
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>special.mcmc_sampling &#8212; special  documentation</title>
    
  <link href="../../_static/css/theme.css" rel="stylesheet">
  <link href="../../_static/css/index.ff1ffe594081f20da1ef19478df9384b.css" rel="stylesheet">

    
  <link rel="stylesheet"
    href="../../_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../../_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../../_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    
      

    
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/sphinx-book-theme.css?digest=84ace793992934648b4de8eed757e5a2" />
    
  <link rel="preload" as="script" href="../../_static/js/index.be7d3bbb2ef33a8344ce.js">

    <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="../../_static/sphinx-book-theme.9d8b4a8b9bb19db25eeaddc40d639ba2.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="None">
    

    <!-- Google Analytics -->
    
  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="80">
    
    <div class="container-fluid" id="banner"></div>

    

    <div class="container-xl">
      <div class="row">
          
<!-- Checkboxes to toggle the left sidebar -->
<input type="checkbox" class="sidebar-toggle" name="__navigation" id="__navigation" aria-label="Toggle navigation sidebar">
<label class="overlay" for="__navigation">
    <div class="visually-hidden">Toggle navigation sidebar</div>
</label>
<div class="col-12 col-md-3 bd-sidebar site-navigation " id="site-navigation">
    
        <div class="navbar-brand-box">
    <a class="navbar-brand text-wrap" href="../../index.html">
      
        <!-- `logo` is deprecated in Sphinx 4.0, so remove this when we stop supporting 3 -->
        
      
      
      <img src="../../_static/Special_logo.jpeg" class="logo" alt="logo">
      
      
    </a>
</div><form class="bd-search d-flex align-items-center" action="../../search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search the docs ..." aria-label="Search the docs ..." autocomplete="off" >
</form><nav class="bd-links" id="bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item active">
        <p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Tutorial
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../../tutorials/walkthrough.html">
   <em>
    special
   </em>
   tutorial
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Index
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../../special.html">
   Module contents
  </a>
 </li>
</ul>

    </div>
</nav> <!-- To handle the deprecated key -->

<div class="navbar_extra_footer">
  Theme by the <a href="https://ebp.jupyterbook.org">Executable Book Project</a>
</div>

</div>


          


          
<!-- This is an invisible pixel that we watch to see if we've scrolled. -->
<div class="sbt-scroll-pixel-helper"></div>
<main class="col py-md-3 pl-md-4 bd-content overflow-auto" role="main">
    
    <div class="topbar container-xl fixed-top">
    <div class="topbar-contents row">
        <div class="col-12 col-md-3 bd-topbar-whitespace site-navigation show"></div>
        <div class="col pl-md-4 topbar-main">
            <div class="topbar-left">
                
                <label class="nav-toggle-button" for="__navigation">
                    <div class="visually-hidden">Toggle navigation</div>
                    <i class="fas fa-bars"></i>
                </label>
                
            </div>
            
            <!-- Source interaction buttons -->

<div class="dropdown-buttons-trigger">
    <button id="dropdown-buttons-trigger" class="btn btn-secondary topbarbtn"
        aria-label="Connect with source repository"><i class="fab fa-github"></i></button>
    <div class="dropdown-buttons sourcebuttons">
        <a class="repository-button"
            href="https://github.com/VChristiaens/special"><button type="button" class="btn btn-secondary topbarbtn"
                data-toggle="tooltip" data-placement="left" title="Source repository"><i
                    class="fab fa-github"></i>repository</button></a>
        <a class="issues-button"
            href="https://github.com/VChristiaens/special/issues/new?title=Issue%20on%20page%20%2F_modules/special/mcmc_sampling.html&body=Your%20issue%20content%20here."><button
                type="button" class="btn btn-secondary topbarbtn" data-toggle="tooltip" data-placement="left"
                title="Open an issue"><i class="fas fa-lightbulb"></i>open issue</button></a>
        
    </div>
</div>

            <!-- Full screen (wrap in <a> to have style consistency -->

<a class="full-screen-button"><button type="button" class="btn btn-secondary topbarbtn" data-toggle="tooltip"
        data-placement="bottom" onclick="toggleFullScreen()" aria-label="Fullscreen mode"
        title="Fullscreen mode"><i
            class="fas fa-expand"></i></button></a>

            <!-- Launch buttons -->

        </div>

        <!-- Table of contents -->
        <div class="d-none d-md-block col-md-2 bd-toc show noprint">
            
        </div>
    </div>
</div>
    <div id="main-content" class="row">
        <div class="col-12 col-md-9 pl-md-3 pr-md-0">
            <!-- Table of contents that is only displayed when printing the page -->
            <div id="jb-print-docs-body" class="onlyprint">
                <h1></h1>
                <!-- Table of contents -->
                <div id="print-main-content">
                    <div id="jb-print-toc">
                        
                    </div>
                </div>
            </div>
            
              <div>
                
  <h1>Source code for special.mcmc_sampling</h1><div class="highlight"><pre>
<span></span><span class="ch">#! /usr/bin/env python</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Module with the MCMC (``emcee``) sampling for model spectra parameter </span>
<span class="sd">estimation.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="n">__author__</span> <span class="o">=</span> <span class="s1">&#39;V. Christiaens&#39;</span>
<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;mcmc_spec_sampling&#39;</span><span class="p">,</span>
           <span class="s1">&#39;lnprob&#39;</span><span class="p">,</span>
           <span class="s1">&#39;lnlike&#39;</span><span class="p">,</span>
           <span class="s1">&#39;chain_zero_truncated&#39;</span><span class="p">,</span>
           <span class="s1">&#39;show_corner_plot&#39;</span><span class="p">,</span>
           <span class="s1">&#39;show_walk_plot&#39;</span><span class="p">,</span>
           <span class="s1">&#39;confidence&#39;</span><span class="p">]</span>

<span class="kn">from</span> <span class="nn">astropy</span> <span class="kn">import</span> <span class="n">constants</span> <span class="k">as</span> <span class="n">con</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">from</span> <span class="nn">os.path</span> <span class="kn">import</span> <span class="n">isdir</span><span class="p">,</span> <span class="n">isfile</span>
<span class="kn">import</span> <span class="nn">emcee</span>
<span class="kn">import</span> <span class="nn">inspect</span>
<span class="kn">import</span> <span class="nn">datetime</span>
<span class="kn">import</span> <span class="nn">corner</span>
<span class="kn">from</span> <span class="nn">matplotlib</span> <span class="kn">import</span> <span class="n">pyplot</span> <span class="k">as</span> <span class="n">plt</span>
<span class="kn">from</span> <span class="nn">matplotlib.ticker</span> <span class="kn">import</span> <span class="n">MaxNLocator</span>
<span class="kn">import</span> <span class="nn">pickle</span>
<span class="kn">from</span> <span class="nn">scipy.stats</span> <span class="kn">import</span> <span class="n">norm</span>
<span class="kn">from</span> <span class="nn">.config</span> <span class="kn">import</span> <span class="n">time_ini</span><span class="p">,</span> <span class="n">timing</span><span class="p">,</span> <span class="n">sep</span>
<span class="kn">from</span> <span class="nn">.fits</span> <span class="kn">import</span> <span class="n">open_fits</span><span class="p">,</span> <span class="n">write_fits</span>
<span class="kn">from</span> <span class="nn">.utils_mcmc</span> <span class="kn">import</span> <span class="n">gelman_rubin</span><span class="p">,</span> <span class="n">autocorr_test</span>
<span class="kn">from</span> <span class="nn">.chi</span> <span class="kn">import</span> <span class="n">goodness_of_fit</span>
<span class="kn">from</span> <span class="nn">.model_resampling</span> <span class="kn">import</span> <span class="n">make_model_from_params</span><span class="p">,</span> <span class="n">make_resampled_models</span>
<span class="kn">from</span> <span class="nn">.utils_spec</span> <span class="kn">import</span> <span class="n">mj_from_rj_and_logg</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="n">warnings</span><span class="o">.</span><span class="n">filterwarnings</span><span class="p">(</span><span class="s2">&quot;ignore&quot;</span><span class="p">,</span> <span class="n">category</span><span class="o">=</span><span class="ne">DeprecationWarning</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">lnprior</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">labels</span><span class="p">,</span> <span class="n">bounds</span><span class="p">,</span> <span class="n">priors</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Define the prior log-function.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    params: tuple</span>
<span class="sd">        The model parameters.</span>
<span class="sd">    labels: Tuple of strings</span>
<span class="sd">        Tuple of labels in the same order as initial_state, that is:</span>
<span class="sd">        - first all parameters related to loaded models (e.g. &#39;Teff&#39;, &#39;logg&#39;)</span>
<span class="sd">        - then the planet photometric radius &#39;R&#39;, in Jupiter radius</span>
<span class="sd">        - (optionally) the flux of emission lines (labels should match those in</span>
<span class="sd">        the em_lines dictionary), in units of the model spectrum (times mu)</span>
<span class="sd">        - (optionally) the optical extinction &#39;Av&#39;, in mag</span>
<span class="sd">        - (optionally) the ratio of total to selective optical extinction &#39;Rv&#39;</span>
<span class="sd">        - (optionally) &#39;Tbb1&#39;, &#39;Rbb1&#39;, &#39;Tbb2&#39;, &#39;Rbb2&#39;, etc. for each extra bb</span>
<span class="sd">        contribution.</span>
<span class="sd">    bounds: dictionary</span>
<span class="sd">        Each entry should be associated with a tuple corresponding to lower and </span>
<span class="sd">        upper bounds respectively. Bounds should be provided for ALL model</span>
<span class="sd">        parameters, including &#39;R&#39; (planet photometric radius). &#39;Av&#39; (optical </span>
<span class="sd">        extinction) is optional. If provided here, Av will also be fitted.</span>
<span class="sd">        All keywords that are neither &#39;R&#39;, &#39;Av&#39; nor &#39;M&#39; will </span>
<span class="sd">        be considered model grid parameters.</span>
<span class="sd">        Example for BT-SETTL: bounds = {&#39;Teff&#39;:(1000,2000), &#39;logg&#39;:(3.0,4.5),</span>
<span class="sd">        &#39;R&#39;:(0.1,5), &#39;Av&#39;:(0.,2.5)}</span>
<span class="sd">        &#39;M&#39; can be used for a prior on the mass of the planet. In that case the</span>
<span class="sd">        corresponding prior log probability is computed from the values for </span>
<span class="sd">        parameters &#39;logg&#39; and &#39;R&#39;.</span>
<span class="sd">    priors: dictionary, opt</span>
<span class="sd">        If not None, sets prior estimates for each parameter of the model. Each </span>
<span class="sd">        entry should be set to either None (no prior) or a tuple of 2 elements </span>
<span class="sd">        containing prior estimate and uncertainty on the estimate.</span>
<span class="sd">        Missing entries (i.e. provided in bounds dictionary but not here) will</span>
<span class="sd">        be associated no prior.</span>
<span class="sd">        e.g. priors = {&#39;Teff&#39;:(1600,100), &#39;logg&#39;:(3.5,0.5),</span>
<span class="sd">                       &#39;R&#39;:(1.6,0.1), &#39;Av&#39;:(1.8,0.2), &#39;M&#39;:(10,3)}</span>
<span class="sd">        Important: dictionary entry names should match exactly those of bounds.</span>
<span class="sd">    </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out: float.</span>
<span class="sd">        If all parameters are within bounds:</span>
<span class="sd">            * 0 if no prior,</span>
<span class="sd">            * the sum of gaussian log proba for each prior otherwise.</span>
<span class="sd">        If at least one model parameters is out of bounds:</span>
<span class="sd">        returns -np.inf </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">n_params</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>
    <span class="n">n_labs</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span>
    <span class="n">n_dico</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">bounds</span><span class="p">)</span>    
    <span class="k">if</span> <span class="n">n_dico</span><span class="o">!=</span><span class="n">n_params</span> <span class="ow">or</span> <span class="n">n_dico</span> <span class="o">!=</span> <span class="n">n_labs</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;params, labels and bounds should have same length&#39;</span><span class="p">)</span>

    <span class="n">cond</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="k">for</span> <span class="n">pp</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_params</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">bounds</span><span class="p">[</span><span class="n">labels</span><span class="p">[</span><span class="n">pp</span><span class="p">]][</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">params</span><span class="p">[</span><span class="n">pp</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">bounds</span><span class="p">[</span><span class="n">labels</span><span class="p">[</span><span class="n">pp</span><span class="p">]][</span><span class="mi">1</span><span class="p">]:</span>
            <span class="n">cond</span><span class="o">=</span><span class="kc">False</span>

    <span class="k">if</span> <span class="n">cond</span><span class="p">:</span>
        <span class="n">lnpri</span> <span class="o">=</span> <span class="mf">0.</span>
        <span class="k">if</span> <span class="n">priors</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">prior</span> <span class="ow">in</span> <span class="n">priors</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">key</span> <span class="o">==</span> <span class="s1">&#39;M&#39;</span> <span class="ow">and</span> <span class="s1">&#39;logg&#39;</span> <span class="ow">in</span> <span class="n">labels</span><span class="p">:</span>
                    <span class="n">idx_logg</span> <span class="o">=</span><span class="n">labels</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s2">&quot;logg&quot;</span><span class="p">)</span>
                    <span class="n">idx_rp</span> <span class="o">=</span> <span class="n">labels</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s2">&quot;R&quot;</span><span class="p">)</span>
                    <span class="n">rp</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="n">idx_rp</span><span class="p">]</span>
                    <span class="n">logg</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="n">idx_logg</span><span class="p">]</span>
                    <span class="n">mp</span> <span class="o">=</span> <span class="n">mj_from_rj_and_logg</span><span class="p">(</span><span class="n">rp</span><span class="p">,</span> <span class="n">logg</span><span class="p">)</span>
                    <span class="n">lnpri</span> <span class="o">+=</span> <span class="o">-</span><span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">mp</span> <span class="o">-</span> <span class="n">prior</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span> <span class="o">/</span> <span class="n">prior</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">idx_prior</span> <span class="o">=</span> <span class="n">labels</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
                    <span class="n">lnpri</span> <span class="o">+=</span> <span class="o">-</span><span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="n">idx_prior</span><span class="p">]</span><span class="o">-</span><span class="n">prior</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="n">prior</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span>
        <span class="k">return</span> <span class="n">lnpri</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span>


<div class="viewcode-block" id="lnlike"><a class="viewcode-back" href="../../special.html#special.mcmc_sampling.lnlike">[docs]</a><span class="k">def</span> <span class="nf">lnlike</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">labels</span><span class="p">,</span> <span class="n">grid_param_list</span><span class="p">,</span> <span class="n">lbda_obs</span><span class="p">,</span> <span class="n">spec_obs</span><span class="p">,</span> <span class="n">err_obs</span><span class="p">,</span> <span class="n">dist</span><span class="p">,</span> 
           <span class="n">model_grid</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">model_reader</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">em_lines</span><span class="o">=</span><span class="p">{},</span> <span class="n">em_grid</span><span class="o">=</span><span class="p">{},</span> 
           <span class="n">dlbda_obs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">instru_corr</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">instru_fwhm</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">instru_idx</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> 
           <span class="n">filter_reader</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">AV_bef_bb</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">units_obs</span><span class="o">=</span><span class="s1">&#39;si&#39;</span><span class="p">,</span> <span class="n">units_mod</span><span class="o">=</span><span class="s1">&#39;si&#39;</span><span class="p">,</span> 
           <span class="n">interp_order</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Define the likelihood log-function.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    params : tuple</span>
<span class="sd">        Set of models parameters for which the model grid has to be </span>
<span class="sd">        interpolated.</span>
<span class="sd">    labels: Tuple of strings</span>
<span class="sd">        Tuple of labels in the same order as initial_state, that is:</span>
<span class="sd">        - first all parameters related to loaded models (e.g. &#39;Teff&#39;, &#39;logg&#39;)</span>
<span class="sd">        - then the planet photometric radius &#39;R&#39;, in Jupiter radius</span>
<span class="sd">        - (optionally) the flux of emission lines (labels should match those \</span>
<span class="sd">        in the em_lines dictionary), in units of the model spectrum (times mu)</span>
<span class="sd">        - (optionally) the optical extinction &#39;Av&#39;, in mag</span>
<span class="sd">        - (optionally) the ratio of total to selective optical extinction &#39;Rv&#39;</span>
<span class="sd">        - (optionally) &#39;Tbb1&#39;, &#39;Rbb1&#39;, &#39;Tbb2&#39;, &#39;Rbb2&#39;, etc. for each extra bb \</span>
<span class="sd">        contribution.</span>
<span class="sd">        </span>
<span class="sd">    grid_param_list : list of 1d numpy arrays/lists OR None</span>
<span class="sd">        - If list, should contain list/numpy 1d arrays with available grid of </span>
<span class="sd">        model parameters. </span>
<span class="sd">        - Set to None for a pure n-blackbody fit, n=1,2,...</span>
<span class="sd">        - Note1: model grids should not contain grids on radius and Av, but </span>
<span class="sd">        these should still be passed in initial_state (Av optional).</span>
<span class="sd">        - Note2: for a combined grid model + black body, just provide</span>
<span class="sd">        the grid parameter list here, and provide values for &#39;Tbbn&#39; and &#39;Rbbn&#39;</span>
<span class="sd">        in initial_state, labels and bounds.</span>
<span class="sd">        </span>
<span class="sd">    lbda_obs : numpy 1d ndarray or list</span>
<span class="sd">        Wavelength of observed spectrum. If several instruments, should be </span>
<span class="sd">        ordered per instrument, not necessarily as monotonically increasing </span>
<span class="sd">        wavelength. Hereafter, n_ch = len(lbda_obs).</span>
<span class="sd">    spec_obs : numpy 1d ndarray or list</span>
<span class="sd">        Observed spectrum for each value of lbda_obs.</span>
<span class="sd">    err_obs : numpy 1d/2d ndarray or list</span>
<span class="sd">        Uncertainties on the observed spectrum. If 2d array, should be [2,n_ch]</span>
<span class="sd">        where the first (resp. second) column corresponds to lower (upper) </span>
<span class="sd">        uncertainty, and n_ch is the length of lbda_obs and spec_obs.</span>
<span class="sd">    dist :  float</span>
<span class="sd">        Distance in parsec, used for flux scaling of the models.</span>
<span class="sd">    model_grid : numpy N-d array, optional</span>
<span class="sd">        If provided, should contain the grid of model spectra for each</span>
<span class="sd">        free parameter of the given grid. I.e. for a grid of n_T values of Teff </span>
<span class="sd">        and n_g values of Logg, the numpy array should be n_T x n_g x n_ch x 2, </span>
<span class="sd">        where n_ch is the number of wavelengths for the observed spectrum,</span>
<span class="sd">        and the last 2 dims are for wavelength and fluxes respectively.</span>
<span class="sd">        If provided, takes precedence over model_name/model_reader.</span>
<span class="sd">    model_reader : python routine, opt</span>
<span class="sd">        External routine that reads a model file and returns a 2D numpy array, </span>
<span class="sd">        where the first column corresponds to wavelengths, and the second </span>
<span class="sd">        contains model values. See example routine in model_interpolation() </span>
<span class="sd">        description.</span>
<span class="sd">    em_lines: dictionary, opt</span>
<span class="sd">        Dictionary of emission lines to be added on top of the model spectrum.</span>
<span class="sd">        Each dict entry should be the name of the line, assigned to a tuple of</span>
<span class="sd">        4 values: </span>
<span class="sd">        1) the wavelength (in mu); </span>
<span class="sd">        2) a string indicating whether line intensity is expressed in flux </span>
<span class="sd">        (&#39;F&#39;), luminosity (&#39;L&#39;) or log(L/LSun) (&quot;LogL&quot;);</span>
<span class="sd">        3) the FWHM of the gaussian (or None if to be set automatically); </span>
<span class="sd">        4) whether the FWHM is expressed in &#39;nm&#39;, &#39;mu&#39; or &#39;km/s&#39;. </span>
<span class="sd">        </span>
<span class="sd">        The third and fourth can also be set to None. In that case, the FWHM of </span>
<span class="sd">        the gaussian will automatically be set to the equivalent width of the</span>
<span class="sd">        line, calculated from the flux to be injected and the continuum </span>
<span class="sd">        level (measured in the grid model to which the line is injected). </span>
<span class="sd">        Examples:</span>
<span class="sd">        - em_lines = {&#39;BrG&#39;:(2.1667,&#39;F&#39;,None, None)};</span>
<span class="sd">        - em_lines = {&#39;BrG&#39;:(2.1667,&#39;LogL&#39;, 100, &#39;km/s&#39;)}</span>
<span class="sd">        </span>
<span class="sd">    em_grid: dictionary pointing to lists, opt</span>
<span class="sd">        Dictionary where each entry corresponds to an emission line and points</span>
<span class="sd">        to a list of values to inject for emission line fluxes. For computation</span>
<span class="sd">        efficiency, interpolation will be performed between the points of this</span>
<span class="sd">        grid during the MCMC sampling. Dict entries should match labels and </span>
<span class="sd">        em_lines.</span>
<span class="sd">    dlbda_obs: numpy 1d ndarray or list, optional</span>
<span class="sd">        Spectral channel width for the observed spectrum. It should be provided </span>
<span class="sd">        IF one wants to weigh each point based on the spectral resolution of </span>
<span class="sd">        the respective instruments (as in Olofsson et al. 2016).</span>
<span class="sd">    instru_corr : numpy 2d ndarray or list, optional</span>
<span class="sd">        Spectral correlation throughout post-processed images in which the </span>
<span class="sd">        spectrum is measured. It is specific to the combination of instrument, </span>
<span class="sd">        algorithm and radial separation of the companion from the central star.</span>
<span class="sd">        Can be computed using distances.spectral_correlation(). In case of</span>
<span class="sd">        a spectrum obtained with different instruments, build it with</span>
<span class="sd">        distances.combine_corrs(). If not provided, it will consider the </span>
<span class="sd">        uncertainties in each spectral channels are independent. See Greco &amp; </span>
<span class="sd">        Brandt (2017) for details.</span>
<span class="sd">    instru_fwhm : float or list, optional</span>
<span class="sd">        The instrumental spectral fwhm provided in nm. This is used to convolve</span>
<span class="sd">        the model spectrum. If several instruments are used, provide a list of </span>
<span class="sd">        instru_fwhm values, one for each instrument whose spectral resolution</span>
<span class="sd">        is coarser than the model - including broad band</span>
<span class="sd">        filter FWHM if relevant.</span>
<span class="sd">    instru_idx: numpy 1d array, optional</span>
<span class="sd">        1d array containing an index representing each instrument used </span>
<span class="sd">        to obtain the spectrum, label them from 0 to n_instru. Zero for points </span>
<span class="sd">        that don&#39;t correspond to any instru_fwhm provided above, and i in </span>
<span class="sd">        [1,n_instru] for points associated to instru_fwhm[i-1]. This parameter </span>
<span class="sd">        must be provided if the spectrum consists of points obtained with </span>
<span class="sd">        different instruments.</span>
<span class="sd">    filter_reader: python routine, optional</span>
<span class="sd">        External routine that reads a filter file and returns a 2D numpy array, </span>
<span class="sd">        where the first column corresponds to wavelengths, and the second </span>
<span class="sd">        contains transmission values. Important: if not provided, but strings </span>
<span class="sd">        are detected in instru_fwhm, the default format assumed for the files:</span>
<span class="sd">        - first row containing header</span>
<span class="sd">        - starting from 2nd row: 1st column: WL in mu, 2nd column: transmission</span>
<span class="sd">        Note: files should all have the same format and wavelength units.</span>
<span class="sd">    AV_bef_bb: bool, optional</span>
<span class="sd">        If both extinction and an extra bb component are free parameters, </span>
<span class="sd">        whether to apply extinction before adding the BB component (e.g. </span>
<span class="sd">        extinction mostly from circumplanetary dust) or after the BB component</span>
<span class="sd">        (e.g. mostly insterstellar extinction).</span>
<span class="sd">    units_obs : str, opt {&#39;si&#39;,&#39;cgs&#39;,&#39;jy&#39;}</span>
<span class="sd">        Units of observed spectrum. &#39;si&#39; for W/m^2/mu; &#39;cgs&#39; for ergs/s/cm^2/mu </span>
<span class="sd">        or &#39;jy&#39; for janskys.</span>
<span class="sd">    units_mod: str, opt {&#39;si&#39;,&#39;cgs&#39;,&#39;jy&#39;}</span>
<span class="sd">        Units of the model. &#39;si&#39; for W/m^2/mu; &#39;cgs&#39; for ergs/s/cm^2/mu or &#39;jy&#39;</span>
<span class="sd">        for janskys. If different to units_obs, the spectrum units will be </span>
<span class="sd">        converted.</span>
<span class="sd">    interp_order: int, opt, {-1,0,1} </span>
<span class="sd">        Interpolation mode for model interpolation.</span>
<span class="sd">        -1: log interpolation (i.e. linear interpolatlion on log(Flux))</span>
<span class="sd">        0: nearest neighbour model.</span>
<span class="sd">        1: Order 1 spline interpolation.</span>
<span class="sd">        </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out: float</span>
<span class="sd">        The log of the likelihood.</span>
<span class="sd">        </span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">grid_param_list</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">model_grid</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">model_reader</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;model_name and model_reader must be provided&quot;</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
                         
    <span class="n">lbda_mod</span><span class="p">,</span> <span class="n">spec_mod</span> <span class="o">=</span> <span class="n">make_model_from_params</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">labels</span><span class="p">,</span> <span class="n">grid_param_list</span><span class="p">,</span> 
                                                <span class="n">dist</span><span class="p">,</span> <span class="n">lbda_obs</span><span class="p">,</span> <span class="n">model_grid</span><span class="p">,</span> 
                                                <span class="n">model_reader</span><span class="p">,</span> <span class="n">em_lines</span><span class="p">,</span> <span class="n">em_grid</span><span class="p">,</span> 
                                                <span class="n">dlbda_obs</span><span class="p">,</span> <span class="n">instru_fwhm</span><span class="p">,</span> 
                                                <span class="n">instru_idx</span><span class="p">,</span> <span class="n">filter_reader</span><span class="p">,</span> 
                                                <span class="n">AV_bef_bb</span><span class="p">,</span> <span class="n">units_obs</span><span class="p">,</span> <span class="n">units_mod</span><span class="p">,</span> 
                                                <span class="n">interp_order</span><span class="p">)</span>
     
    <span class="c1"># evaluate the goodness of fit indicator</span>
    <span class="n">chi</span> <span class="o">=</span> <span class="n">goodness_of_fit</span><span class="p">(</span><span class="n">lbda_obs</span><span class="p">,</span> <span class="n">spec_obs</span><span class="p">,</span> <span class="n">err_obs</span><span class="p">,</span> <span class="n">lbda_mod</span><span class="p">,</span> <span class="n">spec_mod</span><span class="p">,</span> 
                          <span class="n">dlbda_obs</span><span class="o">=</span><span class="n">dlbda_obs</span><span class="p">,</span> <span class="n">instru_corr</span><span class="o">=</span><span class="n">instru_corr</span><span class="p">,</span> 
                          <span class="n">instru_fwhm</span><span class="o">=</span><span class="n">instru_fwhm</span><span class="p">,</span> <span class="n">instru_idx</span><span class="o">=</span><span class="n">instru_idx</span><span class="p">,</span> 
                          <span class="n">filter_reader</span><span class="o">=</span><span class="n">filter_reader</span><span class="p">,</span> <span class="n">plot</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">outfile</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
    
    <span class="c1"># log likelihood</span>
    <span class="n">lnlikelihood</span> <span class="o">=</span> <span class="o">-</span><span class="mf">0.5</span> <span class="o">*</span> <span class="n">chi</span>
    
    <span class="k">return</span> <span class="n">lnlikelihood</span></div>


<div class="viewcode-block" id="lnprob"><a class="viewcode-back" href="../../special.html#special.mcmc_sampling.lnprob">[docs]</a><span class="k">def</span> <span class="nf">lnprob</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">labels</span><span class="p">,</span> <span class="n">bounds</span><span class="p">,</span> <span class="n">grid_param_list</span><span class="p">,</span> <span class="n">lbda_obs</span><span class="p">,</span> <span class="n">spec_obs</span><span class="p">,</span> <span class="n">err_obs</span><span class="p">,</span> 
           <span class="n">dist</span><span class="p">,</span> <span class="n">model_grid</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">model_reader</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">em_lines</span><span class="o">=</span><span class="p">{},</span> <span class="n">em_grid</span><span class="o">=</span><span class="p">{},</span> 
           <span class="n">dlbda_obs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">instru_corr</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">instru_fwhm</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">instru_idx</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> 
           <span class="n">filter_reader</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">AV_bef_bb</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">units_obs</span><span class="o">=</span><span class="s1">&#39;si&#39;</span><span class="p">,</span> <span class="n">units_mod</span><span class="o">=</span><span class="s1">&#39;si&#39;</span><span class="p">,</span> 
           <span class="n">interp_order</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">priors</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">physical</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Define the probability log-function as the sum between the prior and</span>
<span class="sd">    likelihood log-functions.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    params: tuple</span>
<span class="sd">        The model parameters.</span>
<span class="sd">    labels: Tuple of strings</span>
<span class="sd">        Tuple of labels in the same order as initial_state, that is:</span>
<span class="sd">        - first all parameters related to loaded models (e.g. &#39;Teff&#39;, &#39;logg&#39;)</span>
<span class="sd">        - then the planet photometric radius &#39;R&#39;, in Jupiter radius</span>
<span class="sd">        - (optionally) the flux of emission lines (labels should match those \</span>
<span class="sd">        in the em_lines dictionary), in units of the model spectrum (times mu)</span>
<span class="sd">        - (optionally) the optical extinction &#39;Av&#39;, in mag</span>
<span class="sd">        - (optionally) the ratio of total to selective optical extinction &#39;Rv&#39;</span>
<span class="sd">        - (optionally) &#39;Tbb1&#39;, &#39;Rbb1&#39;, &#39;Tbb2&#39;, &#39;Rbb2&#39;, etc. for each extra bb \</span>
<span class="sd">        contribution.</span>
<span class="sd">    bounds: dictionary</span>
<span class="sd">        Each entry should be associated with a tuple corresponding to lower and </span>
<span class="sd">        upper bounds respectively. Bounds should be provided for ALL model</span>
<span class="sd">        parameters, including &#39;R&#39; (planet photometric radius). &#39;Av&#39; (optical </span>
<span class="sd">        extinction) is optional. If provided here, Av will also be fitted.</span>
<span class="sd">        All keywords that are neither &#39;R&#39;, &#39;Av&#39; nor &#39;M&#39; will </span>
<span class="sd">        be considered model grid parameters.</span>
<span class="sd">        Example for BT-SETTL: bounds = {&#39;Teff&#39;:(1000,2000), &#39;logg&#39;:(3.0,4.5),</span>
<span class="sd">        &#39;R&#39;:(0.1,5), &#39;Av&#39;:(0.,2.5)}</span>
<span class="sd">        &#39;M&#39; can be used for a prior on the mass of the planet. In that case the</span>
<span class="sd">        corresponding prior log probability is computed from the values for </span>
<span class="sd">        parameters &#39;logg&#39; and &#39;R&#39;.</span>
<span class="sd">    grid_param_list : list of 1d numpy arrays/lists OR None</span>
<span class="sd">        - If list, should contain list/numpy 1d arrays with available grid of \</span>
<span class="sd">        model parameters. </span>
<span class="sd">        - Set to None for a pure n-blackbody fit, n=1,2,...</span>
<span class="sd">        - Note1: model grids should not contain grids on radius and Av, but \</span>
<span class="sd">        these should still be passed in initial_state (Av optional).</span>
<span class="sd">        - Note2: for a combined grid model + black body, just provide \</span>
<span class="sd">        the grid parameter list here, and provide values for &#39;Tbbn&#39; and &#39;Rbbn&#39; \</span>
<span class="sd">        in initial_state, labels and bounds.</span>
<span class="sd">    lbda_obs : numpy 1d ndarray or list</span>
<span class="sd">        Wavelength of observed spectrum. If several instruments, should be </span>
<span class="sd">        ordered per instrument, not necessarily as monotonically increasing </span>
<span class="sd">        wavelength. Hereafter, n_ch = len(lbda_obs).</span>
<span class="sd">    spec_obs : numpy 1d ndarray or list</span>
<span class="sd">        Observed spectrum for each value of lbda_obs.</span>
<span class="sd">    err_obs : numpy 1d/2d ndarray or list</span>
<span class="sd">        Uncertainties on the observed spectrum. If 2d array, should be [2,n_ch]</span>
<span class="sd">        where the first (resp. second) column corresponds to lower (upper) </span>
<span class="sd">        uncertainty, and n_ch is the length of lbda_obs and spec_obs.</span>
<span class="sd">    dist :  float</span>
<span class="sd">        Distance in parsec, used for flux scaling of the models.</span>
<span class="sd">    model_grid : numpy N-d array, optional</span>
<span class="sd">        If provided, should contain the grid of model spectra for each</span>
<span class="sd">        free parameter of the given grid. I.e. for a grid of n_T values of Teff </span>
<span class="sd">        and n_g values of Logg, the numpy array should be n_T x n_g x n_ch x 2, </span>
<span class="sd">        where n_ch is the number of wavelengths for the observed spectrum,</span>
<span class="sd">        and the last 2 dims are for wavelength and fluxes respectively.</span>
<span class="sd">        If provided, takes precedence over model_name/model_reader.</span>
<span class="sd">    model_reader : python routine</span>
<span class="sd">        External routine that reads a model file and returns a 2D numpy array, </span>
<span class="sd">        where the first column corresponds to wavelengths, and the second </span>
<span class="sd">        contains model values. See example routine in model_interpolation() </span>
<span class="sd">        description.</span>
<span class="sd">    em_lines: dictionary, opt</span>
<span class="sd">        Dictionary of emission lines to be added on top of the model spectrum.</span>
<span class="sd">        Each dict entry should be the name of the line, assigned to a tuple of</span>
<span class="sd">        4 values: </span>
<span class="sd">        1) the wavelength (in mu); </span>
<span class="sd">        2) a string indicating whether line intensity is expressed in flux </span>
<span class="sd">        (&#39;F&#39;), luminosity (&#39;L&#39;) or log(L/LSun) (&quot;LogL&quot;);</span>
<span class="sd">        3) the FWHM of the gaussian (or None if to be set automatically); </span>
<span class="sd">        4) whether the FWHM is expressed in &#39;nm&#39;, &#39;mu&#39; or &#39;km/s&#39;. </span>
<span class="sd">        The third and fourth can also be set to None. In that case, the FWHM of </span>
<span class="sd">        the gaussian will automatically be set to the equivalent width of the</span>
<span class="sd">        line, calculated from the flux to be injected and the continuum </span>
<span class="sd">        level (measured in the grid model to which the line is injected). </span>
<span class="sd">        Examples:</span>
<span class="sd">        em_lines = {&#39;BrG&#39;:(2.1667,&#39;F&#39;,None, None)};</span>
<span class="sd">        em_lines = {&#39;BrG&#39;:(2.1667,&#39;LogL&#39;, 100, &#39;km/s&#39;)}</span>
<span class="sd">    em_grid: dictionary pointing to lists, opt</span>
<span class="sd">        Dictionary where each entry corresponds to an emission line and points</span>
<span class="sd">        to a list of values to inject for emission line fluxes. For computation </span>
<span class="sd">        efficiency, interpolation will be performed between the points of this </span>
<span class="sd">        grid during the MCMC sampling. Dict entries should match labels and </span>
<span class="sd">        em_lines.</span>
<span class="sd">    dlbda_obs: numpy 1d ndarray or list, optional</span>
<span class="sd">        Spectral channel width for the observed spectrum. It should be provided </span>
<span class="sd">        IF one wants to weigh each point based on the spectral </span>
<span class="sd">        resolution of the respective instruments (as in Olofsson et al. 2016).</span>
<span class="sd">    instru_corr : numpy 2d ndarray or list, optional</span>
<span class="sd">        Spectral correlation throughout post-processed images in which the </span>
<span class="sd">        spectrum is measured. It is specific to the combination of instrument, </span>
<span class="sd">        algorithm and radial separation of the companion from the central star.</span>
<span class="sd">        Can be computed using distances.spectral_correlation(). In case of</span>
<span class="sd">        a spectrum obtained with different instruments, build it with</span>
<span class="sd">        distances.combine_corrs(). If not provided, it will consider the </span>
<span class="sd">        uncertainties in each spectral channels are independent. See Greco &amp; </span>
<span class="sd">        Brandt (2017) for details.</span>
<span class="sd">    instru_fwhm : float or list, optional</span>
<span class="sd">        The instrumental spectral fwhm provided in nm. This is used to convolve</span>
<span class="sd">        the model spectrum. If several instruments are used, provide a list of </span>
<span class="sd">        instru_fwhm values, one for each instrument whose spectral resolution</span>
<span class="sd">        is coarser than the model - including broad band</span>
<span class="sd">        filter FWHM if relevant.</span>
<span class="sd">    instru_idx: numpy 1d array, optional</span>
<span class="sd">        1d array containing an index representing each instrument used </span>
<span class="sd">        to obtain the spectrum, label them from 0 to n_instru. Zero for points </span>
<span class="sd">        that don&#39;t correspond to any instru_fwhm provided above, and i in </span>
<span class="sd">        [1,n_instru] for points associated to instru_fwhm[i-1]. This parameter </span>
<span class="sd">        must be provided if the spectrum consists of points obtained with </span>
<span class="sd">        different instruments.</span>
<span class="sd">    filter_reader: python routine, optional</span>
<span class="sd">        External routine that reads a filter file and returns a 2D numpy array, </span>
<span class="sd">        where the first column corresponds to wavelengths, and the second </span>
<span class="sd">        contains transmission values. Important: if not provided, but strings </span>
<span class="sd">        are detected in instru_fwhm, the default format assumed for the files:</span>
<span class="sd">        - first row containing header</span>
<span class="sd">        - starting from 2nd row: 1st column: WL in mu, 2nd column: transmission</span>
<span class="sd">        Note: files should all have the same format and wavelength units.</span>
<span class="sd">    AV_bef_bb: bool, optional</span>
<span class="sd">        If both extinction and an extra bb component are free parameters, </span>
<span class="sd">        whether to apply extinction before adding the BB component (e.g. </span>
<span class="sd">        extinction mostly from circumplanetary dust) or after the BB component</span>
<span class="sd">        (e.g. mostly insterstellar extinction).</span>
<span class="sd">    units_obs : str, opt {&#39;si&#39;,&#39;cgs&#39;,&#39;jy&#39;}</span>
<span class="sd">        Units of observed spectrum. &#39;si&#39; for W/m^2/mu; &#39;cgs&#39; for ergs/s/cm^2/mu </span>
<span class="sd">        or &#39;jy&#39; for janskys.</span>
<span class="sd">    units_mod: str, opt {&#39;si&#39;,&#39;cgs&#39;,&#39;jy&#39;}</span>
<span class="sd">        Units of the model. &#39;si&#39; for W/m^2/mu; &#39;cgs&#39; for ergs/s/cm^2/mu or &#39;jy&#39;</span>
<span class="sd">        for janskys. If different to units_obs, the spectrum units will be </span>
<span class="sd">        converted.</span>
<span class="sd">    interp_order: int, opt, {-1,0,1} </span>
<span class="sd">        Interpolation mode for model interpolation.</span>
<span class="sd">        -1: log interpolation (i.e. linear interpolatlion on log(Flux))</span>
<span class="sd">        0: nearest neighbour model.</span>
<span class="sd">        1: Order 1 spline interpolation.</span>
<span class="sd">    priors: dictionary, opt</span>
<span class="sd">        If not None, sets prior estimates for each parameter of the model. Each </span>
<span class="sd">        entry should be set to either None (no prior) or a tuple of 2 elements </span>
<span class="sd">        containing prior estimate and uncertainty on the estimate.</span>
<span class="sd">        Missing entries (i.e. provided in bounds dictionary but not here) will</span>
<span class="sd">        be associated no prior.</span>
<span class="sd">        e.g. priors = {&#39;Teff&#39;:(1600,100), &#39;logg&#39;:(3.5,0.5), &#39;R&#39;:(1.6,0.1), </span>
<span class="sd">        &#39;Av&#39;:(1.8,0.2), &#39;M&#39;:(10,3)}</span>
<span class="sd">        </span>
<span class="sd">        Important: dictionary entry names should match exactly those of bounds.</span>
<span class="sd">    physical: bool, opt</span>
<span class="sd">        In case of extra black body component(s) to a photosphere, whether to </span>
<span class="sd">        force lower temperature than the photosphere effective temperature.</span>
<span class="sd">        </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out: float</span>
<span class="sd">        The probability log-function.</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">lp</span> <span class="o">=</span> <span class="n">lnprior</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">labels</span><span class="p">,</span> <span class="n">bounds</span><span class="p">,</span> <span class="n">priors</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isinf</span><span class="p">(</span><span class="n">lp</span><span class="p">):</span>
        <span class="k">return</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span>
    
    <span class="k">if</span> <span class="s1">&#39;Tbb1&#39;</span> <span class="ow">in</span> <span class="n">labels</span><span class="p">:</span>
        <span class="n">condT</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;T&#39;</span> <span class="ow">in</span> <span class="n">labels</span> <span class="ow">or</span> <span class="s1">&#39;Teff&#39;</span> <span class="ow">in</span> <span class="n">labels</span><span class="p">)</span>
        <span class="n">n_bb</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">labels</span><span class="p">:</span>
            <span class="k">if</span> <span class="s1">&#39;Tbb&#39;</span> <span class="ow">in</span> <span class="n">label</span><span class="p">:</span>
                <span class="n">n_bb</span><span class="o">+=</span><span class="mi">1</span>
        <span class="n">idx_Tbb1</span> <span class="o">=</span> <span class="n">labels</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s2">&quot;Tbb1&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_bb</span><span class="p">):</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">ii</span><span class="o">*</span><span class="mi">2</span>
            <span class="k">if</span> <span class="n">grid_param_list</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">condT</span><span class="p">:</span>
                <span class="k">if</span> <span class="s1">&#39;T&#39;</span> <span class="ow">in</span> <span class="n">labels</span><span class="p">:</span>
                    <span class="n">idx_Teff</span> <span class="o">=</span> <span class="n">labels</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">idx_Teff</span> <span class="o">=</span> <span class="n">labels</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s2">&quot;Teff&quot;</span><span class="p">)</span>
                <span class="c1"># COND 1: only allow Tbb &lt; Teff</span>
                <span class="k">if</span> <span class="n">physical</span> <span class="ow">and</span> <span class="n">params</span><span class="p">[</span><span class="n">idx_Tbb1</span><span class="o">+</span><span class="n">idx</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">params</span><span class="p">[</span><span class="n">idx_Teff</span><span class="p">]:</span>
                    <span class="k">return</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span>
                <span class="k">elif</span> <span class="n">physical</span><span class="p">:</span>
                    <span class="n">idx_R</span><span class="o">=</span> <span class="n">labels</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s2">&quot;R&quot;</span><span class="p">)</span>
                    <span class="n">R</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="n">idx_R</span><span class="p">]</span>
                    <span class="n">Rbb</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="n">idx_Tbb1</span><span class="o">+</span><span class="n">idx</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">Rbb</span><span class="o">&lt;=</span><span class="n">R</span><span class="p">:</span>
                        <span class="k">pass</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">Teq</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="n">idx_Teff</span><span class="p">]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">R</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">Rbb</span><span class="p">))</span>
                        <span class="c1"># COND 2: only allow Tbb &lt;= Teq at Rbb</span>
                        <span class="k">if</span> <span class="n">params</span><span class="p">[</span><span class="n">idx_Tbb1</span><span class="o">+</span><span class="n">idx</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">Teq</span><span class="p">:</span>
                            <span class="k">return</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span>
            <span class="k">if</span> <span class="n">ii</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
                <span class="c1"># avoid unnecessary degenerecaies by only allowing:</span>
                <span class="c1"># Teff1 &gt; Teff2, Teff2 &gt; Teff3</span>
                <span class="k">if</span> <span class="n">params</span><span class="p">[</span><span class="n">idx_Tbb1</span><span class="o">+</span><span class="n">idx</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">params</span><span class="p">[</span><span class="n">idx_Tbb1</span><span class="o">+</span><span class="n">idx</span><span class="o">-</span><span class="mi">2</span><span class="p">]:</span>
                    <span class="k">return</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span>
        
    <span class="k">return</span> <span class="n">lp</span> <span class="o">+</span> <span class="n">lnlike</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">labels</span><span class="p">,</span> <span class="n">grid_param_list</span><span class="p">,</span> <span class="n">lbda_obs</span><span class="p">,</span> <span class="n">spec_obs</span><span class="p">,</span> 
                            <span class="n">err_obs</span><span class="p">,</span> <span class="n">dist</span><span class="p">,</span> <span class="n">model_grid</span><span class="p">,</span> <span class="n">model_reader</span><span class="p">,</span> <span class="n">em_lines</span><span class="p">,</span>
                            <span class="n">em_grid</span><span class="p">,</span> <span class="n">dlbda_obs</span><span class="p">,</span> <span class="n">instru_corr</span><span class="p">,</span> <span class="n">instru_fwhm</span><span class="p">,</span> 
                            <span class="n">instru_idx</span><span class="p">,</span> <span class="n">filter_reader</span><span class="p">,</span> <span class="n">AV_bef_bb</span><span class="p">,</span> <span class="n">units_obs</span><span class="p">,</span> 
                            <span class="n">units_mod</span><span class="p">,</span> <span class="n">interp_order</span><span class="p">)</span></div>


<div class="viewcode-block" id="mcmc_spec_sampling"><a class="viewcode-back" href="../../special.html#special.mcmc_sampling.mcmc_spec_sampling">[docs]</a><span class="k">def</span> <span class="nf">mcmc_spec_sampling</span><span class="p">(</span><span class="n">lbda_obs</span><span class="p">,</span> <span class="n">spec_obs</span><span class="p">,</span> <span class="n">err_obs</span><span class="p">,</span> <span class="n">dist</span><span class="p">,</span> <span class="n">grid_param_list</span><span class="p">,</span> 
                       <span class="n">initial_state</span><span class="p">,</span> <span class="n">labels</span><span class="p">,</span> <span class="n">bounds</span><span class="p">,</span> <span class="n">resamp_before</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> 
                       <span class="n">model_grid</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">model_reader</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">em_lines</span><span class="o">=</span><span class="p">{},</span> 
                       <span class="n">em_grid</span><span class="o">=</span><span class="p">{},</span> <span class="n">dlbda_obs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">instru_corr</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> 
                       <span class="n">instru_fwhm</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">instru_idx</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">filter_reader</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> 
                       <span class="n">AV_bef_bb</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">units_obs</span><span class="o">=</span><span class="s1">&#39;si&#39;</span><span class="p">,</span> <span class="n">units_mod</span><span class="o">=</span><span class="s1">&#39;si&#39;</span><span class="p">,</span> 
                       <span class="n">interp_order</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">priors</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">physical</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> 
                       <span class="n">interp_nonexist</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">ini_ball</span><span class="o">=</span><span class="mf">1e-1</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="mf">2.0</span><span class="p">,</span> 
                       <span class="n">nwalkers</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span> <span class="n">niteration_min</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">niteration_limit</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span> 
                       <span class="n">niteration_supp</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">check_maxgap</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span> <span class="n">conv_test</span><span class="o">=</span><span class="s1">&#39;ac&#39;</span><span class="p">,</span> 
                       <span class="n">ac_c</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span> <span class="n">ac_count_thr</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">burnin</span><span class="o">=</span><span class="mf">0.3</span><span class="p">,</span> <span class="n">rhat_threshold</span><span class="o">=</span><span class="mf">1.01</span><span class="p">,</span> 
                       <span class="n">rhat_count_threshold</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">grid_name</span><span class="o">=</span><span class="s1">&#39;resamp_grid.fits&#39;</span><span class="p">,</span> 
                       <span class="n">output_dir</span><span class="o">=</span><span class="s1">&#39;special/&#39;</span><span class="p">,</span> <span class="n">output_file</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">nproc</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> 
                       <span class="n">display</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">verbosity</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">save</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Runs an affine invariant MCMC sampling algorithm in order to determine</span>
<span class="sd">    the most likely parameters for given spectral model and observed spectrum. </span>
<span class="sd">    Allowed features:</span>
<span class="sd">        </span>
<span class="sd">    * Spectral models can either be read from a grid (e.g. BT-SETTL) or \</span>
<span class="sd">    be purely parametric (e.g. a blackbody model).</span>
<span class="sd">    * Extinction (A_V) and total-to-selective optical extinction ratio \</span>
<span class="sd">    (R_V) can be sampled. Default: A_V=0. If non-zero, default R_V=3.1 (ISM).</span>
<span class="sd">    * A dictionary of emission lines can be provided and their flux can \</span>
<span class="sd">    be sampled too.</span>
<span class="sd">    * Gaussian priors can be provided for each parameter, including the \</span>
<span class="sd">    mass of the object. The latter will be used if &#39;logg&#39; is a parameter.</span>
<span class="sd">    * Spectral correlation between measurements will be taken into account \ </span>
<span class="sd">    if provided in &#39;instru_corr&#39;.</span>
<span class="sd">    * Convolution of the model spectra with instrumental FWHM or \</span>
<span class="sd">    photometric filter can be performed using &#39;instru_fwhm&#39; and/or \</span>
<span class="sd">    &#39;filter_reader&#39; (done before resampling to observed).</span>
<span class="sd">    * The weight of each observed point will be directly proportional to \</span>
<span class="sd">    Delta lbda_i/lbda_i, where Delta lbda_i is either the FWHM of the \</span>
<span class="sd">    photometric filter (imager) or the width of the spectral channel (IFS).</span>
<span class="sd">    * MCMC convergence criterion can either be based on auto-correlation \</span>
<span class="sd">    time (default) or the Gelman-Rubin test.</span>
<span class="sd">        </span>
<span class="sd">    The result of this procedure is a chain with the samples from the posterior </span>
<span class="sd">    distributions of each of the free parameters in the model.</span>
<span class="sd">    More details in Christiaens et al. (2021).</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    lbda_obs : numpy 1d ndarray or list</span>
<span class="sd">        Wavelength of observed spectrum. If several instruments, should be </span>
<span class="sd">        ordered per instrument, not necessarily as monotonically increasing </span>
<span class="sd">        wavelength. Hereafter, n_ch = len(lbda_obs).</span>
<span class="sd">    spec_obs : numpy 1d ndarray or list</span>
<span class="sd">        Observed spectrum for each value of lbda_obs.</span>
<span class="sd">    err_obs : numpy 1d/2d ndarray or list</span>
<span class="sd">        Uncertainties on the observed spectrum. If 2d array, should be [2,n_ch]</span>
<span class="sd">        where the first (resp. second) column corresponds to lower (upper) </span>
<span class="sd">        uncertainty, and n_ch is the length of lbda_obs and spec_obs.</span>
<span class="sd">    dist :  float</span>
<span class="sd">        Distance in parsec, used for flux scaling of the models.</span>
<span class="sd">    grid_param_list : list of 1d numpy arrays/lists OR None</span>
<span class="sd">        - If list, should contain list/numpy 1d arrays with available grid of \</span>
<span class="sd">        model parameters. </span>
<span class="sd">        - Set to None for a pure n-blackbody fit, n=1,2,...</span>
<span class="sd">        - Note1: model grids should not contain grids on radius and Av, but \</span>
<span class="sd">        these should still be passed in initial_state (Av optional).</span>
<span class="sd">        - Note2: for a combined grid model + black body, just provide \</span>
<span class="sd">        the grid parameter list here, and provide values for &#39;Tbbn&#39; and &#39;Rbbn&#39; \</span>
<span class="sd">        in initial_state, labels and bounds.</span>
<span class="sd">        </span>
<span class="sd">    initial_state: tuple of floats</span>
<span class="sd">        Initial guess on the best fit parameters of the spectral fit. Length of </span>
<span class="sd">        the tuple should match the total number of free parameters. Walkers</span>
<span class="sd">        will all be initialised in a small ball of parameter space around that</span>
<span class="sd">        first guess.</span>
<span class="sd">        - first all parameters related to loaded models (e.g. &#39;Teff&#39;, &#39;logg&#39;)</span>
<span class="sd">        - then the planet photometric radius &#39;R&#39;, in Jupiter radius</span>
<span class="sd">        - (optionally) the intensity of emission lines (labels must match \</span>
<span class="sd">        those in the em_lines dict), in units of the model spectrum (x mu)</span>
<span class="sd">        - (optionally) the optical extinction &#39;Av&#39;, in mag</span>
<span class="sd">        - (optionally) the ratio of total to selective optical extinction &#39;Rv&#39;</span>
<span class="sd">        - (optionally) &#39;Tbb1&#39;, &#39;Rbb1&#39;, &#39;Tbb2&#39;, &#39;Rbb2&#39;, etc. for each extra bb \</span>
<span class="sd">        contribution</span>
<span class="sd">        </span>
<span class="sd">    labels: Tuple of strings</span>
<span class="sd">        Tuple of labels in the same order as initial_state, that is:</span>
<span class="sd">        - first all parameters related to loaded models (e.g. &#39;Teff&#39;, &#39;logg&#39;)</span>
<span class="sd">        - then the planet photometric radius &#39;R&#39;, in Jupiter radius</span>
<span class="sd">        - (optionally) the flux of emission lines (labels should match those \</span>
<span class="sd">        in the em_lines dictionary), in units of the model spectrum (times mu)</span>
<span class="sd">        - (optionally) the optical extinction &#39;Av&#39;, in mag</span>
<span class="sd">        - (optionally) the ratio of total to selective optical extinction &#39;Rv&#39;</span>
<span class="sd">        - (optionally) &#39;Tbb1&#39;, &#39;Rbb1&#39;, &#39;Tbb2&#39;, &#39;Rbb2&#39;, etc. for each extra bb \</span>
<span class="sd">        contribution.</span>
<span class="sd">        </span>
<span class="sd">    bounds: dictionary</span>
<span class="sd">        Each entry should be associated with a tuple corresponding to lower and </span>
<span class="sd">        upper bounds respectively. Bounds should be provided for ALL model</span>
<span class="sd">        parameters, including &#39;R&#39; (planet photometric radius). &#39;Av&#39; (optical </span>
<span class="sd">        extinction) is optional. If provided here, Av will also be fitted.</span>
<span class="sd">        Example for BT-SETTL: bounds = {&#39;Teff&#39;:(1000,2000), &#39;logg&#39;:(3.0,4.5),</span>
<span class="sd">        &#39;R&#39;:(0.1,5), &#39;Av&#39;:(0.,2.5)}</span>
<span class="sd">        &#39;M&#39; can be used for a prior on the mass of the planet. In that case the</span>
<span class="sd">        corresponding prior log probability is computed from the values for </span>
<span class="sd">        parameters &#39;logg&#39; and &#39;R&#39; (if both exist).</span>
<span class="sd">    resamp_before: bool, optional</span>
<span class="sd">        Whether to prepare the whole grid of resampled models before entering </span>
<span class="sd">        the MCMC, i.e. to avoid doing it at every MCMC step. Recommended.</span>
<span class="sd">        Only reason not to: model grid is too large and individual models </span>
<span class="sd">        require being opened and resampled at each step.</span>
<span class="sd">    model_grid : numpy N-d array, optional</span>
<span class="sd">        If provided, should contain the grid of model spectra for each</span>
<span class="sd">        free parameter of the given grid. I.e. for a grid of n_T values of Teff </span>
<span class="sd">        and n_g values of Logg, the numpy array should be n_T x n_g x n_ch x 2, </span>
<span class="sd">        where n_ch is the number of wavelengths for the observed spectrum,</span>
<span class="sd">        and the last 2 dims are for wavelength and fluxes respectively.</span>
<span class="sd">        If provided, takes precedence over filename/file_reader.</span>
<span class="sd">    model_reader : python routine, optional</span>
<span class="sd">        External routine that reads a model file and returns a 2D numpy array, </span>
<span class="sd">        where the first column corresponds to wavelengths, and the second </span>
<span class="sd">        contains model values. See example routine in model_interpolation() </span>
<span class="sd">        description.</span>
<span class="sd">    em_lines: dictionary, opt</span>
<span class="sd">        Dictionary of emission lines to be added on top of the model spectrum.</span>
<span class="sd">        Each dict entry should be the name of the line, assigned to a tuple of</span>
<span class="sd">        4 values: </span>
<span class="sd">        1) the wavelength (in mu); </span>
<span class="sd">        2) a string indicating whether line intensity is expressed in flux </span>
<span class="sd">        (&#39;F&#39;), luminosity (&#39;L&#39;) or log(L/LSun) (&quot;LogL&quot;);</span>
<span class="sd">        3) the FWHM of the gaussian (or None if to be set automatically); </span>
<span class="sd">        4) whether the FWHM is expressed in &#39;nm&#39;, &#39;mu&#39; or &#39;km/s&#39;. </span>
<span class="sd">        The third and fourth can also be set to None. In that case, the FWHM of </span>
<span class="sd">        the gaussian will automatically be set to the equivalent width of the</span>
<span class="sd">        line, calculated from the flux to be injected and the continuum </span>
<span class="sd">        level (measured in the grid model to which the line is injected). </span>
<span class="sd">        Examples: </span>
<span class="sd">        em_lines = {&#39;BrG&#39;:(2.1667,&#39;F&#39;, None, None)};</span>
<span class="sd">        em_lines = {&#39;BrG&#39;:(2.1667,&#39;LogL&#39;, 100, &#39;km/s&#39;)}</span>
<span class="sd">    em_grid: dictionary pointing to lists, opt</span>
<span class="sd">        Dictionary where each entry corresponds to an emission line and points</span>
<span class="sd">        to a list of values to inject for emission line fluxes. For computation </span>
<span class="sd">        efficiency, interpolation will be performed between the points of this </span>
<span class="sd">        grid during the MCMC sampling. Dict entries should match labels and </span>
<span class="sd">        em_lines.</span>
<span class="sd">    dlbda_obs: numpy 1d ndarray or list, optional</span>
<span class="sd">        Spectral channel width for the observed spectrum. It should be provided </span>
<span class="sd">        IF one wants to weigh each point based on the spectral </span>
<span class="sd">        resolution of the respective instruments (as in Olofsson et al. 2016).</span>
<span class="sd">    instru_corr : numpy 2d ndarray or list, optional</span>
<span class="sd">        Spectral correlation throughout post-processed images in which the </span>
<span class="sd">        spectrum is measured. It is specific to the combination of instrument, </span>
<span class="sd">        algorithm and radial separation of the companion from the central star.</span>
<span class="sd">        Can be computed using `spec_corr.spectral_correlation()`. In case of</span>
<span class="sd">        a spectrum obtained with different instruments, build it with</span>
<span class="sd">        `spec_corr.combine_corrs()`. If not provided, it will consider the </span>
<span class="sd">        uncertainties in each spectral channels are independent. See Greco &amp; </span>
<span class="sd">        Brandt (2017) for details.</span>
<span class="sd">    instru_fwhm : float OR list of either floats or strings, optional</span>
<span class="sd">        The instrumental spectral fwhm provided in nm. This is used to convolve</span>
<span class="sd">        the model spectrum. If several instruments are used, provide a list of </span>
<span class="sd">        instru_fwhm values, one for each instrument whose spectral resolution</span>
<span class="sd">        is coarser than the model - including broad band filter FWHM if </span>
<span class="sd">        relevant.</span>
<span class="sd">        If strings are provided, they should correspond to filenames (including </span>
<span class="sd">        full paths) of text files containing the filter information for each </span>
<span class="sd">        observed wavelength. Strict format: </span>
<span class="sd">    instru_idx: numpy 1d array, optional</span>
<span class="sd">        1d array containing an index representing each instrument used </span>
<span class="sd">        to obtain the spectrum, label them from 0 to n_instru. Zero for points </span>
<span class="sd">        that don&#39;t correspond to any instru_fwhm provided above, and i in </span>
<span class="sd">        [1,n_instru] for points associated to instru_fwhm[i-1]. This parameter </span>
<span class="sd">        must be provided if the spectrum consists of points obtained with </span>
<span class="sd">        different instruments.</span>
<span class="sd">    filter_reader: python routine, optional</span>
<span class="sd">        External routine that reads a filter file and returns a 2D numpy array, </span>
<span class="sd">        where the first column corresponds to wavelengths, and the second </span>
<span class="sd">        contains transmission values. Important: if not provided, but strings </span>
<span class="sd">        are detected in instru_fwhm, the default file reader will be used. </span>
<span class="sd">        It assumes the following format for the files:</span>
<span class="sd">        - first row containing header</span>
<span class="sd">        - starting from 2nd row: 1st column: wavelength, 2nd col.: transmission</span>
<span class="sd">        - Unit of wavelength can be provided in parentheses of first header \</span>
<span class="sd">        key name: e.g. &quot;WL(AA)&quot; for angstrom, &quot;wavelength(mu)&quot; for micrometer \</span>
<span class="sd">        or &quot;lambda(nm)&quot; for nanometer. Note: Only what is in parentheses \</span>
<span class="sd">        matters.</span>
<span class="sd">        </span>
<span class="sd">        Important: filter files should all have the same format and WL units.</span>
<span class="sd">    AV_bef_bb: bool, optional</span>
<span class="sd">        If both extinction and an extra bb component are free parameters, </span>
<span class="sd">        whether to apply extinction before adding the BB component (e.g. </span>
<span class="sd">        extinction mostly from circumplanetary dust) or after the BB component</span>
<span class="sd">        (e.g. mostly insterstellar extinction).</span>
<span class="sd">    units_obs : str, opt {&#39;si&#39;,&#39;cgs&#39;,&#39;jy&#39;}</span>
<span class="sd">        Units of observed spectrum. &#39;si&#39; for W/m^2/mu; &#39;cgs&#39; for ergs/s/cm^2/mu </span>
<span class="sd">        or &#39;jy&#39; for janskys.</span>
<span class="sd">    units_mod: str, opt {&#39;si&#39;,&#39;cgs&#39;,&#39;jy&#39;}</span>
<span class="sd">        Units of the model. &#39;si&#39; for W/m^2/mu; &#39;cgs&#39; for ergs/s/cm^2/mu or &#39;jy&#39;</span>
<span class="sd">        for janskys. If different to units_obs, the spectrum units will be </span>
<span class="sd">        converted.</span>
<span class="sd">    interp_order: int, opt, {-1,0,1} </span>
<span class="sd">        Interpolation mode for model interpolation.</span>
<span class="sd">        -1: log interpolation (i.e. linear interpolatlion on log(Flux))</span>
<span class="sd">        0: nearest neighbour model.</span>
<span class="sd">        1: Order 1 spline interpolation.</span>
<span class="sd">    priors: dictionary, opt</span>
<span class="sd">        If not None, sets prior estimates for each parameter of the model. Each </span>
<span class="sd">        entry should be set to either None (no prior) or a tuple of 2 elements </span>
<span class="sd">        containing prior estimate and uncertainty on the estimate.</span>
<span class="sd">        Missing entries (i.e. provided in bounds dictionary but not here) will</span>
<span class="sd">        be associated no prior.</span>
<span class="sd">        e.g. priors = {&#39;Teff&#39;:(1600,100), &#39;logg&#39;:(3.5,0.5), &#39;R&#39;:(1.6,0.1), </span>
<span class="sd">        &#39;Av&#39;:(1.8,0.2), &#39;M&#39;:(10,3)}</span>
<span class="sd">        Important: dictionary entry names should match exactly those of bounds.</span>
<span class="sd">    physical: bool, opt</span>
<span class="sd">        In case of extra black body component(s) to a photosphere, whether to </span>
<span class="sd">        force lower temperature than the photosphere effective temperature.</span>
<span class="sd">    interp_nonexist: bool, opt</span>
<span class="sd">        Whether to interpolate non-existing models in the grid. Only used if </span>
<span class="sd">        resamp_before is set to True.</span>
<span class="sd">    ini_ball: float or string, default=1e-1</span>
<span class="sd">        Size of the initial ball in parameter space from which walkers start </span>
<span class="sd">        their chain. If &quot;uniform&quot; is provided, a uniform ini_ball spanning</span>
<span class="sd">        the bounds interval will be used to initialise walkers.</span>
<span class="sd">    a: float, default=2.0</span>
<span class="sd">        The proposal scale parameter. See notes.</span>
<span class="sd">    nwalkers: int, default: 1000</span>
<span class="sd">        Number of walkers</span>
<span class="sd">    niteration_min: int, optional</span>
<span class="sd">        Steps per walker lower bound. The simulation will run at least this</span>
<span class="sd">        number of steps per walker.</span>
<span class="sd">    niteration_limit: int, optional</span>
<span class="sd">        Steps per walker upper bound. If the simulation runs up to</span>
<span class="sd">        &#39;niteration_limit&#39; steps without having reached the convergence</span>
<span class="sd">        criterion, the run is stopped.</span>
<span class="sd">    niteration_supp: int, optional</span>
<span class="sd">        Number of iterations to run after having &quot;reached the convergence&quot;.</span>
<span class="sd">    burnin: float, default=0.3</span>
<span class="sd">        The fraction of a walker which is discarded.</span>
<span class="sd">    rhat_threshold: float, default=0.01</span>
<span class="sd">        The Gelman-Rubin threshold used for the test for nonconvergence.</span>
<span class="sd">    rhat_count_threshold: int, optional</span>
<span class="sd">        The Gelman-Rubin test must be satisfied &#39;rhat_count_threshold&#39; times in</span>
<span class="sd">        a row before claiming that the chain has converged.</span>
<span class="sd">    check_maxgap: int, optional</span>
<span class="sd">        Maximum number of steps per walker between two convergence tests.</span>
<span class="sd">    conv_test: str, optional {&#39;gb&#39;,&#39;autocorr&#39;}</span>
<span class="sd">        Method to check for convergence: </span>
<span class="sd">        - &#39;gb&#39; for gelman-rubin test \</span>
<span class="sd">        (http://digitalassets.lib.berkeley.edu/sdtr/ucb/text/305.pdf)</span>
<span class="sd">        - &#39;autocorr&#39; for autocorrelation analysis \</span>
<span class="sd">        (https://emcee.readthedocs.io/en/stable/tutorials/autocorr/)</span>
<span class="sd">        </span>
<span class="sd">    nproc: int, optional</span>
<span class="sd">        The number of processes to use for parallelization.</span>
<span class="sd">    grid_name: str, optional</span>
<span class="sd">        Name of the fits file containing the model grid (numpy array) AFTER</span>
<span class="sd">        convolution+resampling as the observed spectrum given as input.</span>
<span class="sd">        If provided, will read it if it exists (and resamp_before is set</span>
<span class="sd">        to True), or make it and write it if it doesn&#39;t.</span>
<span class="sd">    output_dir: str, optional</span>
<span class="sd">        The name of the output directory which contains the output files in the </span>
<span class="sd">        case  ``save`` is True.        </span>
<span class="sd">    output_file: str, optional</span>
<span class="sd">        The name of the output file which contains the MCMC results in the case</span>
<span class="sd">        ``save`` is True.</span>
<span class="sd">    display: bool, optional</span>
<span class="sd">        If True, the walk plot is displayed at each evaluation of the Gelman-</span>
<span class="sd">        Rubin test.</span>
<span class="sd">    verbosity: 0, 1 or 2, optional</span>
<span class="sd">        Verbosity level. 0 for no output and 2 for full information.</span>
<span class="sd">    save: bool, optional</span>
<span class="sd">        If True, the MCMC results are pickled.</span>
<span class="sd">                    </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : numpy.array</span>
<span class="sd">        The MCMC samples after truncation of zeros.</span>
<span class="sd">    lnprobability: emcee sample object</span>
<span class="sd">        The corresponding probabilities for each sample</span>
<span class="sd">        </span>
<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The parameter `a` must be &gt; 1. For more theoretical information concerning</span>
<span class="sd">    this parameter, see Goodman &amp; Weare, 2010, Comm. App. Math. Comp. Sci.,</span>
<span class="sd">    5, 65, Eq. [9] p70.</span>
<span class="sd">    </span>
<span class="sd">    The parameter &#39;rhat_threshold&#39; can be a numpy.array with individual</span>
<span class="sd">    threshold value for each model parameter.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">nparams</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">initial_state</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">grid_param_list</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">model_grid</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">model_reader</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Either model_grid or model_reader have to be provided&quot;</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
        <span class="n">n_gparams</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">grid_param_list</span><span class="p">)</span>
        <span class="n">gp_dims</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">nn</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_gparams</span><span class="p">):</span>
            <span class="n">gp_dims</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">grid_param_list</span><span class="p">[</span><span class="n">nn</span><span class="p">]))</span>
        <span class="n">gp_dims</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">gp_dims</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">n_gparams</span> <span class="o">=</span> <span class="mi">0</span>
        
    <span class="c1"># format emission line dictionary and em grid</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">em_grid</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
        <span class="n">n_em</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">em_grid</span><span class="p">)</span>
        <span class="n">em_dims</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">lab</span> <span class="ow">in</span> <span class="n">labels</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">lab</span> <span class="ow">in</span> <span class="n">em_grid</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="n">em_dims</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">em_grid</span><span class="p">[</span><span class="n">lab</span><span class="p">]))</span>
        <span class="n">em_dims</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">em_dims</span><span class="p">)</span>
        <span class="c1"># update the grids depending on input units =&gt; make it surface flux</span>
        <span class="n">idx_R</span> <span class="o">=</span> <span class="n">labels</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s1">&#39;R&#39;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">em_lines</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">val</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;L&#39;</span><span class="p">:</span>
                <span class="n">idx_line</span> <span class="o">=</span> <span class="n">labels</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
                <span class="c1"># adapt grid</span>
                <span class="n">R_si</span> <span class="o">=</span> <span class="n">initial_state</span><span class="p">[</span><span class="n">idx_R</span><span class="p">]</span><span class="o">*</span><span class="n">con</span><span class="o">.</span><span class="n">R_jup</span><span class="o">.</span><span class="n">value</span>
                <span class="n">conv_fac</span> <span class="o">=</span> <span class="mi">4</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">R_si</span><span class="o">**</span><span class="mi">2</span>
                <span class="n">tmp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">em_grid</span><span class="p">[</span><span class="n">key</span><span class="p">])</span><span class="o">/</span><span class="n">conv_fac</span>
                <span class="n">em_grid</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
                <span class="c1"># adapt ini state </span>
                <span class="n">initial_state</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">initial_state</span><span class="p">)</span>
                <span class="n">initial_state</span><span class="p">[</span><span class="n">idx_line</span><span class="p">]</span> <span class="o">/=</span> <span class="n">conv_fac</span>
                <span class="n">initial_state</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">initial_state</span><span class="p">)</span>
                <span class="c1">#adapt bounds</span>
                <span class="n">bounds_ori</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">bounds</span><span class="p">[</span><span class="n">key</span><span class="p">])</span>
                <span class="n">bounds</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">bounds_ori</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="n">conv_fac</span><span class="p">,</span> <span class="n">bounds_ori</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="n">conv_fac</span><span class="p">)</span> 
            <span class="k">elif</span> <span class="n">val</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;LogL&#39;</span><span class="p">:</span>
                <span class="n">idx_line</span> <span class="o">=</span> <span class="n">labels</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
                <span class="n">R_si</span> <span class="o">=</span> <span class="n">initial_state</span><span class="p">[</span><span class="n">idx_R</span><span class="p">]</span><span class="o">*</span><span class="n">con</span><span class="o">.</span><span class="n">R_jup</span><span class="o">.</span><span class="n">value</span>
                <span class="n">conv_fac</span> <span class="o">=</span> <span class="n">con</span><span class="o">.</span><span class="n">L_sun</span><span class="o">.</span><span class="n">value</span><span class="o">/</span><span class="p">(</span><span class="mi">4</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">R_si</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
                <span class="n">tmp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">em_grid</span><span class="p">[</span><span class="n">key</span><span class="p">]))</span><span class="o">*</span><span class="n">conv_fac</span>
                <span class="n">em_grid</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>  
                <span class="c1"># adapt ini state </span>
                <span class="n">initial_state</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">initial_state</span><span class="p">)</span>
                <span class="n">initial_state</span><span class="p">[</span><span class="n">idx_line</span><span class="p">]</span> <span class="o">=</span> <span class="n">conv_fac</span><span class="o">*</span><span class="mi">10</span><span class="o">**</span><span class="n">initial_state</span><span class="p">[</span><span class="n">idx_line</span><span class="p">]</span>
                <span class="n">initial_state</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">initial_state</span><span class="p">)</span>
                <span class="c1">#adapt bounds</span>
                <span class="n">bounds_ori</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">bounds</span><span class="p">[</span><span class="n">key</span><span class="p">])</span>
                <span class="n">bounds</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">conv_fac</span><span class="o">*</span><span class="mi">10</span><span class="o">**</span><span class="n">bounds_ori</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> 
                               <span class="n">conv_fac</span><span class="o">*</span><span class="mi">10</span><span class="o">**</span><span class="n">bounds_ori</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> 
            <span class="k">if</span> <span class="n">em_lines</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">em_lines</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;km/s&#39;</span><span class="p">:</span>
                    <span class="n">v</span> <span class="o">=</span> <span class="n">em_lines</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span>
                    <span class="n">em_lines_tmp</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">em_lines</span><span class="p">[</span><span class="n">key</span><span class="p">])</span>
                    <span class="n">em_lines_tmp</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1000</span><span class="o">*</span><span class="n">v</span><span class="o">/</span><span class="n">con</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">value</span><span class="p">)</span><span class="o">*</span><span class="n">em_lines</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">em_lines_tmp</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;mu&#39;</span>
                    <span class="n">em_lines</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">em_lines_tmp</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">em_lines</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;nm&#39;</span><span class="p">:</span>
                    <span class="n">em_lines_tmp</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">em_lines</span><span class="p">[</span><span class="n">key</span><span class="p">])</span>
                    <span class="n">em_lines_tmp</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">em_lines</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span><span class="o">/</span><span class="mi">1000</span>
                    <span class="n">em_lines_tmp</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;mu&#39;</span>
                    <span class="n">em_lines</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">em_lines_tmp</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">em_lines</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="s1">&#39;mu&#39;</span><span class="p">:</span>
                    <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Invalid unit of FWHM for line injection&quot;</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
                
    <span class="k">if</span> <span class="n">model_grid</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">grid_param_list</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">model_grid</span><span class="o">.</span><span class="n">ndim</span><span class="o">-</span><span class="mi">2</span> <span class="o">!=</span> <span class="n">n_gparams</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Ndim-2 of model_grid should match len(grid_param_list)&quot;</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">verbosity</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">start_time</span> <span class="o">=</span> <span class="n">time_ini</span><span class="p">()</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;       MCMC sampler for spectral fitting       &quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">sep</span><span class="p">)</span>


    <span class="c1"># If required, create the output folder.</span>
    <span class="k">if</span> <span class="n">save</span> <span class="ow">or</span> <span class="p">(</span><span class="n">resamp_before</span> <span class="ow">and</span> <span class="n">grid_param_list</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">output_dir</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Please provide an output directory path&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">isdir</span><span class="p">(</span><span class="n">output_dir</span><span class="p">):</span>
            <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">output_dir</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">output_dir</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="s1">&#39;/&#39;</span><span class="p">:</span>
            <span class="n">output_dir</span> <span class="o">=</span> <span class="n">output_dir</span><span class="o">+</span><span class="s1">&#39;/&#39;</span>

        <span class="c1">#output_file_tmp = datetime.datetime.now().strftime(&quot;%Y%m%d_%H%M%S&quot;)</span>
 
    <span class="c1"># Check model grid parameters extend beyond bounds to avoid extrapolation</span>
    <span class="k">if</span> <span class="n">grid_param_list</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">pp</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_gparams</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">grid_param_list</span><span class="p">[</span><span class="n">pp</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">&gt;</span><span class="n">bounds</span><span class="p">[</span><span class="n">labels</span><span class="p">[</span><span class="n">pp</span><span class="p">]][</span><span class="mi">0</span><span class="p">]:</span>
                <span class="n">msg</span><span class="o">=</span> <span class="s2">&quot;Grid has to extend beyond bounds for </span><span class="si">{}</span><span class="s2">.&quot;</span>
                <span class="n">msg</span><span class="o">+=</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2"> Consider increasing the lower bound to &gt;</span><span class="si">{}</span><span class="s2">.&quot;</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">labels</span><span class="p">[</span><span class="n">pp</span><span class="p">],</span><span class="n">grid_param_list</span><span class="p">[</span><span class="n">pp</span><span class="p">][</span><span class="mi">0</span><span class="p">]))</span>
            <span class="k">if</span> <span class="n">grid_param_list</span><span class="p">[</span><span class="n">pp</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">&lt;</span><span class="n">bounds</span><span class="p">[</span><span class="n">labels</span><span class="p">[</span><span class="n">pp</span><span class="p">]][</span><span class="mi">1</span><span class="p">]:</span>
                <span class="n">msg</span><span class="o">=</span> <span class="s2">&quot;Grid has to extend beyond bounds for </span><span class="si">{}</span><span class="s2">.&quot;</span>
                <span class="n">msg</span><span class="o">+=</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2"> Consider decreasing the upper bound to &lt;</span><span class="si">{}</span><span class="s2">.&quot;</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">labels</span><span class="p">[</span><span class="n">pp</span><span class="p">],</span><span class="n">grid_param_list</span><span class="p">[</span><span class="n">pp</span><span class="p">][</span><span class="mi">1</span><span class="p">]))</span>
                
    <span class="c1"># Check initial state is within bounds for all params (not only grid)</span>
    <span class="k">for</span> <span class="n">pp</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nparams</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">initial_state</span><span class="p">[</span><span class="n">pp</span><span class="p">]</span><span class="o">&lt;</span><span class="n">bounds</span><span class="p">[</span><span class="n">labels</span><span class="p">[</span><span class="n">pp</span><span class="p">]][</span><span class="mi">0</span><span class="p">]:</span>
            <span class="n">msg</span><span class="o">=</span> <span class="s2">&quot;Initial state has to be within bounds for </span><span class="si">{}</span><span class="s2">.&quot;</span>
            <span class="n">msg</span><span class="o">+=</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2"> Consider decreasing the lower bound to &lt;</span><span class="si">{}</span><span class="s2">.&quot;</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">labels</span><span class="p">[</span><span class="n">pp</span><span class="p">],</span><span class="n">initial_state</span><span class="p">[</span><span class="n">pp</span><span class="p">]))</span>            
        <span class="k">if</span> <span class="n">initial_state</span><span class="p">[</span><span class="n">pp</span><span class="p">]</span><span class="o">&gt;</span><span class="n">bounds</span><span class="p">[</span><span class="n">labels</span><span class="p">[</span><span class="n">pp</span><span class="p">]][</span><span class="mi">1</span><span class="p">]:</span>
            <span class="n">msg</span><span class="o">=</span> <span class="s2">&quot;Initial state has to be within bounds for </span><span class="si">{}</span><span class="s2">.&quot;</span>
            <span class="n">msg</span><span class="o">+=</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2"> Consider decreasing the upper bound to &gt;</span><span class="si">{}</span><span class="s2">.&quot;</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">labels</span><span class="p">[</span><span class="n">pp</span><span class="p">],</span><span class="n">initial_state</span><span class="p">[</span><span class="n">pp</span><span class="p">]))</span>
        
    <span class="c1"># Prepare model grid: convolve+resample models as observations </span>
    <span class="k">if</span> <span class="n">resamp_before</span> <span class="ow">and</span> <span class="n">grid_param_list</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">isfile</span><span class="p">(</span><span class="n">output_dir</span><span class="o">+</span><span class="n">grid_name</span><span class="p">):</span>
            <span class="n">model_grid</span> <span class="o">=</span> <span class="n">open_fits</span><span class="p">(</span><span class="n">output_dir</span><span class="o">+</span><span class="n">grid_name</span><span class="p">)</span>
            <span class="c1"># check its shape is consistent with grid_param_list</span>
            <span class="k">if</span> <span class="n">model_grid</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="n">n_gparams</span><span class="p">]</span> <span class="o">!=</span> <span class="n">gp_dims</span><span class="p">:</span>
                <span class="n">msg</span><span class="o">=</span><span class="s2">&quot;the loaded model grid (</span><span class="si">{}</span><span class="s2">) doesn&#39;t have expected dims (</span><span class="si">{}</span><span class="s2">)&quot;</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">model_grid</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span><span class="n">gp_dims</span><span class="p">))</span>
            <span class="k">elif</span> <span class="n">model_grid</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">lbda_obs</span><span class="p">):</span>
                <span class="n">msg</span><span class="o">=</span><span class="s2">&quot;the loaded model grid doesn&#39;t have expected WL dimension&quot;</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">model_grid</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">msg</span><span class="o">=</span><span class="s2">&quot;the loaded model grid doesn&#39;t have expected last dimension&quot;</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">em_grid</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">model_grid</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">n_gparams</span><span class="p">:</span><span class="n">n_gparams</span><span class="o">+</span><span class="n">n_em</span><span class="p">]</span> <span class="o">!=</span> <span class="n">em_dims</span><span class="p">:</span>
                    <span class="n">msg</span><span class="o">=</span><span class="s2">&quot;loaded model grid (</span><span class="si">{}</span><span class="s2">) doesn&#39;t have expected dims (</span><span class="si">{}</span><span class="s2">)&quot;</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">model_grid</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span><span class="n">em_dims</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">model_grid</span> <span class="o">=</span> <span class="n">make_resampled_models</span><span class="p">(</span><span class="n">lbda_obs</span><span class="p">,</span> <span class="n">grid_param_list</span><span class="p">,</span> 
                                               <span class="n">model_grid</span><span class="p">,</span> <span class="n">model_reader</span><span class="p">,</span> 
                                               <span class="n">em_lines</span><span class="p">,</span> <span class="n">em_grid</span><span class="p">,</span> <span class="n">dlbda_obs</span><span class="p">,</span> 
                                               <span class="n">instru_fwhm</span><span class="p">,</span> <span class="n">instru_idx</span><span class="p">,</span> 
                                               <span class="n">filter_reader</span><span class="p">,</span> <span class="n">interp_nonexist</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">output_dir</span> <span class="ow">and</span> <span class="n">grid_name</span><span class="p">:</span>
                <span class="n">write_fits</span><span class="p">(</span><span class="n">output_dir</span><span class="o">+</span><span class="n">grid_name</span><span class="p">,</span> <span class="n">model_grid</span><span class="p">)</span>
        <span class="c1"># note: if model_grid is provided, it is still resampled to the </span>
        <span class="c1"># same wavelengths as observed spectrum. However, if a fits name is </span>
        <span class="c1"># provided in grid_name and that file exists, it is assumed the model </span>
        <span class="c1"># grid in it is already resampled to match lbda_obs.</span>

    <span class="k">if</span> <span class="n">save</span> <span class="ow">and</span> <span class="n">output_file</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">output_file</span> <span class="o">=</span> <span class="s1">&#39;MCMC_results&#39;</span>

    
    <span class="c1"># #########################################################################</span>
    <span class="c1"># Initialization of the MCMC variables                                    #</span>
    <span class="c1"># #########################################################################</span>
    <span class="n">dim</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span>
    <span class="n">itermin</span> <span class="o">=</span> <span class="n">niteration_min</span>
    <span class="n">limit</span> <span class="o">=</span> <span class="n">niteration_limit</span>
    <span class="n">supp</span> <span class="o">=</span> <span class="n">niteration_supp</span>
    <span class="n">maxgap</span> <span class="o">=</span> <span class="n">check_maxgap</span>
    <span class="n">initial_state</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">initial_state</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">itermin</span> <span class="o">&gt;</span> <span class="n">limit</span><span class="p">:</span>
        <span class="n">itermin</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="n">fraction</span> <span class="o">=</span> <span class="mf">0.3</span>
    <span class="n">geom</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">lastcheck</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">konvergence</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
    <span class="n">rhat_count</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">ac_count</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">chain</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">([</span><span class="n">nwalkers</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">dim</span><span class="p">])</span>
    <span class="n">ar_frac</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">([</span><span class="n">nwalkers</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
    <span class="n">nIterations</span> <span class="o">=</span> <span class="n">limit</span> <span class="o">+</span> <span class="n">supp</span>
    <span class="n">rhat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">dim</span><span class="p">)</span>
    <span class="n">stop</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
    
    <span class="c1"># initialise ball of walkers</span>
    <span class="k">if</span> <span class="n">ini_ball</span> <span class="o">==</span> <span class="s2">&quot;uniform&quot;</span><span class="p">:</span>
        <span class="n">pos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">nwalkers</span><span class="p">,</span> <span class="n">dim</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">dim</span><span class="p">):</span>
            <span class="n">low_b</span> <span class="o">=</span> <span class="n">bounds</span><span class="p">[</span><span class="n">labels</span><span class="p">[</span><span class="n">ii</span><span class="p">]][</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">up_b</span> <span class="o">=</span> <span class="p">(</span><span class="n">bounds</span><span class="p">[</span><span class="n">labels</span><span class="p">[</span><span class="n">ii</span><span class="p">]][</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">pos</span><span class="p">[:,</span><span class="n">ii</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="n">low_b</span> <span class="o">+</span> <span class="mf">0.01</span><span class="o">*</span><span class="p">(</span><span class="n">up_b</span><span class="o">-</span><span class="n">low_b</span><span class="p">),</span> 
                                          <span class="n">up_b</span><span class="p">,</span> <span class="n">nwalkers</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ini_ball</span><span class="p">,</span><span class="nb">float</span><span class="p">):</span>
        <span class="n">pos</span> <span class="o">=</span> <span class="n">initial_state</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">ini_ball</span><span class="p">,</span> <span class="p">(</span><span class="n">nwalkers</span><span class="p">,</span> <span class="n">dim</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;ini_ball must be string or float&quot;</span><span class="p">)</span>
    
    <span class="n">sampler</span> <span class="o">=</span> <span class="n">emcee</span><span class="o">.</span><span class="n">EnsembleSampler</span><span class="p">(</span><span class="n">nwalkers</span><span class="p">,</span> <span class="n">dim</span><span class="p">,</span> <span class="n">lnprob</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="n">a</span><span class="p">,</span>
                                    <span class="n">args</span><span class="o">=</span><span class="p">([</span><span class="n">labels</span><span class="p">,</span> <span class="n">bounds</span><span class="p">,</span> <span class="n">grid_param_list</span><span class="p">,</span> 
                                           <span class="n">lbda_obs</span><span class="p">,</span> <span class="n">spec_obs</span><span class="p">,</span> <span class="n">err_obs</span><span class="p">,</span> <span class="n">dist</span><span class="p">,</span>
                                           <span class="n">model_grid</span><span class="p">,</span> <span class="n">model_reader</span><span class="p">,</span> <span class="n">em_lines</span><span class="p">,</span>
                                           <span class="n">em_grid</span><span class="p">,</span> <span class="n">dlbda_obs</span><span class="p">,</span> <span class="n">instru_corr</span><span class="p">,</span> 
                                           <span class="n">instru_fwhm</span><span class="p">,</span><span class="n">instru_idx</span><span class="p">,</span><span class="n">filter_reader</span><span class="p">,</span> 
                                           <span class="n">AV_bef_bb</span><span class="p">,</span> <span class="n">units_obs</span><span class="p">,</span> <span class="n">units_mod</span><span class="p">,</span> 
                                           <span class="n">interp_order</span><span class="p">,</span> <span class="n">priors</span><span class="p">,</span> <span class="n">physical</span><span class="p">]),</span>
                                    <span class="n">threads</span><span class="o">=</span><span class="n">nproc</span><span class="p">)</span>
                                    
    <span class="n">start</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span>

    <span class="c1"># #########################################################################</span>
    <span class="c1"># Affine Invariant MCMC run</span>
    <span class="c1"># #########################################################################</span>
    <span class="k">if</span> <span class="n">verbosity</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">Start of the MCMC run ...&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Step  |  Duration/step (sec)  |  Remaining Estimated Time (sec)&#39;</span><span class="p">)</span>
    
    <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">res</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">sampler</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="n">iterations</span><span class="o">=</span><span class="n">nIterations</span><span class="p">)):</span>
        <span class="n">elapsed</span> <span class="o">=</span> <span class="p">(</span><span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span><span class="o">-</span><span class="n">start</span><span class="p">)</span><span class="o">.</span><span class="n">total_seconds</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">verbosity</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">q</span> <span class="o">=</span> <span class="mf">0.5</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">q</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{}</span><span class="se">\t\t</span><span class="si">{:.5f}</span><span class="se">\t\t\t</span><span class="si">{:.5f}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">elapsed</span> <span class="o">*</span> <span class="n">q</span><span class="p">,</span>
                                                    <span class="n">elapsed</span> <span class="o">*</span> <span class="p">(</span><span class="n">limit</span><span class="o">-</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">q</span><span class="p">))</span>
            
        <span class="n">start</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span>

        <span class="c1"># ---------------------------------------------------------------------</span>
        <span class="c1"># Store the state manually in order to handle with dynamical sized chain</span>
        <span class="c1"># ---------------------------------------------------------------------</span>
        <span class="c1"># Check if the size of the chain is long enough.</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">chain</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">k</span><span class="o">+</span><span class="mi">1</span> <span class="o">&gt;</span> <span class="n">s</span><span class="p">:</span>     <span class="c1"># if not, one doubles the chain length</span>
            <span class="n">empty</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">nwalkers</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="n">dim</span><span class="p">])</span>
            <span class="n">chain</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">chain</span><span class="p">,</span> <span class="n">empty</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">empty</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">nwalkers</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">s</span><span class="p">])</span>
            <span class="n">ar_frac</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">ar_frac</span><span class="p">,</span> <span class="n">empty</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="c1"># Store the state of the chain</span>
        <span class="n">chain</span><span class="p">[:,</span> <span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">res</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">ar_frac</span><span class="p">[:,</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">sampler</span><span class="o">.</span><span class="n">acceptance_fraction</span>

        <span class="c1"># ---------------------------------------------------------------------</span>
        <span class="c1"># If k meets the criterion, one tests the non-convergence.</span>
        <span class="c1"># ---------------------------------------------------------------------</span>
        <span class="n">criterion</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">amin</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">itermin</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">fraction</span><span class="p">)</span><span class="o">**</span><span class="n">geom</span><span class="p">),</span>
                        <span class="n">lastcheck</span><span class="o">+</span><span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">maxgap</span><span class="p">)]))</span>
        <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="n">criterion</span><span class="p">:</span>
            
            <span class="n">geom</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">lastcheck</span> <span class="o">=</span> <span class="n">k</span>
            <span class="k">if</span> <span class="n">display</span><span class="p">:</span>
                <span class="n">show_walk_plot</span><span class="p">(</span><span class="n">chain</span><span class="p">)</span>
                
            <span class="c1"># We only test the rhat if we have reached the min # of steps</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">itermin</span> <span class="ow">and</span> <span class="n">konvergence</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">verbosity</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="si">{}</span><span class="s1"> convergence test in progress...&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">conv_test</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">conv_test</span> <span class="o">==</span> <span class="s1">&#39;gb&#39;</span><span class="p">:</span>
                    <span class="n">thr0</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">burnin</span><span class="o">*</span><span class="n">k</span><span class="p">))</span>
                    <span class="n">thr1</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">((</span><span class="mi">1</span><span class="o">-</span><span class="n">burnin</span><span class="p">)</span><span class="o">*</span><span class="n">k</span><span class="o">*</span><span class="mf">0.25</span><span class="p">))</span>
    
                    <span class="c1"># We calculate the rhat for each model parameter.</span>
                    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">dim</span><span class="p">):</span>
                        <span class="n">part1</span> <span class="o">=</span> <span class="n">chain</span><span class="p">[:,</span> <span class="n">thr0</span><span class="p">:</span><span class="n">thr0</span> <span class="o">+</span> <span class="n">thr1</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
                        <span class="n">part2</span> <span class="o">=</span> <span class="n">chain</span><span class="p">[:,</span> <span class="n">thr0</span> <span class="o">+</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">thr1</span><span class="p">:</span><span class="n">thr0</span> <span class="o">+</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">thr1</span><span class="p">,</span> <span class="n">j</span>
                                     <span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
                        <span class="n">series</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">part1</span><span class="p">,</span> <span class="n">part2</span><span class="p">))</span>
                        <span class="n">rhat</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">gelman_rubin</span><span class="p">(</span><span class="n">series</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">verbosity</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;   r_hat = </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">rhat</span><span class="p">))</span>
                        <span class="n">cond</span> <span class="o">=</span> <span class="n">rhat</span> <span class="o">&lt;=</span> <span class="n">rhat_threshold</span>
                        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;   r_hat &lt;= threshold = </span><span class="si">{}</span><span class="s1"> </span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">cond</span><span class="p">))</span>
                    <span class="c1"># We test the rhat.</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">rhat</span> <span class="o">&lt;=</span> <span class="n">rhat_threshold</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
                        <span class="n">rhat_count</span> <span class="o">+=</span> <span class="mi">1</span>
                        <span class="k">if</span> <span class="n">rhat_count</span> <span class="o">&lt;</span> <span class="n">rhat_count_threshold</span><span class="p">:</span>
                            <span class="k">if</span> <span class="n">verbosity</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                                <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Gelman-Rubin test OK </span><span class="si">{}</span><span class="s2">/</span><span class="si">{}</span><span class="s2">&quot;</span>
                                <span class="nb">print</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">rhat_count</span><span class="p">,</span> 
                                                 <span class="n">rhat_count_threshold</span><span class="p">))</span>
                        <span class="k">elif</span> <span class="n">rhat_count</span> <span class="o">&gt;=</span> <span class="n">rhat_count_threshold</span><span class="p">:</span>
                            <span class="k">if</span> <span class="n">verbosity</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;... ==&gt; convergence reached&#39;</span><span class="p">)</span>
                            <span class="n">konvergence</span> <span class="o">=</span> <span class="n">k</span>
                            <span class="n">stop</span> <span class="o">=</span> <span class="n">konvergence</span> <span class="o">+</span> <span class="n">supp</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">rhat_count</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">elif</span> <span class="n">conv_test</span> <span class="o">==</span> <span class="s1">&#39;ac&#39;</span><span class="p">:</span>
                    <span class="c1"># We calculate the auto-corr test for each model parameter.</span>
                    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">dim</span><span class="p">):</span>
                        <span class="n">rhat</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">autocorr_test</span><span class="p">(</span><span class="n">chain</span><span class="p">[:,:</span><span class="n">k</span><span class="p">,</span><span class="n">j</span><span class="p">])</span>
                    <span class="n">thr</span> <span class="o">=</span> <span class="mf">1.</span><span class="o">/</span><span class="n">ac_c</span>
                    <span class="k">if</span> <span class="n">verbosity</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Auto-corr tau/N = </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">rhat</span><span class="p">))</span>
                        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;tau/N &lt;= </span><span class="si">{}</span><span class="s1"> = </span><span class="si">{}</span><span class="s1"> </span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">thr</span><span class="p">,</span> <span class="n">rhat</span><span class="o">&lt;</span><span class="n">thr</span><span class="p">))</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">rhat</span> <span class="o">&lt;=</span> <span class="n">thr</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
                        <span class="n">ac_count</span><span class="o">+=</span><span class="mi">1</span>
                        <span class="k">if</span> <span class="n">verbosity</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                            <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Auto-correlation test passed for all params!&quot;</span>
                            <span class="n">msg</span><span class="o">+=</span> <span class="s2">&quot;</span><span class="si">{}</span><span class="s2">/</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">ac_count</span><span class="p">,</span><span class="n">ac_count_thr</span><span class="p">)</span>
                            <span class="nb">print</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">ac_count</span> <span class="o">&gt;=</span> <span class="n">ac_count_thr</span><span class="p">:</span>
                            <span class="n">msg</span><span class="o">=</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1"> ... ==&gt; convergence reached&#39;</span>
                            <span class="nb">print</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
                            <span class="n">stop</span> <span class="o">=</span> <span class="n">k</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">ac_count</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;conv_test value not recognized&#39;</span><span class="p">)</span>
                
                                
                <span class="k">if</span> <span class="n">save</span> <span class="ow">and</span> <span class="n">verbosity</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                    <span class="n">ac_time</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">dim</span><span class="p">):</span>
                        <span class="n">ac_time</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">k</span><span class="o">*</span><span class="n">autocorr_test</span><span class="p">(</span><span class="n">chain</span><span class="p">[:,:</span><span class="n">k</span><span class="p">,</span><span class="n">j</span><span class="p">]))</span>
                    <span class="n">fname</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">{d}</span><span class="s1">/</span><span class="si">{f}</span><span class="s1">_temp_k</span><span class="si">{k}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">d</span><span class="o">=</span><span class="n">output_dir</span><span class="p">,</span>
                                                       <span class="n">f</span><span class="o">=</span><span class="n">output_file</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="p">)</span>
                    <span class="n">data</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;chain&#39;</span><span class="p">:</span> <span class="n">sampler</span><span class="o">.</span><span class="n">chain</span><span class="p">,</span>
                            <span class="s1">&#39;lnprob&#39;</span><span class="p">:</span> <span class="n">sampler</span><span class="o">.</span><span class="n">lnprobability</span><span class="p">,</span>
                            <span class="s1">&#39;ac_time&#39;</span><span class="p">:</span> <span class="n">ac_time</span><span class="p">,</span>
                             <span class="s1">&#39;AR&#39;</span><span class="p">:</span> <span class="n">ar_frac</span><span class="p">}</span>
                    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="s1">&#39;wb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">fileSave</span><span class="p">:</span>
                        <span class="n">pickle</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">fileSave</span><span class="p">)</span>

        <span class="c1"># We have reached convergence</span>
        <span class="k">if</span> <span class="n">k</span><span class="o">+</span><span class="mi">1</span> <span class="o">&gt;=</span> <span class="n">stop</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">verbosity</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;We break the loop because we have reached convergence&#39;</span><span class="p">)</span>
            <span class="k">break</span>
        <span class="c1"># We have reached the maximum number of steps for our Markov chain.</span>
        <span class="k">if</span> <span class="n">k</span><span class="o">+</span><span class="mi">1</span> <span class="o">&gt;=</span> <span class="n">nIterations</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="c1"># break to avoid a bug related to font type</span>
            <span class="k">break</span>
        
    <span class="n">isamples</span><span class="p">,</span> <span class="n">ln_proba</span><span class="p">,</span> <span class="n">ar</span> <span class="o">=</span> <span class="n">chain_zero_truncated</span><span class="p">(</span><span class="n">chain</span><span class="p">,</span> <span class="n">sampler</span><span class="o">.</span><span class="n">lnprobability</span><span class="p">,</span>
                                                  <span class="n">ar_frac</span><span class="p">)</span>   
    <span class="c1"># update units in the chain if needed</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">em_grid</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">em_lines</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">idx_line</span> <span class="o">=</span> <span class="n">labels</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">val</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;L&#39;</span><span class="p">:</span>
                <span class="n">R_si</span> <span class="o">=</span> <span class="n">isamples</span><span class="p">[:,:,</span><span class="n">idx_R</span><span class="p">]</span><span class="o">*</span><span class="n">con</span><span class="o">.</span><span class="n">R_jup</span><span class="o">.</span><span class="n">value</span>
                <span class="n">isamples</span><span class="p">[:,:,</span><span class="n">idx_line</span><span class="p">]</span> <span class="o">*=</span> <span class="mi">4</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">R_si</span><span class="o">**</span><span class="mi">2</span>
            <span class="k">elif</span> <span class="n">val</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;LogL&#39;</span><span class="p">:</span>
                <span class="n">R_si</span> <span class="o">=</span> <span class="n">isamples</span><span class="p">[:,:,</span><span class="n">idx_R</span><span class="p">]</span><span class="o">*</span><span class="n">con</span><span class="o">.</span><span class="n">R_jup</span><span class="o">.</span><span class="n">value</span>
                <span class="n">conv_fac</span> <span class="o">=</span> <span class="mi">4</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">R_si</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="n">con</span><span class="o">.</span><span class="n">L_sun</span><span class="o">.</span><span class="n">value</span>
                <span class="n">isamples</span><span class="p">[:,:,</span><span class="n">idx_line</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">isamples</span><span class="p">[:,:,</span><span class="n">idx_line</span><span class="p">]</span><span class="o">*</span><span class="n">conv_fac</span><span class="p">)</span>
      
    <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="n">nIterations</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">verbosity</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;We have reached the limit # of steps without convergence&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;You may have to increase niteration_limit&quot;</span><span class="p">)</span>
    <span class="c1"># #########################################################################</span>
    <span class="c1"># Construction of the independent samples</span>
    <span class="c1"># #########################################################################</span>
 

    <span class="k">if</span> <span class="n">save</span><span class="p">:</span>
        <span class="n">frame</span> <span class="o">=</span> <span class="n">inspect</span><span class="o">.</span><span class="n">currentframe</span><span class="p">()</span>
        <span class="n">args</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">values</span> <span class="o">=</span> <span class="n">inspect</span><span class="o">.</span><span class="n">getargvalues</span><span class="p">(</span><span class="n">frame</span><span class="p">)</span>
        <span class="n">input_parameters</span> <span class="o">=</span> <span class="p">{</span><span class="n">j</span><span class="p">:</span> <span class="n">values</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">:]}</span>
        <span class="n">ac_time</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">dim</span><span class="p">):</span>
            <span class="n">ac_time</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">isamples</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">autocorr_test</span><span class="p">(</span><span class="n">isamples</span><span class="p">[:,:,</span><span class="n">j</span><span class="p">]))</span>
        <span class="n">output</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;isamples&#39;</span><span class="p">:</span> <span class="n">isamples</span><span class="p">,</span>
                  <span class="c1">#&#39;chain&#39;: chain,</span>
                  <span class="s1">&#39;input_parameters&#39;</span><span class="p">:</span> <span class="n">input_parameters</span><span class="p">,</span>
                  <span class="s1">&#39;AR&#39;</span><span class="p">:</span> <span class="n">ar</span><span class="p">,</span>
                  <span class="s1">&#39;ac_time&#39;</span><span class="p">:</span> <span class="n">ac_time</span><span class="p">,</span>
                  <span class="s1">&#39;lnprobability&#39;</span><span class="p">:</span> <span class="n">ln_proba</span><span class="p">}</span>
                  
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">output_dir</span><span class="o">+</span><span class="n">output_file</span><span class="p">,</span> <span class="s1">&#39;wb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">fileSave</span><span class="p">:</span>
            <span class="n">pickle</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="n">fileSave</span><span class="p">)</span>
        
        <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">The file MCMC_results has been stored in the folder </span><span class="si">{}</span><span class="s2">&quot;</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">output_dir</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">verbosity</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">timing</span><span class="p">(</span><span class="n">start_time</span><span class="p">)</span>
                                    
    <span class="k">return</span> <span class="n">isamples</span><span class="p">,</span> <span class="n">ln_proba</span></div>

                                    
<div class="viewcode-block" id="chain_zero_truncated"><a class="viewcode-back" href="../../special.html#special.mcmc_sampling.chain_zero_truncated">[docs]</a><span class="k">def</span> <span class="nf">chain_zero_truncated</span><span class="p">(</span><span class="n">chain</span><span class="p">,</span> <span class="n">ln_proba</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ar</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the Markov chain with the dimension: walkers x steps* x parameters,</span>
<span class="sd">    where steps* is the last step before having 0 (not yet constructed chain).</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    chain: numpy.array</span>
<span class="sd">        The MCMC chain.</span>
<span class="sd">    ln_proba: numpy.array, opt</span>
<span class="sd">        Corresponding ln-probabilities.</span>
<span class="sd">     </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out: numpy.array</span>
<span class="sd">        The truncated MCMC chain, that is to say, the chain which only contains</span>
<span class="sd">        relevant information.</span>
<span class="sd">    out_ln_proba: numpy.array</span>
<span class="sd">        If ln_proba is provided as input, out_ln_proba contains the </span>
<span class="sd">        zero-truncated ln-proba (i.e. matching shape with non-zero samples)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">idxzero</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">chain</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="n">idxzero</span> <span class="o">=</span> <span class="n">chain</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">res</span> <span class="o">=</span> <span class="p">[</span><span class="n">chain</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">:</span><span class="n">idxzero</span><span class="p">,</span> <span class="p">:]]</span>
        
    <span class="k">if</span> <span class="n">ln_proba</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">res</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ln_proba</span><span class="p">[:,</span><span class="mi">0</span><span class="p">:</span><span class="n">idxzero</span><span class="p">])</span>
    <span class="k">if</span> <span class="n">ar</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">res</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ar</span><span class="p">[:,</span><span class="mi">0</span><span class="p">:</span><span class="n">idxzero</span><span class="p">])</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">res</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">res</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">res</span><span class="p">)</span></div>
 
   
<div class="viewcode-block" id="show_walk_plot"><a class="viewcode-back" href="../../special.html#special.mcmc_sampling.show_walk_plot">[docs]</a><span class="k">def</span> <span class="nf">show_walk_plot</span><span class="p">(</span><span class="n">chain</span><span class="p">,</span> <span class="n">labels</span><span class="p">,</span> <span class="n">save</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">output_dir</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">ntrunc</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span>
                   <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Display/save a figure showing the path of each walker during the MCMC run.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    chain: numpy.array</span>
<span class="sd">        The Markov chain. The shape of chain must be nwalkers x length x dim.</span>
<span class="sd">        If a part of the chain is filled with zero values, the method will</span>
<span class="sd">        discard these steps.</span>
<span class="sd">    labels: Tuple of strings</span>
<span class="sd">        Tuple of labels in the same order as initial_state, that is:</span>
<span class="sd">        - first all parameters related to loaded models (e.g. &#39;Teff&#39;, &#39;logg&#39;)</span>
<span class="sd">        - next the planet photometric radius &#39;R&#39;,</span>
<span class="sd">        - (optionally) the optical extinction &#39;Av&#39;.</span>
<span class="sd">        - (optionally) &#39;Tbb1&#39;, &#39;Rbb1&#39;, &#39;Tbb2&#39;, &#39;Rbb2&#39;, etc. for each extra bb</span>
<span class="sd">        contribution</span>
<span class="sd">    save: boolean, default: False</span>
<span class="sd">        If True, a pdf file is created.</span>
<span class="sd">    output_dir: str, optional</span>
<span class="sd">        The name of the output directory which contains the output files in the </span>
<span class="sd">        case  ``save`` is True.    </span>
<span class="sd">    ntrunc: int, opt</span>
<span class="sd">        max number of walkers plotted. If too many walkers the plot will become</span>
<span class="sd">        too voluminous and too crowded. Plot will be truncated to only ntrunc </span>
<span class="sd">        first walkers</span>
<span class="sd">    kwargs:</span>
<span class="sd">        Additional attributes are passed to the matplotlib plot method.</span>
<span class="sd">                                                        </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    Display the figure or create a pdf file named walk_plot.pdf in the working</span>
<span class="sd">    directory.</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">npar</span> <span class="o">=</span> <span class="n">chain</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span> <span class="o">!=</span> <span class="n">npar</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Labels length should match chain last dimension&quot;</span><span class="p">)</span>
    <span class="n">temp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">chain</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">temp</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">chain</span> <span class="o">=</span> <span class="n">chain</span><span class="p">[:,</span> <span class="p">:</span><span class="n">temp</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="p">:]</span>


    <span class="n">color</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;color&#39;</span><span class="p">,</span> <span class="s1">&#39;k&#39;</span><span class="p">)</span>
    <span class="n">alpha</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;alpha&#39;</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">)</span>
    <span class="n">filename</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;filename&#39;</span><span class="p">,</span><span class="s1">&#39;walk_plot.pdf&#39;</span><span class="p">)</span>
    <span class="c1">#labels = kwargs.pop(&#39;labels&#39;, [&quot;$r$&quot;, r&quot;$\theta$&quot;, &quot;$f$&quot;])</span>
    <span class="n">fig</span><span class="p">,</span> <span class="n">axes</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="n">npar</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">sharex</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                             <span class="n">figsize</span><span class="o">=</span><span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;figsize&#39;</span><span class="p">,</span> <span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">npar</span><span class="p">))))</span>
    <span class="k">if</span> <span class="n">npar</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">:</span>
        <span class="n">axes</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;xlabel&#39;</span><span class="p">,</span> <span class="s1">&#39;step number&#39;</span><span class="p">))</span>
        <span class="n">axes</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">(</span><span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;xlim&#39;</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">chain</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]]))</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">npar</span><span class="p">):</span>
            <span class="n">axes</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">chain</span><span class="p">[:</span><span class="n">ntrunc</span><span class="p">,</span> <span class="p">:,</span> <span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">color</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="n">axes</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">yaxis</span><span class="o">.</span><span class="n">set_major_locator</span><span class="p">(</span><span class="n">MaxNLocator</span><span class="p">(</span><span class="mi">5</span><span class="p">))</span>
            <span class="n">axes</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="n">labels</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">axes</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;xlabel&#39;</span><span class="p">,</span> <span class="s1">&#39;step number&#39;</span><span class="p">))</span>
        <span class="n">axes</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">(</span><span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;xlim&#39;</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">chain</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]]))</span>            
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">npar</span><span class="p">):</span>
            <span class="n">axes</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">chain</span><span class="p">[:</span><span class="n">ntrunc</span><span class="p">,</span> <span class="p">:,</span> <span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">color</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="n">axes</span><span class="o">.</span><span class="n">yaxis</span><span class="o">.</span><span class="n">set_major_locator</span><span class="p">(</span><span class="n">MaxNLocator</span><span class="p">(</span><span class="mi">5</span><span class="p">))</span>
            <span class="n">axes</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="n">labels</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
    <span class="n">fig</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">(</span><span class="n">h_pad</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">save</span><span class="p">:</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">output_dir</span><span class="o">+</span><span class="n">filename</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="n">fig</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span></div>


<div class="viewcode-block" id="show_corner_plot"><a class="viewcode-back" href="../../special.html#special.mcmc_sampling.show_corner_plot">[docs]</a><span class="k">def</span> <span class="nf">show_corner_plot</span><span class="p">(</span><span class="n">chain</span><span class="p">,</span> <span class="n">burnin</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">save</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">output_dir</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> 
                     <span class="n">mcmc_res</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">units</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ndig</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">labels_plot</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> 
                     <span class="n">plot_name</span><span class="o">=</span><span class="s1">&#39;corner_plot.pdf&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Display/save a figure showing the corner plot (pdfs + correlation plots).</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    chain: numpy.array</span>
<span class="sd">        The Markov chain. The shape of chain must be nwalkers x length x dim.</span>
<span class="sd">        If a part of the chain is filled with zero values, the method will</span>
<span class="sd">        discard these steps.</span>
<span class="sd">    burnin: float, default: 0</span>
<span class="sd">        The fraction of a walker we want to discard.</span>
<span class="sd">    save: boolean, default: False</span>
<span class="sd">        If True, a pdf file is created.</span>
<span class="sd">    output_dir: str, optional</span>
<span class="sd">        The name of the output directory which contains the output files in the </span>
<span class="sd">        case  ``save`` is True.    </span>
<span class="sd">    mcmc_res: numpy array OR tuple of 2 dictionaries/np.array, opt</span>
<span class="sd">        Values to be printed on top of each 1d posterior distribution   </span>
<span class="sd">        * if numpy array: \</span>
<span class="sd">        - npar x 3 dimensions (where npar is the number of parameters), \</span>
<span class="sd">        containing the most likely value of each parameter and the lower \</span>
<span class="sd">        and upper uncertainties at the desired quantiles, resp. </span>
<span class="sd">        - npar x 2 dimensions: same as above but with a single value of  \</span>
<span class="sd">        uncertainty. E.g. output of spec_confidence() for a gaussian fit</span>
<span class="sd">        * if tuple of 2 dictionaries: output of spec_confidence without \</span>
<span class="sd">        gaussian fit</span>
<span class="sd">        * if tuple of 2 np.array: output of spec_confidence() with gaussian fit</span>
<span class="sd">    units: tuple, opt</span>
<span class="sd">        Tuple of strings containing units for each parameter. If provided,</span>
<span class="sd">        mcmc_res will be printed on top of each 1d posterior distribution along </span>
<span class="sd">        with these units.</span>
<span class="sd">    ndig: tuple, opt</span>
<span class="sd">        Number of digits precision for each printed parameter</span>
<span class="sd">    labels_plot: tuple, opt</span>
<span class="sd">        Labels corresponding to parameter names, used for the plot. If None,</span>
<span class="sd">        will use &quot;labels&quot; passed in kwargs.</span>
<span class="sd">    kwargs:</span>
<span class="sd">        Additional attributes passed to the corner.corner() method.</span>
<span class="sd">        (e.g. &#39;labels&#39;, &#39;labels_tit&#39;, &#39;labels_tit_unit&#39;, &#39;title_kwargs&#39;)</span>
<span class="sd">                    </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    Display the figure or create a pdf file named walk_plot.pdf in the working</span>
<span class="sd">    directory.</span>
<span class="sd">        </span>
<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ImportError</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">npar</span> <span class="o">=</span> <span class="n">chain</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">if</span> <span class="s2">&quot;labels&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
        <span class="n">labels</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;labels&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">labels_plot</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">labels_plot</span> <span class="o">=</span> <span class="n">labels</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">labels</span> <span class="o">=</span> <span class="kc">None</span>
        
    <span class="c1"># allows for different title/units on top of 1D posterior distributions</span>
    <span class="n">labels_tit</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;labels_tit&#39;</span><span class="p">,</span> <span class="n">labels_plot</span><span class="p">)</span>
    <span class="n">labels_tit_unit</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;labels_tit_unit&#39;</span><span class="p">,</span> <span class="n">units</span><span class="p">)</span>
    
    <span class="k">try</span><span class="p">:</span>
        <span class="n">temp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">chain</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">temp</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">chain</span> <span class="o">=</span> <span class="n">chain</span><span class="p">[:,</span> <span class="p">:</span><span class="n">temp</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="p">:]</span>
        <span class="n">length</span> <span class="o">=</span> <span class="n">chain</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">indburn</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">burnin</span><span class="o">*</span><span class="p">(</span><span class="n">length</span><span class="o">-</span><span class="mi">1</span><span class="p">)))</span>
        <span class="n">chain</span> <span class="o">=</span> <span class="n">chain</span><span class="p">[:,</span> <span class="n">indburn</span><span class="p">:</span><span class="n">length</span><span class="p">,</span> <span class="p">:]</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">npar</span><span class="p">))</span>
    <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
        <span class="k">pass</span>

    <span class="k">if</span> <span class="n">chain</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;It seems the chain is empty. Have you run the MCMC?&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">fig</span> <span class="o">=</span> <span class="n">corner</span><span class="o">.</span><span class="n">corner</span><span class="p">(</span><span class="n">chain</span><span class="p">,</span> <span class="n">labels</span><span class="o">=</span><span class="n">labels_plot</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        
    <span class="k">if</span> <span class="n">mcmc_res</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">labels</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">title_kwargs</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;title_kwargs&#39;</span><span class="p">,</span> <span class="p">{})</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mcmc_res</span><span class="p">,</span><span class="nb">tuple</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">mcmc_res</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;mcmc_res should have 2 elements&quot;</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">mcmc_res</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">!=</span> <span class="n">npar</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">mcmc_res</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">!=</span> <span class="n">npar</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;dict should have as many entries as there are params&quot;</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">labels</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;labels should be provided&quot;</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>                
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mcmc_res</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">mcmc_res</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">npar</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;mcmc_res first dim should be equal to number of params&quot;</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>  
        <span class="k">else</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;type of mcmc_res not recognised&quot;</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
        <span class="c1"># Extract the axes</span>
        <span class="n">axes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">fig</span><span class="o">.</span><span class="n">axes</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">npar</span><span class="p">,</span> <span class="n">npar</span><span class="p">))</span>
                
        <span class="c1"># Loop over the diagonal</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">npar</span><span class="p">):</span>
            <span class="n">ax</span> <span class="o">=</span> <span class="n">axes</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span>
            <span class="n">title</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mcmc_res</span><span class="p">,</span><span class="nb">tuple</span><span class="p">):</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mcmc_res</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="nb">dict</span><span class="p">):</span>
                    <span class="n">q_50</span> <span class="o">=</span> <span class="n">mcmc_res</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">labels</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>
                    <span class="n">q_m</span> <span class="o">=</span> <span class="n">mcmc_res</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">labels</span><span class="p">[</span><span class="n">i</span><span class="p">]][</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">q_p</span> <span class="o">=</span> <span class="n">mcmc_res</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">labels</span><span class="p">[</span><span class="n">i</span><span class="p">]][</span><span class="mi">1</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">q_50</span> <span class="o">=</span> <span class="n">mcmc_res</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">q_m</span> <span class="o">=</span> <span class="n">mcmc_res</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">q_p</span> <span class="o">=</span> <span class="n">q_m</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">q_50</span> <span class="o">=</span> <span class="n">mcmc_res</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">q_m</span> <span class="o">=</span> <span class="n">mcmc_res</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">mcmc_res</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">==</span><span class="mi">3</span><span class="p">:</span>
                    <span class="n">q_p</span> <span class="o">=</span> <span class="n">mcmc_res</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">q_p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">q_m</span><span class="p">)</span>
                    <span class="n">q_m</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">q_m</span><span class="p">)</span>

            <span class="c1"># Format the quantile display.</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">fmt</span> <span class="o">=</span> <span class="s2">&quot;{{:.</span><span class="si">{0}</span><span class="s2">f}}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">ndig</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="o">.</span><span class="n">format</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="n">fmt</span> <span class="o">=</span> <span class="s2">&quot;{{:.2f}}&quot;</span><span class="o">.</span><span class="n">format</span>
            <span class="n">title</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;${{</span><span class="si">{0}</span><span class="s2">}}_{{</span><span class="si">{1}</span><span class="s2">}}^{{+</span><span class="si">{2}</span><span class="s2">}}$&quot;</span>
            <span class="n">title</span> <span class="o">=</span> <span class="n">title</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">fmt</span><span class="p">(</span><span class="n">q_50</span><span class="p">),</span> <span class="n">fmt</span><span class="p">(</span><span class="n">q_m</span><span class="p">),</span> <span class="n">fmt</span><span class="p">(</span><span class="n">q_p</span><span class="p">))</span>

            <span class="c1"># Add in the column name if it&#39;s given.</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">title</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">{0}</span><span class="s2"> = </span><span class="si">{1}</span><span class="s2"> </span><span class="si">{2}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">labels_tit</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">title</span><span class="p">,</span> 
                                               <span class="n">labels_tit_unit</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="n">title</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">{0}</span><span class="s2"> = </span><span class="si">{1}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">labels_tit</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">title</span><span class="p">)</span>
                
            <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="n">title</span><span class="p">,</span> <span class="o">**</span><span class="n">title_kwargs</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">save</span><span class="p">:</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">output_dir</span><span class="o">+</span><span class="n">plot_name</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="n">fig</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span></div>


<div class="viewcode-block" id="confidence"><a class="viewcode-back" href="../../special.html#special.mcmc_sampling.confidence">[docs]</a><span class="k">def</span> <span class="nf">confidence</span><span class="p">(</span><span class="n">isamples</span><span class="p">,</span> <span class="n">labels</span><span class="p">,</span> <span class="n">cfd</span><span class="o">=</span><span class="mf">68.27</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">gaussian_fit</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> 
               <span class="n">weights</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">save</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">output_dir</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> 
               <span class="n">bounds</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">priors</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Determine the highly probable value for each model parameter, as well as</span>
<span class="sd">    the 1-sigma confidence interval.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    isamples: numpy.array</span>
<span class="sd">        The independent samples for each model parameter.</span>
<span class="sd">    labels: Tuple of strings</span>
<span class="sd">        Tuple of labels in the same order as initial_state, that is:</span>
<span class="sd">        - first all parameters related to loaded models (e.g. &#39;Teff&#39;, &#39;logg&#39;)</span>
<span class="sd">        - next the planet photometric radius &#39;R&#39;,</span>
<span class="sd">        - (optionally) the optical extinction &#39;Av&#39;.</span>
<span class="sd">        - (optionally) &#39;Tbb1&#39;, &#39;Rbb1&#39;, &#39;Tbb2&#39;, &#39;Rbb2&#39;, etc. for each extra bb \</span>
<span class="sd">        contribution</span>
<span class="sd">    cfd: float, optional</span>
<span class="sd">        The confidence level given in percentage.</span>
<span class="sd">    bins: int, optional</span>
<span class="sd">        The number of bins used to sample the posterior distributions.</span>
<span class="sd">    gaussian_fit: boolean, optional</span>
<span class="sd">        If True, a gaussian fit is performed in order to determine (\mu,\sigma)</span>
<span class="sd">    weights : (n, ) numpy ndarray or None, optional</span>
<span class="sd">        An array of weights for each sample.</span>
<span class="sd">    verbose: boolean, optional</span>
<span class="sd">        Display information in the shell.</span>
<span class="sd">    save: boolean, optional</span>
<span class="sd">        If &quot;True&quot;, a txt file with the results is saved in the output</span>
<span class="sd">        repository.</span>
<span class="sd">    bounds: dictionary, opt</span>
<span class="sd">        Only used if a text file is saved summarizing results+bounds+priors.</span>
<span class="sd">        Should be the same bounds as provided to the MCMC.</span>
<span class="sd">    priors: dictionary, opt</span>
<span class="sd">        Only used if a text file is saved summarizing results+bounds+priors.</span>
<span class="sd">        Should be the same priors as provided to the MCMC.</span>
<span class="sd">    kwargs: optional</span>
<span class="sd">        Additional attributes are passed to the matplotlib hist() method.</span>
<span class="sd">        </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out: tuple</span>
<span class="sd">        A 2 elements tuple with the highly probable solution and the confidence</span>
<span class="sd">        interval.</span>
<span class="sd">        </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">title</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;title&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        
    <span class="n">output_file</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;filename&#39;</span><span class="p">,</span> <span class="s1">&#39;confidence.txt&#39;</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">gaussian_fit</span><span class="p">:</span>
        <span class="n">output_pdf</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;pdfname&#39;</span><span class="p">,</span><span class="s1">&#39;confi_hist_spec_params_gaussfit.pdf&#39;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">output_pdf</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;pdfname&#39;</span><span class="p">,</span><span class="s1">&#39;confi_hist_spec_params.pdf&#39;</span><span class="p">)</span>
        
    <span class="k">try</span><span class="p">:</span>
        <span class="n">l</span> <span class="o">=</span> <span class="n">isamples</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="n">l</span> <span class="o">=</span> <span class="mi">1</span>
     
    <span class="n">confidenceInterval</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">val_max</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">pKey</span> <span class="o">=</span> <span class="n">labels</span> <span class="c1">#[&#39;r&#39;, &#39;theta&#39;, &#39;f&#39;]</span>
    
    <span class="k">if</span> <span class="n">l</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">pKey</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Labels length should match chain last dimension&quot;</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">cfd</span> <span class="o">==</span> <span class="mi">100</span><span class="p">:</span>
        <span class="n">cfd</span> <span class="o">=</span> <span class="mf">99.9</span>
        
    <span class="c1">#########################################</span>
    <span class="c1">##  Determine the confidence interval  ##</span>
    <span class="c1">#########################################</span>
    <span class="k">if</span> <span class="n">gaussian_fit</span><span class="p">:</span>
        <span class="n">mu</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">l</span><span class="p">)</span>
        <span class="n">sigma</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">mu</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">gaussian_fit</span><span class="p">:</span>
        <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="mi">4</span><span class="o">*</span><span class="n">l</span><span class="p">),</span><span class="mi">8</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="mi">4</span><span class="o">*</span><span class="n">l</span><span class="p">),</span><span class="mi">4</span><span class="p">))</span>
    
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">l</span><span class="p">):</span>
        
        <span class="k">if</span> <span class="n">gaussian_fit</span><span class="p">:</span>
            <span class="n">n</span><span class="p">,</span> <span class="n">bin_vertices</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">hist</span><span class="p">(</span><span class="n">isamples</span><span class="p">[:,</span><span class="n">j</span><span class="p">],</span> <span class="n">bins</span><span class="o">=</span><span class="n">bins</span><span class="p">,</span>
                                               <span class="n">weights</span><span class="o">=</span><span class="n">weights</span><span class="p">,</span> <span class="n">histtype</span><span class="o">=</span><span class="s1">&#39;step&#39;</span><span class="p">,</span>
                                               <span class="n">edgecolor</span><span class="o">=</span><span class="s1">&#39;gray&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">n</span><span class="p">,</span> <span class="n">bin_vertices</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">ax</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">hist</span><span class="p">(</span><span class="n">isamples</span><span class="p">[:,</span><span class="n">j</span><span class="p">],</span> <span class="n">bins</span><span class="o">=</span><span class="n">bins</span><span class="p">,</span>
                                            <span class="n">weights</span><span class="o">=</span><span class="n">weights</span><span class="p">,</span> <span class="n">histtype</span><span class="o">=</span><span class="s1">&#39;step&#39;</span><span class="p">,</span>
                                            <span class="n">edgecolor</span><span class="o">=</span><span class="s1">&#39;gray&#39;</span><span class="p">)</span>
        <span class="n">bins_width</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">bin_vertices</span><span class="p">))</span>
        <span class="n">surface_total</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="o">*</span><span class="n">bins_width</span> <span class="o">*</span> <span class="n">n</span><span class="p">)</span>
        <span class="n">n_arg_sort</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">n</span><span class="p">)[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        
        <span class="n">test</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">pourcentage</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">jj</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">n_arg_sort</span><span class="p">):</span>
            <span class="n">test</span> <span class="o">=</span> <span class="n">test</span> <span class="o">+</span> <span class="n">bins_width</span><span class="o">*</span><span class="n">n</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">jj</span><span class="p">)]</span>
            <span class="n">pourcentage</span> <span class="o">=</span> <span class="n">test</span><span class="o">/</span><span class="n">surface_total</span><span class="o">*</span><span class="mi">100</span>
            <span class="k">if</span> <span class="n">pourcentage</span> <span class="o">&gt;</span> <span class="n">cfd</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                    <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;percentage for </span><span class="si">{}</span><span class="s1">: </span><span class="si">{}</span><span class="s1">%&#39;</span>
                    <span class="nb">print</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">pKey</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">pourcentage</span><span class="p">))</span>
                <span class="k">break</span>
        <span class="n">n_arg_min</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">n_arg_sort</span><span class="p">[:</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">())</span>
        <span class="n">n_arg_max</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">n_arg_sort</span><span class="p">[:</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">())</span>
        
        <span class="k">if</span> <span class="n">n_arg_min</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">n_arg_min</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">n_arg_max</span> <span class="o">==</span> <span class="n">bins</span><span class="p">:</span>
            <span class="n">n_arg_max</span> <span class="o">-=</span> <span class="mi">1</span>
        
        <span class="n">val_max</span><span class="p">[</span><span class="n">pKey</span><span class="p">[</span><span class="n">j</span><span class="p">]]</span> <span class="o">=</span> <span class="n">bin_vertices</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">n_arg_sort</span><span class="p">[</span><span class="mi">0</span><span class="p">])]</span><span class="o">+</span><span class="n">bins_width</span><span class="o">/</span><span class="mf">2.</span>
        <span class="n">confidenceInterval</span><span class="p">[</span><span class="n">pKey</span><span class="p">[</span><span class="n">j</span><span class="p">]]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">bin_vertices</span><span class="p">[</span><span class="n">n_arg_min</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span>
                                               <span class="n">bin_vertices</span><span class="p">[</span><span class="n">n_arg_max</span><span class="o">+</span><span class="mi">1</span><span class="p">]]</span>
                                               <span class="o">-</span> <span class="n">val_max</span><span class="p">[</span><span class="n">pKey</span><span class="p">[</span><span class="n">j</span><span class="p">]])</span>
                        
        <span class="n">arg</span> <span class="o">=</span> <span class="p">(</span><span class="n">isamples</span><span class="p">[:,</span> <span class="n">j</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">bin_vertices</span><span class="p">[</span><span class="n">n_arg_min</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span> <span class="o">*</span> \
              <span class="p">(</span><span class="n">isamples</span><span class="p">[:,</span> <span class="n">j</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">bin_vertices</span><span class="p">[</span><span class="n">n_arg_max</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">gaussian_fit</span><span class="p">:</span>
            <span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">hist</span><span class="p">(</span><span class="n">isamples</span><span class="p">[</span><span class="n">arg</span><span class="p">,</span><span class="n">j</span><span class="p">],</span> <span class="n">bins</span><span class="o">=</span><span class="n">bin_vertices</span><span class="p">,</span>
                          <span class="n">facecolor</span><span class="o">=</span><span class="s1">&#39;gray&#39;</span><span class="p">,</span> <span class="n">edgecolor</span><span class="o">=</span><span class="s1">&#39;darkgray&#39;</span><span class="p">,</span>
                          <span class="n">histtype</span><span class="o">=</span><span class="s1">&#39;stepfilled&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
            <span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">vlines</span><span class="p">(</span><span class="n">val_max</span><span class="p">[</span><span class="n">pKey</span><span class="p">[</span><span class="n">j</span><span class="p">]],</span> <span class="mi">0</span><span class="p">,</span> <span class="n">n</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">n_arg_sort</span><span class="p">[</span><span class="mi">0</span><span class="p">])],</span>
                            <span class="n">linestyles</span><span class="o">=</span><span class="s1">&#39;dashed&#39;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;red&#39;</span><span class="p">)</span>
            <span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="n">pKey</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">j</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;Counts&#39;</span><span class="p">)</span>

            <span class="n">mu</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">sigma</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">norm</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">isamples</span><span class="p">[:,</span> <span class="n">j</span><span class="p">])</span>
            <span class="n">n_fit</span><span class="p">,</span> <span class="n">bins_fit</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">histogram</span><span class="p">(</span><span class="n">isamples</span><span class="p">[:,</span> <span class="n">j</span><span class="p">],</span> <span class="n">bins</span><span class="p">,</span> <span class="n">density</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                                           <span class="n">weights</span><span class="o">=</span><span class="n">weights</span><span class="p">)</span>
            <span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">hist</span><span class="p">(</span><span class="n">isamples</span><span class="p">[:,</span> <span class="n">j</span><span class="p">],</span> <span class="n">bins</span><span class="p">,</span> <span class="n">density</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="n">weights</span><span class="p">,</span>
                          <span class="n">facecolor</span><span class="o">=</span><span class="s1">&#39;gray&#39;</span><span class="p">,</span> <span class="n">edgecolor</span><span class="o">=</span><span class="s1">&#39;darkgray&#39;</span><span class="p">,</span>
                          <span class="n">histtype</span><span class="o">=</span><span class="s1">&#39;step&#39;</span><span class="p">)</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">norm</span><span class="o">.</span><span class="n">pdf</span><span class="p">(</span><span class="n">bins_fit</span><span class="p">,</span> <span class="n">mu</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">sigma</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
            <span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">bins_fit</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="s1">&#39;r--&#39;</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.7</span><span class="p">)</span>

            <span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="n">pKey</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">j</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;Counts&#39;</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">title</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;</span><span class="si">{}</span><span class="s2">   $\mu$ = </span><span class="si">{:.4f}</span><span class="s2">, $\sigma$ = </span><span class="si">{:.4f}</span><span class="s2">&quot;</span>
                <span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">title</span><span class="p">,</span> <span class="n">mu</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">sigma</span><span class="p">[</span><span class="n">j</span><span class="p">]),</span>
                                   <span class="n">fontsize</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">ax</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">hist</span><span class="p">(</span><span class="n">isamples</span><span class="p">[</span><span class="n">arg</span><span class="p">,</span><span class="n">j</span><span class="p">],</span><span class="n">bins</span><span class="o">=</span><span class="n">bin_vertices</span><span class="p">,</span> <span class="n">facecolor</span><span class="o">=</span><span class="s1">&#39;gray&#39;</span><span class="p">,</span>
                       <span class="n">edgecolor</span><span class="o">=</span><span class="s1">&#39;darkgray&#39;</span><span class="p">,</span> <span class="n">histtype</span><span class="o">=</span><span class="s1">&#39;stepfilled&#39;</span><span class="p">,</span>
                       <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
            <span class="n">ax</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">vlines</span><span class="p">(</span><span class="n">val_max</span><span class="p">[</span><span class="n">pKey</span><span class="p">[</span><span class="n">j</span><span class="p">]],</span> <span class="mi">0</span><span class="p">,</span> <span class="n">n</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">n_arg_sort</span><span class="p">[</span><span class="mi">0</span><span class="p">])],</span>
                         <span class="n">linestyles</span><span class="o">=</span><span class="s1">&#39;dashed&#39;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;red&#39;</span><span class="p">)</span>
            <span class="n">ax</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="n">pKey</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">j</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">ax</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;Counts&#39;</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">title</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> - </span><span class="si">{:.3f}</span><span class="s2"> </span><span class="si">{:.3f}</span><span class="s2"> +</span><span class="si">{:.3f}</span><span class="s2">&quot;</span>
                <span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">title</span><span class="p">,</span> <span class="n">val_max</span><span class="p">[</span><span class="n">pKey</span><span class="p">[</span><span class="n">j</span><span class="p">]],</span> 
                                           <span class="n">confidenceInterval</span><span class="p">[</span><span class="n">pKey</span><span class="p">[</span><span class="n">j</span><span class="p">]][</span><span class="mi">0</span><span class="p">],</span> 
                                           <span class="n">confidenceInterval</span><span class="p">[</span><span class="n">pKey</span><span class="p">[</span><span class="n">j</span><span class="p">]][</span><span class="mi">1</span><span class="p">]),</span>
                                <span class="n">fontsize</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>

        <span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">(</span><span class="n">w_pad</span><span class="o">=</span><span class="mf">0.1</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">save</span><span class="p">:</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">output_dir</span><span class="o">+</span><span class="n">output_pdf</span><span class="p">)</span>


    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">l</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;******* Results for </span><span class="si">{}</span><span class="s2"> ***** &quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">pKey</span><span class="p">[</span><span class="n">j</span><span class="p">]))</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n\n</span><span class="s1">Confidence intervals:&#39;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1">: </span><span class="si">{}</span><span class="s1"> [</span><span class="si">{}</span><span class="s1">,</span><span class="si">{}</span><span class="s1">]&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">pKey</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">val_max</span><span class="p">[</span><span class="n">pKey</span><span class="p">[</span><span class="n">j</span><span class="p">]],</span>
                                          <span class="n">confidenceInterval</span><span class="p">[</span><span class="n">pKey</span><span class="p">[</span><span class="n">j</span><span class="p">]][</span><span class="mi">0</span><span class="p">],</span>
                                          <span class="n">confidenceInterval</span><span class="p">[</span><span class="n">pKey</span><span class="p">[</span><span class="n">j</span><span class="p">]][</span><span class="mi">1</span><span class="p">]))</span>
            <span class="k">if</span> <span class="n">gaussian_fit</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Gaussian fit results:&#39;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1">: </span><span class="si">{}</span><span class="s1"> +-</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">pKey</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">mu</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">sigma</span><span class="p">[</span><span class="n">j</span><span class="p">]))</span>

    <span class="c1">##############################################</span>
    <span class="c1">##  Write inference results in a text file  ##</span>
    <span class="c1">##############################################</span>
    <span class="k">if</span> <span class="n">save</span><span class="p">:</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">output_dir</span><span class="o">+</span><span class="n">output_file</span><span class="p">,</span> <span class="s2">&quot;w&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;######################################</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;####   MCMC results (confidence)   ###</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;######################################</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39; </span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;Results of the MCMC fit</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;----------------------- </span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39; </span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">bounds</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;Bounds</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
                <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;------&#39;</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">l</span><span class="p">):</span>
                    <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="si">{}</span><span class="s1">: [</span><span class="si">{}</span><span class="s1">,</span><span class="si">{}</span><span class="s1">]&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">pKey</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">bounds</span><span class="p">[</span><span class="n">pKey</span><span class="p">[</span><span class="n">j</span><span class="p">]][</span><span class="mi">0</span><span class="p">],</span>
                                                   <span class="n">bounds</span><span class="p">[</span><span class="n">pKey</span><span class="p">[</span><span class="n">j</span><span class="p">]][</span><span class="mi">1</span><span class="p">]))</span>
                <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39; </span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
                <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39; </span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;Priors</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;------&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">priors</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">prior</span> <span class="ow">in</span> <span class="n">priors</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="si">{}</span><span class="s1">: </span><span class="si">{}</span><span class="s1">+-</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">prior</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">prior</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1"> None&#39;</span><span class="p">)</span>
            <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39; </span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39; </span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;&gt;&gt; Spectral parameters for a &#39;</span><span class="p">)</span>
            <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1"> </span><span class="si">% c</span><span class="s1">onfidence interval:</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">cfd</span><span class="p">))</span>
            
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">l</span><span class="p">):</span>
                <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1">: </span><span class="si">{}</span><span class="s1"> [</span><span class="si">{}</span><span class="s1">,</span><span class="si">{}</span><span class="s1">]&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">pKey</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">val_max</span><span class="p">[</span><span class="n">pKey</span><span class="p">[</span><span class="n">j</span><span class="p">]],</span>
                                              <span class="n">confidenceInterval</span><span class="p">[</span><span class="n">pKey</span><span class="p">[</span><span class="n">j</span><span class="p">]][</span><span class="mi">0</span><span class="p">],</span>
                                              <span class="n">confidenceInterval</span><span class="p">[</span><span class="n">pKey</span><span class="p">[</span><span class="n">j</span><span class="p">]][</span><span class="mi">1</span><span class="p">]))</span>
                <span class="k">if</span> <span class="n">gaussian_fit</span><span class="p">:</span>
                    <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;Gaussian fit results:&#39;</span><span class="p">)</span>
                    <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1">: </span><span class="si">{}</span><span class="s1"> +-</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">pKey</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">mu</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">sigma</span><span class="p">[</span><span class="n">j</span><span class="p">]))</span>

    <span class="k">if</span> <span class="n">gaussian_fit</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">mu</span><span class="p">,</span> <span class="n">sigma</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">val_max</span><span class="p">,</span> <span class="n">confidenceInterval</span></div>
</pre></div>

              </div>
              
            
                <!-- Previous / next buttons -->
<div class='prev-next-area'>
</div>
            
        </div>
    </div>
    <footer class="footer">
  <p>
    
      By Valentin Christiaens<br/>
    
        &copy; Copyright 2019-2022, Valentin Christiaens.<br/>
  </p>
</footer>
</main>


      </div>
    </div>
  
  <script src="../../_static/js/index.be7d3bbb2ef33a8344ce.js"></script>

  </body>
</html>