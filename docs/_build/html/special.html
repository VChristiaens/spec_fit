<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>special.chi &mdash; special  documentation</title>
      <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="author" title="About these documents" href="about.html" />
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="prev" title="Contributions" href="about.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="index.html">
            <img src="_static/Special_logo.jpeg" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Getting started</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="features.html">What makes it <cite>special</cite>?</a></li>
<li class="toctree-l1"><a class="reference internal" href="trimmed_readme.html">TL;DR setup guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="trimmed_readme.html#installation-and-dependencies">Installation and dependencies</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Tutorial</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="tutorials/walkthrough.html"><em>special</em> tutorial</a></li>
<li class="toctree-l1"><a class="reference internal" href="tutorials/walkthrough.html#1.-Loading-the-data">1. Loading the data</a></li>
<li class="toctree-l1"><a class="reference internal" href="tutorials/walkthrough.html#2.-Spectral-correlation-matrix">2. Spectral correlation matrix</a></li>
<li class="toctree-l1"><a class="reference internal" href="tutorials/walkthrough.html#3.-Preliminary-spectral-analysis">3. Preliminary spectral analysis</a></li>
<li class="toctree-l1"><a class="reference internal" href="tutorials/walkthrough.html#4.-MCMC-sampler-examples">4. MCMC sampler examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="tutorials/walkthrough.html#5.-Comparison-of-results">5. Comparison of results</a></li>
<li class="toctree-l1"><a class="reference internal" href="tutorials/walkthrough.html#6.-Nested-sampler-examples">6. Nested sampler examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="tutorials/walkthrough.html#7.-Best-fit-template-spectrum">7. Best-fit template spectrum</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">About</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="about.html">Contributions</a></li>
<li class="toctree-l1"><a class="reference internal" href="about.html#questions-and-suggestions">Questions and suggestions</a></li>
<li class="toctree-l1"><a class="reference internal" href="about.html#acknowledgements">Acknowledgements</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Package content</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="current reference internal" href="#">special.chi</a></li>
<li class="toctree-l1"><a class="reference internal" href="#module-special.config">special.config</a></li>
<li class="toctree-l1"><a class="reference internal" href="#module-special.fits">special.fits</a></li>
<li class="toctree-l1"><a class="reference internal" href="#module-special.mcmc_sampling">special.mcmc_sampling</a></li>
<li class="toctree-l1"><a class="reference internal" href="#module-special.model_resampling">special.model_resampling</a></li>
<li class="toctree-l1"><a class="reference internal" href="#module-special.nested_sampling">special.nested_sampling</a></li>
<li class="toctree-l1"><a class="reference internal" href="#module-special.spec_corr">special.spec_corr</a></li>
<li class="toctree-l1"><a class="reference internal" href="#module-special.spec_indices">special.spec_indices</a></li>
<li class="toctree-l1"><a class="reference internal" href="#module-special.template_fit">special.template_fit</a></li>
<li class="toctree-l1"><a class="reference internal" href="#module-special.utils_mcmc">special.utils_mcmc</a></li>
<li class="toctree-l1"><a class="reference internal" href="#module-special.utils_spec">special.utils_spec</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">special</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
      <li>special.chi</li>
      <li class="wy-breadcrumbs-aside">
              <a href="https://github.com/VChristiaens/special/blob/main/docs/special.rst" class="fa fa-github"> Edit on GitHub</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  
<style>
/* CSS overrides for sphinx_rtd_theme */

/* 24px margin */
.nbinput.nblast.container,
.nboutput.nblast.container {
    margin-bottom: 19px;  /* padding has already 5px */
}

/* ... except between code cells! */
.nblast.container + .nbinput.container {
    margin-top: -19px;
}

.admonition > p:before {
    margin-right: 4px;  /* make room for the exclamation icon */
}

/* Fix math alignment, see https://github.com/rtfd/sphinx_rtd_theme/pull/686 */
.math {
    text-align: unset;
}
</style>
<div class="section" id="module-special.chi">
<span id="special-chi"></span><span id="special"></span><h1>special.chi<a class="headerlink" href="#module-special.chi" title="Permalink to this headline"></a></h1>
<p>Function defining the goodness of fit.</p>
<dl class="py function">
<dt class="sig sig-object py" id="special.chi.gof_scal">
<span class="sig-prename descclassname"><span class="pre">special.chi.</span></span><span class="sig-name descname"><span class="pre">gof_scal</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">params</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lbda_obs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">spec_obs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">err_obs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lbda_mod</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">spec_mod</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dlbda_obs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">instru_corr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">instru_fwhm</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">instru_idx</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">filter_reader</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ext_range</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/special/chi.html#gof_scal"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#special.chi.gof_scal" title="Permalink to this definition"></a></dt>
<dd><p>Wrapper for the goodness of fit routine to search for best template
library fitting spectrum. The only difference with <cite>goodness_of_fit</cite> is
the “params” argument.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>params</strong> (<em>tuple</em>) – Tuple of 1 or 2 elements: scaling factor and (optionally) differential
optical extinction $Delta A_V$ ($Delta A_V$ can be negative if
template spectra are not dereddened).</p></li>
<li><p><strong>lbda_obs</strong> (<em>numpy 1d ndarray</em><em> or </em><em>list</em>) – Wavelength of observed spectrum. If several instruments, should be
ordered per instrument, not necessarily as monotonically increasing
wavelength. Hereafter, n_ch = len(lbda_obs).</p></li>
<li><p><strong>spec_obs</strong> (<em>numpy 1d ndarray</em><em> or </em><em>list</em>) – Observed spectrum for each value of lbda_obs.</p></li>
<li><p><strong>err_obs</strong> (<em>numpy 1d/2d ndarray</em><em> or </em><em>list</em>) – Uncertainties on the observed spectrum. If 2d array, should be [2,n_ch]
where the first (resp. second) column corresponds to lower (upper)
uncertainty, and n_ch is the length of lbda_obs and spec_obs.</p></li>
<li><p><strong>lbda_mod</strong> (<em>numpy 1d ndarray</em><em> or </em><em>list</em>) – Wavelength of tested model. Should have a wider wavelength extent than
the observed spectrum.</p></li>
<li><p><strong>spec_mod</strong> (<em>numpy 1d ndarray</em>) – Model spectrum. It does not require the same wavelength sampling as the
observed spectrum. If higher spectral resolution, it will be convolved
with the instrumental spectral psf (if instru_fwhm is provided) and
then binned to the same sampling. If lower spectral resolution, a
linear interpolation is performed to infer the value at the observed
spectrum wavelength sampling.</p></li>
<li><p><strong>dlbda_obs</strong> (<em>numpy 1d ndarray</em><em> or </em><em>list</em><em>, </em><em>optional</em>) – Spectral channel width for the observed spectrum. It should be provided
IF one wants to weigh each point based on the spectral
resolution of the respective instruments (as in Olofsson et al. 2016).</p></li>
<li><p><strong>instru_corr</strong> (<em>numpy 2d ndarray</em><em> or </em><em>list</em><em>, </em><em>optional</em>) – Spectral correlation throughout post-processed images in which the
spectrum is measured. It is specific to the combination of instrument,
algorithm and radial separation of the companion from the central star.
Can be computed using distances.spectral_correlation(). In case of
a spectrum obtained with different instruments, build it with
distances.combine_corrs(). If not provided, it will consider the
uncertainties in each spectral channels are independent. See Greco &amp;
Brandt (2017) for details.</p></li>
<li><p><strong>instru_fwhm</strong> (<em>float</em><em> or </em><em>list</em><em>, </em><em>optional</em>) – The instrumental spectral fwhm provided in nm. This is used to convolve
the model spectrum. If several instruments are used, provide a list of
instru_fwhm values, one for each instrument whose spectral resolution
is coarser than the model - including broad band
filter FWHM if relevant.</p></li>
<li><p><strong>instru_idx</strong> (<em>numpy 1d array</em><em>, </em><em>optional</em>) – 1d array containing an index representing each instrument used
to obtain the spectrum, label them from 0 to n_instru. Zero for points
that don’t correspond to any instru_fwhm provided above, and i in
[1,n_instru] for points associated to instru_fwhm[i-1]. This parameter
must be provided if the spectrum consists of points obtained with
different instruments.</p></li>
<li><p><strong>filter_reader</strong> (<em>python routine</em><em>, </em><em>optional</em>) – External routine that reads a filter file and returns a 2D numpy array,
where the first column corresponds to wavelengths, and the second
contains transmission values. Important: if not provided, but strings
are detected in instru_fwhm, the default format assumed for the files:
- first row containing header
- starting from 2nd row: 1st column: WL in mu, 2nd column: transmission
Note: files should all have the same format and wavelength units.</p></li>
<li><p><strong>ext_range</strong> (<em>tuple</em><em> or </em><em>None</em><em>, </em><em>opt</em>) – If None: differential extinction is not to be considered as a free
parameter. Elif a tuple of 3 floats is provided, differential extinction
will be considered, with the floats as lower limit, upper limit and step
of the grid search.
Note: if simplex search, the range is still used to set a chi of
np.inf outside of the range.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>chi_sq</strong> – Goodness of fit indicator.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="special.chi.goodness_of_fit">
<span class="sig-prename descclassname"><span class="pre">special.chi.</span></span><span class="sig-name descname"><span class="pre">goodness_of_fit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">lbda_obs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">spec_obs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">err_obs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lbda_mod</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">spec_mod</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dlbda_obs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">instru_corr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">instru_fwhm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">instru_idx</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">filter_reader</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">plot</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">outfile</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/special/chi.html#goodness_of_fit"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#special.chi.goodness_of_fit" title="Permalink to this definition"></a></dt>
<dd><p>Function to estimate the goodness of fit indicator defined as
in Olofsson et al. 2016 (Eq. 8). In addition, if a spectral
correlation matrix is provided, it is used to take into account the
correlated noise between spectral channels (see Greco &amp; Brandt 2016).
The goodness of fit indicator is identical to a chi square when all
points are obtained from the same instrument (no additional weighting).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>lbda_obs</strong> (<em>numpy 1d ndarray</em><em> or </em><em>list</em>) – Wavelength of observed spectrum. If several instruments, should be
ordered per instrument, not necessarily as monotonically increasing
wavelength. Hereafter, n_ch = len(lbda_obs).</p></li>
<li><p><strong>spec_obs</strong> (<em>numpy 1d ndarray</em><em> or </em><em>list</em>) – Observed spectrum for each value of lbda_obs.</p></li>
<li><p><strong>err_obs</strong> (<em>numpy 1d/2d ndarray</em><em> or </em><em>list</em>) – Uncertainties on the observed spectrum. If 2d array, should be [2,n_ch]
where the first (resp. second) column corresponds to lower (upper)
uncertainty, and n_ch is the length of lbda_obs and spec_obs.</p></li>
<li><p><strong>lbda_mod</strong> (<em>numpy 1d ndarray</em><em> or </em><em>list</em>) – Wavelength of tested model. Should have a wider wavelength extent than
the observed spectrum.</p></li>
<li><p><strong>spec_mod</strong> (<em>numpy 1d ndarray</em>) – Model spectrum. It does not require the same wavelength sampling as the
observed spectrum. If higher spectral resolution, it will be convolved
with the instrumental spectral psf (if instru_fwhm is provided) and
then binned to the same sampling. If lower spectral resolution, a
linear interpolation is performed to infer the value at the observed
spectrum wavelength sampling.</p></li>
<li><p><strong>dlbda_obs</strong> (<em>numpy 1d ndarray</em><em> or </em><em>list</em><em>, </em><em>optional</em>) – Spectral channel width for the observed spectrum. It should be provided
IF one wants to weigh each point based on the spectral
resolution of the respective instruments (as in Olofsson et al. 2016).</p></li>
<li><p><strong>instru_corr</strong> (<em>numpy 2d ndarray</em><em> or </em><em>list</em><em>, </em><em>optional</em>) – Spectral correlation throughout post-processed images in which the
spectrum is measured. It is specific to the combination of instrument,
algorithm and radial separation of the companion from the central star.
Can be computed using distances.spectral_correlation(). In case of
a spectrum obtained with different instruments, build it with
distances.combine_corrs(). If not provided, it will consider the
uncertainties in each spectral channels are independent. See Greco &amp;
Brandt (2017) for details.</p></li>
<li><p><strong>instru_fwhm</strong> (<em>float</em><em> or </em><em>list</em><em>, </em><em>optional</em>) – The instrumental spectral fwhm provided in nm. This is used to convolve
the model spectrum. If several instruments are used, provide a list of
instru_fwhm values, one for each instrument whose spectral resolution
is coarser than the model - including broad band
filter FWHM if relevant.</p></li>
<li><p><strong>instru_idx</strong> (<em>numpy 1d array</em><em>, </em><em>optional</em>) – 1d array containing an index representing each instrument used
to obtain the spectrum, label them from 0 to n_instru. Zero for points
that don’t correspond to any instru_fwhm provided above, and i in
[1,n_instru] for points associated to instru_fwhm[i-1]. This parameter
must be provided if the spectrum consists of points obtained with
different instruments.</p></li>
<li><p><strong>filter_reader</strong> (<em>python routine</em><em>, </em><em>optional</em>) – External routine that reads a filter file and returns a 2D numpy array,
where the first column corresponds to wavelengths, and the second
contains transmission values. Important: if not provided, but strings
are detected in instru_fwhm, the default format assumed for the files:
- first row containing header
- starting from 2nd row: 1st column: WL in mu, 2nd column: transmission
Note: files should all have the same format and wavelength units.</p></li>
<li><p><strong>plot</strong> (<em>bool</em><em>, </em><em>optional</em>) – Whether to plot the</p></li>
<li><p><strong>outfile</strong> (<em>string</em><em>, </em><em>optional</em>) – Path+filename for the plot to be saved if provided.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>chi_sq</strong> – Goodness of fit indicator.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-special.config">
<span id="special-config"></span><h1>special.config<a class="headerlink" href="#module-special.config" title="Permalink to this headline"></a></h1>
<p>Module with configuration parameters and timing functions (inspired from VIP).</p>
<dl class="py function">
<dt class="sig sig-object py" id="special.config.time_fin">
<span class="sig-prename descclassname"><span class="pre">special.config.</span></span><span class="sig-name descname"><span class="pre">time_fin</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">start_time</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/special/config.html#time_fin"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#special.config.time_fin" title="Permalink to this definition"></a></dt>
<dd><p>Return the execution time of a script.</p>
<p>It requires the initialization  with the function time_ini().</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="special.config.time_ini">
<span class="sig-prename descclassname"><span class="pre">special.config.</span></span><span class="sig-name descname"><span class="pre">time_ini</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/special/config.html#time_ini"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#special.config.time_ini" title="Permalink to this definition"></a></dt>
<dd><p>Set and print the time at which the script started.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>start_time</strong> – Starting time.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>string</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="special.config.timing">
<span class="sig-prename descclassname"><span class="pre">special.config.</span></span><span class="sig-name descname"><span class="pre">timing</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">start_time</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/special/config.html#timing"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#special.config.timing" title="Permalink to this definition"></a></dt>
<dd><p>Print the execution time of a script.</p>
<p>It requires the initialization  with the function time_ini().</p>
</dd></dl>

</div>
<div class="section" id="module-special.fits">
<span id="special-fits"></span><h1>special.fits<a class="headerlink" href="#module-special.fits" title="Permalink to this headline"></a></h1>
<p>Module with various fits handling functions (same as in VIP)</p>
<dl class="py function">
<dt class="sig sig-object py" id="special.fits.info_fits">
<span class="sig-prename descclassname"><span class="pre">special.fits.</span></span><span class="sig-name descname"><span class="pre">info_fits</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fitsfilename</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/special/fits.html#info_fits"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#special.fits.info_fits" title="Permalink to this definition"></a></dt>
<dd><p>Print the information about a fits file.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>fitsfilename</strong> (<em>str</em>) – Path to the fits file.</p></li>
<li><p><strong>**kwargs</strong> (<em>optional</em>) – Optional arguments to the astropy.io.fits.open() function. E.g.
“output_verify” can be set to ignore, in case of non-standard header.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="special.fits.open_fits">
<span class="sig-prename descclassname"><span class="pre">special.fits.</span></span><span class="sig-name descname"><span class="pre">open_fits</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fitsfilename</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n=0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">header=False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ignore_missing_end=False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">precision=&lt;class</span> <span class="pre">'numpy.float32'&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_memmap=False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose=True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">**kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/special/fits.html#open_fits"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#special.fits.open_fits" title="Permalink to this definition"></a></dt>
<dd><p>Load a fits file into a memory as numpy array.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>fitsfilename</strong> (<em>string</em><em> or </em><em>pathlib.Path</em>) – Name of the fits file or <code class="docutils literal notranslate"><span class="pre">pathlib.Path</span></code> object</p></li>
<li><p><strong>n</strong> (<em>int</em><em>, </em><em>optional</em>) – It chooses which HDU to open. Default is the first one.</p></li>
<li><p><strong>header</strong> (<em>bool</em><em>, </em><em>optional</em>) – Whether to return the header along with the data or not.</p></li>
<li><p><strong>precision</strong> (<em>numpy dtype</em><em>, </em><em>optional</em>) – Float precision, by default np.float32 or single precision float.</p></li>
<li><p><strong>ignore_missing_end</strong> (<em>bool optional</em>) – Allows to open fits files with a header missing END card.</p></li>
<li><p><strong>return_memmap</strong> (<em>bool</em><em>, </em><em>optional</em>) – If True, the function returns the handle to the FITS file opened by
mmap. With the hdulist, array data of each HDU to be accessed with mmap,
rather than being read into memory all at once. This is particularly
useful for working with very large arrays that cannot fit entirely into
physical memory.</p></li>
<li><p><strong>verbose</strong> (<em>bool</em><em>, </em><em>optional</em>) – If True prints message of completion.</p></li>
<li><p><strong>**kwargs</strong> (<em>optional</em>) – Optional arguments to the astropy.io.fits.open() function. E.g.
“output_verify” can be set to ignore, in case of non-standard header.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>hdulist</strong> (<em>hdulist</em>) – [memmap=True] FITS file <code class="docutils literal notranslate"><span class="pre">n</span></code> hdulist.</p></li>
<li><p><strong>data</strong> (<em>numpy ndarray</em>) – [memmap=False] Array containing the frames of the fits-cube.</p></li>
<li><p><strong>header</strong> (<em>dict</em>) – [memmap=False, header=True] Dictionary containing the fits header.</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="special.fits.write_fits">
<span class="sig-prename descclassname"><span class="pre">special.fits.</span></span><span class="sig-name descname"><span class="pre">write_fits</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fitsfilename</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">array</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">header=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">output_verify='exception'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">precision=&lt;class</span> <span class="pre">'numpy.float32'&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose=True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/special/fits.html#write_fits"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#special.fits.write_fits" title="Permalink to this definition"></a></dt>
<dd><p>Write array and header into FTIS file.</p>
<p>If there is a previous file with the same filename then it’s replaced.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>fitsfilename</strong> (<em>string</em>) – Full path of the fits file to be written.</p></li>
<li><p><strong>array</strong> (<em>numpy ndarray</em>) – Array to be written into a fits file.</p></li>
<li><p><strong>header</strong> (<em>numpy ndarray</em><em>, </em><em>optional</em>) – Array with header.</p></li>
<li><p><strong>output_verify</strong> (<em>str</em><em>, </em><em>optional</em>) – {“fix”, “silentfix”, “ignore”, “warn”, “exception”}
Verification options:
<a class="reference external" href="https://docs.astropy.org/en/stable/io/fits/api/verification.html">https://docs.astropy.org/en/stable/io/fits/api/verification.html</a></p></li>
<li><p><strong>precision</strong> (<em>numpy dtype</em><em>, </em><em>optional</em>) – Float precision, by default np.float32 or single precision float.</p></li>
<li><p><strong>verbose</strong> (<em>bool</em><em>, </em><em>optional</em>) – If True prints message.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-special.mcmc_sampling">
<span id="special-mcmc-sampling"></span><h1>special.mcmc_sampling<a class="headerlink" href="#module-special.mcmc_sampling" title="Permalink to this headline"></a></h1>
<p>Module with the MCMC (<code class="docutils literal notranslate"><span class="pre">emcee</span></code>) sampling for model spectra parameter
estimation.</p>
<dl class="py function">
<dt class="sig sig-object py" id="special.mcmc_sampling.chain_zero_truncated">
<span class="sig-prename descclassname"><span class="pre">special.mcmc_sampling.</span></span><span class="sig-name descname"><span class="pre">chain_zero_truncated</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">chain</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ln_proba</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ar</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/special/mcmc_sampling.html#chain_zero_truncated"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#special.mcmc_sampling.chain_zero_truncated" title="Permalink to this definition"></a></dt>
<dd><p>Return the Markov chain with the dimension: walkers x steps* x parameters,
where steps* is the last step before having 0 (not yet constructed chain).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>chain</strong> (<em>numpy.array</em>) – The MCMC chain.</p></li>
<li><p><strong>ln_proba</strong> (<em>numpy.array</em><em>, </em><em>opt</em>) – Corresponding ln-probabilities.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>out</strong> (<em>numpy.array</em>) – The truncated MCMC chain, that is to say, the chain which only contains
relevant information.</p></li>
<li><p><strong>out_ln_proba</strong> (<em>numpy.array</em>) – If ln_proba is provided as input, out_ln_proba contains the
zero-truncated ln-proba (i.e. matching shape with non-zero samples)</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="special.mcmc_sampling.confidence">
<span class="sig-prename descclassname"><span class="pre">special.mcmc_sampling.</span></span><span class="sig-name descname"><span class="pre">confidence</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">isamples</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">labels</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cfd</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">68.27</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bins</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gaussian_fit</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weights</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">save</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">output_dir</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">''</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bounds</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">priors</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/special/mcmc_sampling.html#confidence"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#special.mcmc_sampling.confidence" title="Permalink to this definition"></a></dt>
<dd><p>Determine the highly probable value for each model parameter, as well as
the 1-sigma confidence interval.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>isamples</strong> (<em>numpy.array</em>) – The independent samples for each model parameter.</p></li>
<li><p><strong>labels</strong> (<em>Tuple of strings</em>) – Tuple of labels in the same order as initial_state, that is:
- first all parameters related to loaded models (e.g. ‘Teff’, ‘logg’)
- next the planet photometric radius ‘R’,
- (optionally) the optical extinction ‘Av’.
- (optionally) ‘Tbb1’, ‘Rbb1’, ‘Tbb2’, ‘Rbb2’, etc. for each extra bb         contribution</p></li>
<li><p><strong>cfd</strong> (<em>float</em><em>, </em><em>optional</em>) – The confidence level given in percentage.</p></li>
<li><p><strong>bins</strong> (<em>int</em><em>, </em><em>optional</em>) – The number of bins used to sample the posterior distributions.</p></li>
<li><p><strong>gaussian_fit</strong> (<em>boolean</em><em>, </em><em>optional</em>) – If True, a gaussian fit is performed in order to determine (mu,sigma)</p></li>
<li><p><strong>weights</strong> (<em>(</em><em>n</em><em>, </em><em>) </em><em>numpy ndarray</em><em> or </em><em>None</em><em>, </em><em>optional</em>) – An array of weights for each sample.</p></li>
<li><p><strong>verbose</strong> (<em>boolean</em><em>, </em><em>optional</em>) – Display information in the shell.</p></li>
<li><p><strong>save</strong> (<em>boolean</em><em>, </em><em>optional</em>) – If “True”, a txt file with the results is saved in the output
repository.</p></li>
<li><p><strong>bounds</strong> (<em>dictionary</em><em>, </em><em>opt</em>) – Only used if a text file is saved summarizing results+bounds+priors.
Should be the same bounds as provided to the MCMC.</p></li>
<li><p><strong>priors</strong> (<em>dictionary</em><em>, </em><em>opt</em>) – Only used if a text file is saved summarizing results+bounds+priors.
Should be the same priors as provided to the MCMC.</p></li>
<li><p><strong>kwargs</strong> (<em>optional</em>) – Additional attributes are passed to the matplotlib hist() method.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>out</strong> – A 2 elements tuple with the highly probable solution and the confidence
interval.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>tuple</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="special.mcmc_sampling.lnlike">
<span class="sig-prename descclassname"><span class="pre">special.mcmc_sampling.</span></span><span class="sig-name descname"><span class="pre">lnlike</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">params</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">labels</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">grid_param_list</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lbda_obs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">spec_obs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">err_obs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dist</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">model_grid</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">model_reader</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">em_lines</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">{}</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">em_grid</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">{}</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dlbda_obs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">instru_corr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">instru_fwhm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">instru_idx</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">filter_reader</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">AV_bef_bb</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">units_obs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'si'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">units_mod</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'si'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">interp_order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/special/mcmc_sampling.html#lnlike"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#special.mcmc_sampling.lnlike" title="Permalink to this definition"></a></dt>
<dd><p>Define the likelihood log-function.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>params</strong> (<em>tuple</em>) – Set of models parameters for which the model grid has to be
interpolated.</p></li>
<li><p><strong>labels</strong> (<em>Tuple of strings</em>) – Tuple of labels in the same order as initial_state, that is:
- first all parameters related to loaded models (e.g. ‘Teff’, ‘logg’)
- then the planet photometric radius ‘R’, in Jupiter radius
- (optionally) the flux of emission lines (labels should match those         in the em_lines dictionary), in units of the model spectrum (times mu)
- (optionally) the optical extinction ‘Av’, in mag
- (optionally) the ratio of total to selective optical extinction ‘Rv’
- (optionally) ‘Tbb1’, ‘Rbb1’, ‘Tbb2’, ‘Rbb2’, etc. for each extra bb         contribution.</p></li>
<li><p><strong>grid_param_list</strong> (<em>list of 1d numpy arrays/lists OR None</em>) – <ul>
<li><p>If list, should contain list/numpy 1d arrays with available grid of</p></li>
</ul>
<p>model parameters.
- Set to None for a pure n-blackbody fit, n=1,2,…
- Note1: model grids should not contain grids on radius and Av, but
these should still be passed in initial_state (Av optional).
- Note2: for a combined grid model + black body, just provide
the grid parameter list here, and provide values for ‘Tbbn’ and ‘Rbbn’
in initial_state, labels and bounds.</p>
</p></li>
<li><p><strong>lbda_obs</strong> (<em>numpy 1d ndarray</em><em> or </em><em>list</em>) – Wavelength of observed spectrum. If several instruments, should be
ordered per instrument, not necessarily as monotonically increasing
wavelength. Hereafter, n_ch = len(lbda_obs).</p></li>
<li><p><strong>spec_obs</strong> (<em>numpy 1d ndarray</em><em> or </em><em>list</em>) – Observed spectrum for each value of lbda_obs.</p></li>
<li><p><strong>err_obs</strong> (<em>numpy 1d/2d ndarray</em><em> or </em><em>list</em>) – Uncertainties on the observed spectrum. If 2d array, should be [2,n_ch]
where the first (resp. second) column corresponds to lower (upper)
uncertainty, and n_ch is the length of lbda_obs and spec_obs.</p></li>
<li><p><strong>dist</strong> (<em>float</em>) – Distance in parsec, used for flux scaling of the models.</p></li>
<li><p><strong>model_grid</strong> (<em>numpy N-d array</em><em>, </em><em>optional</em>) – If provided, should contain the grid of model spectra for each
free parameter of the given grid. I.e. for a grid of n_T values of Teff
and n_g values of Logg, the numpy array should be n_T x n_g x n_ch x 2,
where n_ch is the number of wavelengths for the observed spectrum,
and the last 2 dims are for wavelength and fluxes respectively.
If provided, takes precedence over model_name/model_reader.</p></li>
<li><p><strong>model_reader</strong> (<em>python routine</em><em>, </em><em>opt</em>) – External routine that reads a model file and returns a 2D numpy array,
where the first column corresponds to wavelengths, and the second
contains model values. See example routine in model_interpolation()
description.</p></li>
<li><p><strong>em_lines</strong> (<em>dictionary</em><em>, </em><em>opt</em>) – <p>Dictionary of emission lines to be added on top of the model spectrum.
Each dict entry should be the name of the line, assigned to a tuple of
4 values:
1) the wavelength (in mu);
2) a string indicating whether line intensity is expressed in flux
(‘F’), luminosity (‘L’) or log(L/LSun) (“LogL”);
3) the FWHM of the gaussian (or None if to be set automatically);
4) whether the FWHM is expressed in ‘nm’, ‘mu’ or ‘km/s’.</p>
<p>The third and fourth can also be set to None. In that case, the FWHM of
the gaussian will automatically be set to the equivalent width of the
line, calculated from the flux to be injected and the continuum
level (measured in the grid model to which the line is injected).
Examples:
- em_lines = {‘BrG’:(2.1667,’F’,None, None)};
- em_lines = {‘BrG’:(2.1667,’LogL’, 100, ‘km/s’)}</p>
</p></li>
<li><p><strong>em_grid</strong> (<em>dictionary pointing to lists</em><em>, </em><em>opt</em>) – Dictionary where each entry corresponds to an emission line and points
to a list of values to inject for emission line fluxes. For computation
efficiency, interpolation will be performed between the points of this
grid during the MCMC sampling. Dict entries should match labels and
em_lines.</p></li>
<li><p><strong>dlbda_obs</strong> (<em>numpy 1d ndarray</em><em> or </em><em>list</em><em>, </em><em>optional</em>) – Spectral channel width for the observed spectrum. It should be provided
IF one wants to weigh each point based on the spectral resolution of
the respective instruments (as in Olofsson et al. 2016).</p></li>
<li><p><strong>instru_corr</strong> (<em>numpy 2d ndarray</em><em> or </em><em>list</em><em>, </em><em>optional</em>) – Spectral correlation throughout post-processed images in which the
spectrum is measured. It is specific to the combination of instrument,
algorithm and radial separation of the companion from the central star.
Can be computed using distances.spectral_correlation(). In case of
a spectrum obtained with different instruments, build it with
distances.combine_corrs(). If not provided, it will consider the
uncertainties in each spectral channels are independent. See Greco &amp;
Brandt (2017) for details.</p></li>
<li><p><strong>instru_fwhm</strong> (<em>float</em><em> or </em><em>list</em><em>, </em><em>optional</em>) – The instrumental spectral fwhm provided in nm. This is used to convolve
the model spectrum. If several instruments are used, provide a list of
instru_fwhm values, one for each instrument whose spectral resolution
is coarser than the model - including broad band
filter FWHM if relevant.</p></li>
<li><p><strong>instru_idx</strong> (<em>numpy 1d array</em><em>, </em><em>optional</em>) – 1d array containing an index representing each instrument used
to obtain the spectrum, label them from 0 to n_instru. Zero for points
that don’t correspond to any instru_fwhm provided above, and i in
[1,n_instru] for points associated to instru_fwhm[i-1]. This parameter
must be provided if the spectrum consists of points obtained with
different instruments.</p></li>
<li><p><strong>filter_reader</strong> (<em>python routine</em><em>, </em><em>optional</em>) – External routine that reads a filter file and returns a 2D numpy array,
where the first column corresponds to wavelengths, and the second
contains transmission values. Important: if not provided, but strings
are detected in instru_fwhm, the default format assumed for the files:
- first row containing header
- starting from 2nd row: 1st column: WL in mu, 2nd column: transmission
Note: files should all have the same format and wavelength units.</p></li>
<li><p><strong>AV_bef_bb</strong> (<em>bool</em><em>, </em><em>optional</em>) – If both extinction and an extra bb component are free parameters,
whether to apply extinction before adding the BB component (e.g.
extinction mostly from circumplanetary dust) or after the BB component
(e.g. mostly insterstellar extinction).</p></li>
<li><p><strong>units_obs</strong> (<em>str</em><em>, </em><em>opt {'si'</em><em>,</em><em>'cgs'</em><em>,</em><em>'jy'}</em>) – Units of observed spectrum. ‘si’ for W/m^2/mu; ‘cgs’ for ergs/s/cm^2/mu
or ‘jy’ for janskys.</p></li>
<li><p><strong>units_mod</strong> (<em>str</em><em>, </em><em>opt {'si'</em><em>,</em><em>'cgs'</em><em>,</em><em>'jy'}</em>) – Units of the model. ‘si’ for W/m^2/mu; ‘cgs’ for ergs/s/cm^2/mu or ‘jy’
for janskys. If different to units_obs, the spectrum units will be
converted.</p></li>
<li><p><strong>interp_order</strong> (<em>int</em><em>, </em><em>opt</em><em>, </em><em>{-1</em><em>,</em><em>0</em><em>,</em><em>1}</em>) – Interpolation mode for model interpolation.
-1: log interpolation (i.e. linear interpolatlion on log(Flux))
0: nearest neighbour model.
1: Order 1 spline interpolation.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>out</strong> – The log of the likelihood.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="special.mcmc_sampling.lnprob">
<span class="sig-prename descclassname"><span class="pre">special.mcmc_sampling.</span></span><span class="sig-name descname"><span class="pre">lnprob</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">params</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">labels</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bounds</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">grid_param_list</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lbda_obs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">spec_obs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">err_obs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dist</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">model_grid</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">model_reader</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">em_lines</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">{}</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">em_grid</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">{}</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dlbda_obs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">instru_corr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">instru_fwhm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">instru_idx</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">filter_reader</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">AV_bef_bb</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">units_obs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'si'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">units_mod</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'si'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">interp_order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">priors</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">physical</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/special/mcmc_sampling.html#lnprob"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#special.mcmc_sampling.lnprob" title="Permalink to this definition"></a></dt>
<dd><p>Define the probability log-function as the sum between the prior and
likelihood log-functions.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>params</strong> (<em>tuple</em>) – The model parameters.</p></li>
<li><p><strong>labels</strong> (<em>Tuple of strings</em>) – Tuple of labels in the same order as initial_state, that is:
- first all parameters related to loaded models (e.g. ‘Teff’, ‘logg’)
- then the planet photometric radius ‘R’, in Jupiter radius
- (optionally) the flux of emission lines (labels should match those         in the em_lines dictionary), in units of the model spectrum (times mu)
- (optionally) the optical extinction ‘Av’, in mag
- (optionally) the ratio of total to selective optical extinction ‘Rv’
- (optionally) ‘Tbb1’, ‘Rbb1’, ‘Tbb2’, ‘Rbb2’, etc. for each extra bb         contribution.</p></li>
<li><p><strong>bounds</strong> (<em>dictionary</em>) – Each entry should be associated with a tuple corresponding to lower and
upper bounds respectively. Bounds should be provided for ALL model
parameters, including ‘R’ (planet photometric radius). ‘Av’ (optical
extinction) is optional. If provided here, Av will also be fitted.
All keywords that are neither ‘R’, ‘Av’ nor ‘M’ will
be considered model grid parameters.
Example for BT-SETTL: bounds = {‘Teff’:(1000,2000), ‘logg’:(3.0,4.5),
‘R’:(0.1,5), ‘Av’:(0.,2.5)}
‘M’ can be used for a prior on the mass of the planet. In that case the
corresponding prior log probability is computed from the values for
parameters ‘logg’ and ‘R’.</p></li>
<li><p><strong>grid_param_list</strong> (<em>list of 1d numpy arrays/lists OR None</em>) – <ul>
<li><p>If list, should contain list/numpy 1d arrays with available grid of         model parameters.</p></li>
<li><p>Set to None for a pure n-blackbody fit, n=1,2,…</p></li>
<li><p>Note1: model grids should not contain grids on radius and Av, but         these should still be passed in initial_state (Av optional).</p></li>
<li><p>Note2: for a combined grid model + black body, just provide         the grid parameter list here, and provide values for ‘Tbbn’ and ‘Rbbn’         in initial_state, labels and bounds.</p></li>
</ul>
</p></li>
<li><p><strong>lbda_obs</strong> (<em>numpy 1d ndarray</em><em> or </em><em>list</em>) – Wavelength of observed spectrum. If several instruments, should be
ordered per instrument, not necessarily as monotonically increasing
wavelength. Hereafter, n_ch = len(lbda_obs).</p></li>
<li><p><strong>spec_obs</strong> (<em>numpy 1d ndarray</em><em> or </em><em>list</em>) – Observed spectrum for each value of lbda_obs.</p></li>
<li><p><strong>err_obs</strong> (<em>numpy 1d/2d ndarray</em><em> or </em><em>list</em>) – Uncertainties on the observed spectrum. If 2d array, should be [2,n_ch]
where the first (resp. second) column corresponds to lower (upper)
uncertainty, and n_ch is the length of lbda_obs and spec_obs.</p></li>
<li><p><strong>dist</strong> (<em>float</em>) – Distance in parsec, used for flux scaling of the models.</p></li>
<li><p><strong>model_grid</strong> (<em>numpy N-d array</em><em>, </em><em>optional</em>) – If provided, should contain the grid of model spectra for each
free parameter of the given grid. I.e. for a grid of n_T values of Teff
and n_g values of Logg, the numpy array should be n_T x n_g x n_ch x 2,
where n_ch is the number of wavelengths for the observed spectrum,
and the last 2 dims are for wavelength and fluxes respectively.
If provided, takes precedence over model_name/model_reader.</p></li>
<li><p><strong>model_reader</strong> (<em>python routine</em>) – External routine that reads a model file and returns a 2D numpy array,
where the first column corresponds to wavelengths, and the second
contains model values. See example routine in model_interpolation()
description.</p></li>
<li><p><strong>em_lines</strong> (<em>dictionary</em><em>, </em><em>opt</em>) – Dictionary of emission lines to be added on top of the model spectrum.
Each dict entry should be the name of the line, assigned to a tuple of
4 values:
1) the wavelength (in mu);
2) a string indicating whether line intensity is expressed in flux
(‘F’), luminosity (‘L’) or log(L/LSun) (“LogL”);
3) the FWHM of the gaussian (or None if to be set automatically);
4) whether the FWHM is expressed in ‘nm’, ‘mu’ or ‘km/s’.
The third and fourth can also be set to None. In that case, the FWHM of
the gaussian will automatically be set to the equivalent width of the
line, calculated from the flux to be injected and the continuum
level (measured in the grid model to which the line is injected).
Examples:
em_lines = {‘BrG’:(2.1667,’F’,None, None)};
em_lines = {‘BrG’:(2.1667,’LogL’, 100, ‘km/s’)}</p></li>
<li><p><strong>em_grid</strong> (<em>dictionary pointing to lists</em><em>, </em><em>opt</em>) – Dictionary where each entry corresponds to an emission line and points
to a list of values to inject for emission line fluxes. For computation
efficiency, interpolation will be performed between the points of this
grid during the MCMC sampling. Dict entries should match labels and
em_lines.</p></li>
<li><p><strong>dlbda_obs</strong> (<em>numpy 1d ndarray</em><em> or </em><em>list</em><em>, </em><em>optional</em>) – Spectral channel width for the observed spectrum. It should be provided
IF one wants to weigh each point based on the spectral
resolution of the respective instruments (as in Olofsson et al. 2016).</p></li>
<li><p><strong>instru_corr</strong> (<em>numpy 2d ndarray</em><em> or </em><em>list</em><em>, </em><em>optional</em>) – Spectral correlation throughout post-processed images in which the
spectrum is measured. It is specific to the combination of instrument,
algorithm and radial separation of the companion from the central star.
Can be computed using distances.spectral_correlation(). In case of
a spectrum obtained with different instruments, build it with
distances.combine_corrs(). If not provided, it will consider the
uncertainties in each spectral channels are independent. See Greco &amp;
Brandt (2017) for details.</p></li>
<li><p><strong>instru_fwhm</strong> (<em>float</em><em> or </em><em>list</em><em>, </em><em>optional</em>) – The instrumental spectral fwhm provided in nm. This is used to convolve
the model spectrum. If several instruments are used, provide a list of
instru_fwhm values, one for each instrument whose spectral resolution
is coarser than the model - including broad band
filter FWHM if relevant.</p></li>
<li><p><strong>instru_idx</strong> (<em>numpy 1d array</em><em>, </em><em>optional</em>) – 1d array containing an index representing each instrument used
to obtain the spectrum, label them from 0 to n_instru. Zero for points
that don’t correspond to any instru_fwhm provided above, and i in
[1,n_instru] for points associated to instru_fwhm[i-1]. This parameter
must be provided if the spectrum consists of points obtained with
different instruments.</p></li>
<li><p><strong>filter_reader</strong> (<em>python routine</em><em>, </em><em>optional</em>) – External routine that reads a filter file and returns a 2D numpy array,
where the first column corresponds to wavelengths, and the second
contains transmission values. Important: if not provided, but strings
are detected in instru_fwhm, the default format assumed for the files:
- first row containing header
- starting from 2nd row: 1st column: WL in mu, 2nd column: transmission
Note: files should all have the same format and wavelength units.</p></li>
<li><p><strong>AV_bef_bb</strong> (<em>bool</em><em>, </em><em>optional</em>) – If both extinction and an extra bb component are free parameters,
whether to apply extinction before adding the BB component (e.g.
extinction mostly from circumplanetary dust) or after the BB component
(e.g. mostly insterstellar extinction).</p></li>
<li><p><strong>units_obs</strong> (<em>str</em><em>, </em><em>opt {'si'</em><em>,</em><em>'cgs'</em><em>,</em><em>'jy'}</em>) – Units of observed spectrum. ‘si’ for W/m^2/mu; ‘cgs’ for ergs/s/cm^2/mu
or ‘jy’ for janskys.</p></li>
<li><p><strong>units_mod</strong> (<em>str</em><em>, </em><em>opt {'si'</em><em>,</em><em>'cgs'</em><em>,</em><em>'jy'}</em>) – Units of the model. ‘si’ for W/m^2/mu; ‘cgs’ for ergs/s/cm^2/mu or ‘jy’
for janskys. If different to units_obs, the spectrum units will be
converted.</p></li>
<li><p><strong>interp_order</strong> (<em>int</em><em>, </em><em>opt</em><em>, </em><em>{-1</em><em>,</em><em>0</em><em>,</em><em>1}</em>) – Interpolation mode for model interpolation.
-1: log interpolation (i.e. linear interpolatlion on log(Flux))
0: nearest neighbour model.
1: Order 1 spline interpolation.</p></li>
<li><p><strong>priors</strong> (<em>dictionary</em><em>, </em><em>opt</em>) – <p>If not None, sets prior estimates for each parameter of the model. Each
entry should be set to either None (no prior) or a tuple of 2 elements
containing prior estimate and uncertainty on the estimate.
Missing entries (i.e. provided in bounds dictionary but not here) will
be associated no prior.
e.g. priors = {‘Teff’:(1600,100), ‘logg’:(3.5,0.5), ‘R’:(1.6,0.1),
‘Av’:(1.8,0.2), ‘M’:(10,3)}</p>
<p>Important: dictionary entry names should match exactly those of bounds.</p>
</p></li>
<li><p><strong>physical</strong> (<em>bool</em><em>, </em><em>opt</em>) – In case of extra black body component(s) to a photosphere, whether to
force lower temperature than the photosphere effective temperature.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>out</strong> – The probability log-function.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="special.mcmc_sampling.mcmc_spec_sampling">
<span class="sig-prename descclassname"><span class="pre">special.mcmc_sampling.</span></span><span class="sig-name descname"><span class="pre">mcmc_spec_sampling</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">lbda_obs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">spec_obs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">err_obs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dist</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">grid_param_list</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">initial_state</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">labels</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bounds</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">resamp_before</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">model_grid</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">model_reader</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">em_lines</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">{}</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">em_grid</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">{}</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dlbda_obs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">instru_corr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">instru_fwhm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">instru_idx</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">filter_reader</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">AV_bef_bb</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">units_obs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'si'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">units_mod</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'si'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">interp_order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">priors</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">physical</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">interp_nonexist</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ini_ball</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">a</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nwalkers</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1000</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">niteration_min</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">niteration_limit</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1000</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">niteration_supp</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">check_maxgap</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">20</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">conv_test</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'ac'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ac_c</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">50</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ac_count_thr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">3</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">burnin</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.3</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rhat_threshold</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.01</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rhat_count_threshold</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">grid_name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'resamp_grid.fits'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">output_dir</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'special/'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">output_file</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nproc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">display</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbosity</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">save</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/special/mcmc_sampling.html#mcmc_spec_sampling"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#special.mcmc_sampling.mcmc_spec_sampling" title="Permalink to this definition"></a></dt>
<dd><p>Runs an affine invariant MCMC sampling algorithm in order to determine
the most likely parameters for given spectral model and observed spectrum.
Allowed features:
* Spectral models can either be read from a grid (e.g. BT-SETTL) or     be purely parametric (e.g. a blackbody model).
* Extinction (A_V) and total-to-selective optical extinction ratio     (R_V) can be sampled. Default: A_V=0. If non-zero, default R_V=3.1 (ISM).
* A dictionary of emission lines can be provided and their flux can     be sampled too.
* Gaussian priors can be provided for each parameter, including the     mass of the object. The latter will be used if ‘logg’ is a parameter.
* Spectral correlation between measurements will be taken into account if provided in ‘instru_corr’.
* Convolution of the model spectra with instrumental FWHM or     photometric filter can be performed using ‘instru_fwhm’ and/or     ‘filter_reader’ (done before resampling to observed).
* The weight of each observed point will be directly proportional to     Delta lbda_i/lbda_i, where Delta lbda_i is either the FWHM of the     photometric filter (imager) or the width of the spectral channel (IFS).
* MCMC convergence criterion can either be based on auto-correlation     time (default) or the Gelman-Rubin test.</p>
<p>The result of this procedure is a chain with the samples from the posterior
distributions of each of the free parameters in the model.
More details in Christiaens et al. (2021).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>lbda_obs</strong> (<em>numpy 1d ndarray</em><em> or </em><em>list</em>) – Wavelength of observed spectrum. If several instruments, should be
ordered per instrument, not necessarily as monotonically increasing
wavelength. Hereafter, n_ch = len(lbda_obs).</p></li>
<li><p><strong>spec_obs</strong> (<em>numpy 1d ndarray</em><em> or </em><em>list</em>) – Observed spectrum for each value of lbda_obs.</p></li>
<li><p><strong>err_obs</strong> (<em>numpy 1d/2d ndarray</em><em> or </em><em>list</em>) – Uncertainties on the observed spectrum. If 2d array, should be [2,n_ch]
where the first (resp. second) column corresponds to lower (upper)
uncertainty, and n_ch is the length of lbda_obs and spec_obs.</p></li>
<li><p><strong>dist</strong> (<em>float</em>) – Distance in parsec, used for flux scaling of the models.</p></li>
<li><p><strong>grid_param_list</strong> (<em>list of 1d numpy arrays/lists OR None</em>) – <ul>
<li><p>If list, should contain list/numpy 1d arrays with available grid of         model parameters.</p></li>
<li><p>Set to None for a pure n-blackbody fit, n=1,2,…</p></li>
<li><p>Note1: model grids should not contain grids on radius and Av, but         these should still be passed in initial_state (Av optional).</p></li>
<li><p>Note2: for a combined grid model + black body, just provide         the grid parameter list here, and provide values for ‘Tbbn’ and ‘Rbbn’         in initial_state, labels and bounds.</p></li>
</ul>
</p></li>
<li><p><strong>initial_state</strong> (<em>tuple of floats</em>) – Initial guess on the best fit parameters of the spectral fit. Length of
the tuple should match the total number of free parameters. Walkers
will all be initialised in a small ball of parameter space around that
first guess.
- first all parameters related to loaded models (e.g. ‘Teff’, ‘logg’)
- then the planet photometric radius ‘R’, in Jupiter radius
- (optionally) the intensity of emission lines (labels must match         those in the em_lines dict), in units of the model spectrum (x mu)
- (optionally) the optical extinction ‘Av’, in mag
- (optionally) the ratio of total to selective optical extinction ‘Rv’
- (optionally) ‘Tbb1’, ‘Rbb1’, ‘Tbb2’, ‘Rbb2’, etc. for each extra bb         contribution</p></li>
<li><p><strong>labels</strong> (<em>Tuple of strings</em>) – Tuple of labels in the same order as initial_state, that is:
- first all parameters related to loaded models (e.g. ‘Teff’, ‘logg’)
- then the planet photometric radius ‘R’, in Jupiter radius
- (optionally) the flux of emission lines (labels should match those         in the em_lines dictionary), in units of the model spectrum (times mu)
- (optionally) the optical extinction ‘Av’, in mag
- (optionally) the ratio of total to selective optical extinction ‘Rv’
- (optionally) ‘Tbb1’, ‘Rbb1’, ‘Tbb2’, ‘Rbb2’, etc. for each extra bb         contribution.</p></li>
<li><p><strong>bounds</strong> (<em>dictionary</em>) – Each entry should be associated with a tuple corresponding to lower and
upper bounds respectively. Bounds should be provided for ALL model
parameters, including ‘R’ (planet photometric radius). ‘Av’ (optical
extinction) is optional. If provided here, Av will also be fitted.
Example for BT-SETTL: bounds = {‘Teff’:(1000,2000), ‘logg’:(3.0,4.5),
‘R’:(0.1,5), ‘Av’:(0.,2.5)}
‘M’ can be used for a prior on the mass of the planet. In that case the
corresponding prior log probability is computed from the values for
parameters ‘logg’ and ‘R’ (if both exist).</p></li>
<li><p><strong>resamp_before</strong> (<em>bool</em><em>, </em><em>optional</em>) – Whether to prepare the whole grid of resampled models before entering
the MCMC, i.e. to avoid doing it at every MCMC step. Recommended.
Only reason not to: model grid is too large and individual models
require being opened and resampled at each step.</p></li>
<li><p><strong>model_grid</strong> (<em>numpy N-d array</em><em>, </em><em>optional</em>) – If provided, should contain the grid of model spectra for each
free parameter of the given grid. I.e. for a grid of n_T values of Teff
and n_g values of Logg, the numpy array should be n_T x n_g x n_ch x 2,
where n_ch is the number of wavelengths for the observed spectrum,
and the last 2 dims are for wavelength and fluxes respectively.
If provided, takes precedence over filename/file_reader.</p></li>
<li><p><strong>model_reader</strong> (<em>python routine</em><em>, </em><em>optional</em>) – External routine that reads a model file and returns a 2D numpy array,
where the first column corresponds to wavelengths, and the second
contains model values. See example routine in model_interpolation()
description.</p></li>
<li><p><strong>em_lines</strong> (<em>dictionary</em><em>, </em><em>opt</em>) – Dictionary of emission lines to be added on top of the model spectrum.
Each dict entry should be the name of the line, assigned to a tuple of
4 values:
1) the wavelength (in mu);
2) a string indicating whether line intensity is expressed in flux
(‘F’), luminosity (‘L’) or log(L/LSun) (“LogL”);
3) the FWHM of the gaussian (or None if to be set automatically);
4) whether the FWHM is expressed in ‘nm’, ‘mu’ or ‘km/s’.
The third and fourth can also be set to None. In that case, the FWHM of
the gaussian will automatically be set to the equivalent width of the
line, calculated from the flux to be injected and the continuum
level (measured in the grid model to which the line is injected).
Examples:
em_lines = {‘BrG’:(2.1667,’F’, None, None)};
em_lines = {‘BrG’:(2.1667,’LogL’, 100, ‘km/s’)}</p></li>
<li><p><strong>em_grid</strong> (<em>dictionary pointing to lists</em><em>, </em><em>opt</em>) – Dictionary where each entry corresponds to an emission line and points
to a list of values to inject for emission line fluxes. For computation
efficiency, interpolation will be performed between the points of this
grid during the MCMC sampling. Dict entries should match labels and
em_lines.</p></li>
<li><p><strong>dlbda_obs</strong> (<em>numpy 1d ndarray</em><em> or </em><em>list</em><em>, </em><em>optional</em>) – Spectral channel width for the observed spectrum. It should be provided
IF one wants to weigh each point based on the spectral
resolution of the respective instruments (as in Olofsson et al. 2016).</p></li>
<li><p><strong>instru_corr</strong> (<em>numpy 2d ndarray</em><em> or </em><em>list</em><em>, </em><em>optional</em>) – Spectral correlation throughout post-processed images in which the
spectrum is measured. It is specific to the combination of instrument,
algorithm and radial separation of the companion from the central star.
Can be computed using <cite>spec_corr.spectral_correlation()</cite>. In case of
a spectrum obtained with different instruments, build it with
<cite>spec_corr.combine_corrs()</cite>. If not provided, it will consider the
uncertainties in each spectral channels are independent. See Greco &amp;
Brandt (2017) for details.</p></li>
<li><p><strong>instru_fwhm</strong> (<em>float OR list of either floats</em><em> or </em><em>strings</em><em>, </em><em>optional</em>) – The instrumental spectral fwhm provided in nm. This is used to convolve
the model spectrum. If several instruments are used, provide a list of
instru_fwhm values, one for each instrument whose spectral resolution
is coarser than the model - including broad band filter FWHM if
relevant.
If strings are provided, they should correspond to filenames (including
full paths) of text files containing the filter information for each
observed wavelength. Strict format:</p></li>
<li><p><strong>instru_idx</strong> (<em>numpy 1d array</em><em>, </em><em>optional</em>) – 1d array containing an index representing each instrument used
to obtain the spectrum, label them from 0 to n_instru. Zero for points
that don’t correspond to any instru_fwhm provided above, and i in
[1,n_instru] for points associated to instru_fwhm[i-1]. This parameter
must be provided if the spectrum consists of points obtained with
different instruments.</p></li>
<li><p><strong>filter_reader</strong> (<em>python routine</em><em>, </em><em>optional</em>) – <p>External routine that reads a filter file and returns a 2D numpy array,
where the first column corresponds to wavelengths, and the second
contains transmission values. Important: if not provided, but strings
are detected in instru_fwhm, the default file reader will be used.
It assumes the following format for the files:
- first row containing header
- starting from 2nd row: 1st column: wavelength, 2nd col.: transmission
- Unit of wavelength can be provided in parentheses of first header         key name: e.g. “WL(AA)” for angstrom, “wavelength(mu)” for micrometer         or “lambda(nm)” for nanometer. Note: Only what is in parentheses         matters.</p>
<p>Important: filter files should all have the same format and WL units.</p>
</p></li>
<li><p><strong>AV_bef_bb</strong> (<em>bool</em><em>, </em><em>optional</em>) – If both extinction and an extra bb component are free parameters,
whether to apply extinction before adding the BB component (e.g.
extinction mostly from circumplanetary dust) or after the BB component
(e.g. mostly insterstellar extinction).</p></li>
<li><p><strong>units_obs</strong> (<em>str</em><em>, </em><em>opt {'si'</em><em>,</em><em>'cgs'</em><em>,</em><em>'jy'}</em>) – Units of observed spectrum. ‘si’ for W/m^2/mu; ‘cgs’ for ergs/s/cm^2/mu
or ‘jy’ for janskys.</p></li>
<li><p><strong>units_mod</strong> (<em>str</em><em>, </em><em>opt {'si'</em><em>,</em><em>'cgs'</em><em>,</em><em>'jy'}</em>) – Units of the model. ‘si’ for W/m^2/mu; ‘cgs’ for ergs/s/cm^2/mu or ‘jy’
for janskys. If different to units_obs, the spectrum units will be
converted.</p></li>
<li><p><strong>interp_order</strong> (<em>int</em><em>, </em><em>opt</em><em>, </em><em>{-1</em><em>,</em><em>0</em><em>,</em><em>1}</em>) – Interpolation mode for model interpolation.
-1: log interpolation (i.e. linear interpolatlion on log(Flux))
0: nearest neighbour model.
1: Order 1 spline interpolation.</p></li>
<li><p><strong>priors</strong> (<em>dictionary</em><em>, </em><em>opt</em>) – If not None, sets prior estimates for each parameter of the model. Each
entry should be set to either None (no prior) or a tuple of 2 elements
containing prior estimate and uncertainty on the estimate.
Missing entries (i.e. provided in bounds dictionary but not here) will
be associated no prior.
e.g. priors = {‘Teff’:(1600,100), ‘logg’:(3.5,0.5), ‘R’:(1.6,0.1),
‘Av’:(1.8,0.2), ‘M’:(10,3)}
Important: dictionary entry names should match exactly those of bounds.</p></li>
<li><p><strong>physical</strong> (<em>bool</em><em>, </em><em>opt</em>) – In case of extra black body component(s) to a photosphere, whether to
force lower temperature than the photosphere effective temperature.</p></li>
<li><p><strong>interp_nonexist</strong> (<em>bool</em><em>, </em><em>opt</em>) – Whether to interpolate non-existing models in the grid. Only used if
resamp_before is set to True.</p></li>
<li><p><strong>ini_ball</strong> (<em>float</em><em> or </em><em>string</em><em>, </em><em>default=1e-1</em>) – Size of the initial ball in parameter space from which walkers start
their chain. If “uniform” is provided, a uniform ini_ball spanning
the bounds interval will be used to initialise walkers.</p></li>
<li><p><strong>a</strong> (<em>float</em><em>, </em><em>default=2.0</em>) – The proposal scale parameter. See notes.</p></li>
<li><p><strong>nwalkers</strong> (<em>int</em><em>, </em><em>default: 1000</em>) – Number of walkers</p></li>
<li><p><strong>niteration_min</strong> (<em>int</em><em>, </em><em>optional</em>) – Steps per walker lower bound. The simulation will run at least this
number of steps per walker.</p></li>
<li><p><strong>niteration_limit</strong> (<em>int</em><em>, </em><em>optional</em>) – Steps per walker upper bound. If the simulation runs up to
‘niteration_limit’ steps without having reached the convergence
criterion, the run is stopped.</p></li>
<li><p><strong>niteration_supp</strong> (<em>int</em><em>, </em><em>optional</em>) – Number of iterations to run after having “reached the convergence”.</p></li>
<li><p><strong>burnin</strong> (<em>float</em><em>, </em><em>default=0.3</em>) – The fraction of a walker which is discarded.</p></li>
<li><p><strong>rhat_threshold</strong> (<em>float</em><em>, </em><em>default=0.01</em>) – The Gelman-Rubin threshold used for the test for nonconvergence.</p></li>
<li><p><strong>rhat_count_threshold</strong> (<em>int</em><em>, </em><em>optional</em>) – The Gelman-Rubin test must be satisfied ‘rhat_count_threshold’ times in
a row before claiming that the chain has converged.</p></li>
<li><p><strong>check_maxgap</strong> (<em>int</em><em>, </em><em>optional</em>) – Maximum number of steps per walker between two convergence tests.</p></li>
<li><p><strong>conv_test</strong> (<em>str</em><em>, </em><em>optional {'gb'</em><em>,</em><em>'autocorr'}</em>) – Method to check for convergence:
- ‘gb’ for gelman-rubin test         (<a class="reference external" href="http://digitalassets.lib.berkeley.edu/sdtr/ucb/text/305.pdf">http://digitalassets.lib.berkeley.edu/sdtr/ucb/text/305.pdf</a>)
- ‘autocorr’ for autocorrelation analysis         (<a class="reference external" href="https://emcee.readthedocs.io/en/stable/tutorials/autocorr/">https://emcee.readthedocs.io/en/stable/tutorials/autocorr/</a>)</p></li>
<li><p><strong>nproc</strong> (<em>int</em><em>, </em><em>optional</em>) – The number of processes to use for parallelization.</p></li>
<li><p><strong>grid_name</strong> (<em>str</em><em>, </em><em>optional</em>) – Name of the fits file containing the model grid (numpy array) AFTER
convolution+resampling as the observed spectrum given as input.
If provided, will read it if it exists (and resamp_before is set
to True), or make it and write it if it doesn’t.</p></li>
<li><p><strong>output_dir</strong> (<em>str</em><em>, </em><em>optional</em>) – The name of the output directory which contains the output files in the
case  <code class="docutils literal notranslate"><span class="pre">save</span></code> is True.</p></li>
<li><p><strong>output_file</strong> (<em>str</em><em>, </em><em>optional</em>) – The name of the output file which contains the MCMC results in the case
<code class="docutils literal notranslate"><span class="pre">save</span></code> is True.</p></li>
<li><p><strong>display</strong> (<em>bool</em><em>, </em><em>optional</em>) – If True, the walk plot is displayed at each evaluation of the Gelman-
Rubin test.</p></li>
<li><p><strong>verbosity</strong> (<em>0</em><em>, </em><em>1</em><em> or </em><em>2</em><em>, </em><em>optional</em>) – Verbosity level. 0 for no output and 2 for full information.</p></li>
<li><p><strong>save</strong> (<em>bool</em><em>, </em><em>optional</em>) – If True, the MCMC results are pickled.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>out</strong> (<em>numpy.array</em>) – The MCMC samples after truncation of zeros.</p></li>
<li><p><strong>lnprobability</strong> (<em>emcee sample object</em>) – The corresponding probabilities for each sample</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The parameter <cite>a</cite> must be &gt; 1. For more theoretical information concerning
this parameter, see Goodman &amp; Weare, 2010, Comm. App. Math. Comp. Sci.,
5, 65, Eq. [9] p70.</p>
<p>The parameter ‘rhat_threshold’ can be a numpy.array with individual
threshold value for each model parameter.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="special.mcmc_sampling.show_corner_plot">
<span class="sig-prename descclassname"><span class="pre">special.mcmc_sampling.</span></span><span class="sig-name descname"><span class="pre">show_corner_plot</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">chain</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">burnin</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">save</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">output_dir</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">''</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mcmc_res</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">units</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ndig</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">labels_plot</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">plot_name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'corner_plot.pdf'</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/special/mcmc_sampling.html#show_corner_plot"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#special.mcmc_sampling.show_corner_plot" title="Permalink to this definition"></a></dt>
<dd><p>Display/save a figure showing the corner plot (pdfs + correlation plots).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>chain</strong> (<em>numpy.array</em>) – The Markov chain. The shape of chain must be nwalkers x length x dim.
If a part of the chain is filled with zero values, the method will
discard these steps.</p></li>
<li><p><strong>burnin</strong> (<em>float</em><em>, </em><em>default: 0</em>) – The fraction of a walker we want to discard.</p></li>
<li><p><strong>save</strong> (<em>boolean</em><em>, </em><em>default: False</em>) – If True, a pdf file is created.</p></li>
<li><p><strong>output_dir</strong> (<em>str</em><em>, </em><em>optional</em>) – The name of the output directory which contains the output files in the
case  <code class="docutils literal notranslate"><span class="pre">save</span></code> is True.</p></li>
<li><p><strong>mcmc_res</strong> (<em>numpy array OR tuple of 2 dictionaries/np.array</em><em>, </em><em>opt</em>) – Values to be printed on top of each 1d posterior distribution
* if numpy array:         - npar x 3 dimensions (where npar is the number of parameters),         containing the most likely value of each parameter and the lower         and upper uncertainties at the desired quantiles, resp.
- npar x 2 dimensions: same as above but with a single value of          uncertainty. E.g. output of spec_confidence() for a gaussian fit
* if tuple of 2 dictionaries: output of spec_confidence without         gaussian fit
* if tuple of 2 np.array: output of spec_confidence() with gaussian fit</p></li>
<li><p><strong>units</strong> (<em>tuple</em><em>, </em><em>opt</em>) – Tuple of strings containing units for each parameter. If provided,
mcmc_res will be printed on top of each 1d posterior distribution along
with these units.</p></li>
<li><p><strong>ndig</strong> (<em>tuple</em><em>, </em><em>opt</em>) – Number of digits precision for each printed parameter</p></li>
<li><p><strong>labels_plot</strong> (<em>tuple</em><em>, </em><em>opt</em>) – Labels corresponding to parameter names, used for the plot. If None,
will use “labels” passed in kwargs.</p></li>
<li><p><strong>kwargs</strong> – Additional attributes passed to the corner.corner() method.
(e.g. ‘labels’, ‘labels_tit’, ‘labels_tit_unit’, ‘title_kwargs’)</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><em>Display the figure or create a pdf file named walk_plot.pdf in the working</em></p></li>
<li><p><em>directory.</em></p></li>
</ul>
</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>ImportError</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="special.mcmc_sampling.show_walk_plot">
<span class="sig-prename descclassname"><span class="pre">special.mcmc_sampling.</span></span><span class="sig-name descname"><span class="pre">show_walk_plot</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">chain</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">labels</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">save</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">output_dir</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">''</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ntrunc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/special/mcmc_sampling.html#show_walk_plot"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#special.mcmc_sampling.show_walk_plot" title="Permalink to this definition"></a></dt>
<dd><p>Display/save a figure showing the path of each walker during the MCMC run.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>chain</strong> (<em>numpy.array</em>) – The Markov chain. The shape of chain must be nwalkers x length x dim.
If a part of the chain is filled with zero values, the method will
discard these steps.</p></li>
<li><p><strong>labels</strong> (<em>Tuple of strings</em>) – Tuple of labels in the same order as initial_state, that is:
- first all parameters related to loaded models (e.g. ‘Teff’, ‘logg’)
- next the planet photometric radius ‘R’,
- (optionally) the optical extinction ‘Av’.
- (optionally) ‘Tbb1’, ‘Rbb1’, ‘Tbb2’, ‘Rbb2’, etc. for each extra bb
contribution</p></li>
<li><p><strong>save</strong> (<em>boolean</em><em>, </em><em>default: False</em>) – If True, a pdf file is created.</p></li>
<li><p><strong>output_dir</strong> (<em>str</em><em>, </em><em>optional</em>) – The name of the output directory which contains the output files in the
case  <code class="docutils literal notranslate"><span class="pre">save</span></code> is True.</p></li>
<li><p><strong>ntrunc</strong> (<em>int</em><em>, </em><em>opt</em>) – max number of walkers plotted. If too many walkers the plot will become
too voluminous and too crowded. Plot will be truncated to only ntrunc
first walkers</p></li>
<li><p><strong>kwargs</strong> – Additional attributes are passed to the matplotlib plot method.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><em>Display the figure or create a pdf file named walk_plot.pdf in the working</em></p></li>
<li><p><em>directory.</em></p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-special.model_resampling">
<span id="special-model-resampling"></span><h1>special.model_resampling<a class="headerlink" href="#module-special.model_resampling" title="Permalink to this headline"></a></h1>
<p>Functions useful for spectral fitting of companions, and model interpolation.</p>
<dl class="py function">
<dt class="sig sig-object py" id="special.model_resampling.interpolate_model">
<span class="sig-prename descclassname"><span class="pre">special.model_resampling.</span></span><span class="sig-name descname"><span class="pre">interpolate_model</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">params</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">grid_param_list</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">params_em</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">{}</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">em_grid</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">{}</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">em_lines</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">{}</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">labels</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">model_grid</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">model_reader</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">interp_order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_dlbda</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0002</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/special/model_resampling.html#interpolate_model"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#special.model_resampling.interpolate_model" title="Permalink to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>params</strong> (<em>tuple</em>) – Set of models parameters for which the model grid has to be
interpolated.</p></li>
<li><p><strong>grid_param_list</strong> (<em>list of 1d numpy arrays/lists</em>) – <ul>
<li><p>If list, should contain list/numpy 1d arrays with available grid of         model parameters.</p></li>
<li><p>Note1: model grids should not contain grids on radius and Av, but         these should still be passed in initial_state (Av optional).</p></li>
</ul>
</p></li>
<li><p><strong>params_em</strong> (<em>dictionary</em><em>, </em><em>opt</em>) – Set of emission line parameters (typically fluxes) for which the model
grid has to be interpolated.</p></li>
<li><p><strong>em_grid</strong> (<em>dictionary pointing to lists</em><em>, </em><em>opt</em>) – Dictionary where each entry corresponds to an emission line and points
to a list of values to inject for emission line fluxes. For computation
efficiency, interpolation will be performed between the points of this
grid during the MCMC sampling. Dict entries should match labels and
em_lines. Note: length of this dictionary can be different of em_lines;
i.e. if a line is in em_lines but not in em_grid, it will not be
considered an MCMC parameter.</p></li>
<li><p><strong>em_lines</strong> (<em>dictionary</em><em>, </em><em>opt</em>) – Dictionary of emission lines to be added on top of the model spectrum.
Each dict entry should be the name of the line, assigned to a tuple of
3 values: 1) the wavelength (in mu), 2) a string indicating whether line
intensity is expressed in flux (‘F’), luminosity (‘L’) or log(L/LSun)
(“LogL”), and 3) the latter quantity. The intensity of the emission
lines can be sampled by MCMC, in that case the last element of the
tuple can be set to None. If not to be sampled, a value for the
intensity should be provided (in the same system of units as the model
spectra, multiplied by mu). Example:
em_lines = {‘BrG’:(2.1667,’F’,263)}</p></li>
<li><p><strong>labels</strong> (<em>Tuple of strings</em>) – Tuple of labels in the same order as initial_state, that is:
* first all parameters related to loaded models (e.g. ‘Teff’, ‘logg’)
* next the planet photometric radius ‘R’, in Jupiter radius
* (optionally) the flux of emission lines (labels should match those         in the em_lines dictionary), in units of the model spectrum (times mu)
* (optionally) the optical extinction ‘Av’, in mag
* (optionally) the ratio of total to selective optical extinction ‘Rv’
* (optionally) ‘Tbb1’, ‘Rbb1’, ‘Tbb2’, ‘Rbb2’, etc. for each extra bb         contribution.
Note: only necessary if an emission list dictionary is provided.</p></li>
<li><p><strong>model_grid</strong> (<em>numpy N-d array</em>) – If provided, should contain the grid of model spectra for each
free parameter of the given grid. I.e. for a grid of n_T values of Teff
and n_g values of Logg, the numpy array should be n_T x n_g x n_ch x 2,
where n_ch is the number of wavelengths for the observed spectrum.
If provided, takes precedence over filename/file_reader which would
open and read models at each step of the MCMC.
Note: if provided, it should already probe any potential emission line.</p></li>
<li><p><strong>model_reader</strong> (<em>python routine</em>) – External routine that reads a model file, converts it to required
units and returns a 2D numpy array, where the first column corresponds
to wavelengths, and the second contains model values. Example below.</p></li>
<li><p><strong>interp_order</strong> (<em>int</em><em>, </em><em>opt</em><em>, </em><em>{0</em><em>,</em><em>1}</em>) – 0: nearest neighbour model.
1: Order 1 spline interpolation.</p></li>
<li><p><strong>max_dlbda</strong> (<em>float</em><em>, </em><em>opt</em>) – Maximum delta lbda in mu allowed if binning of lbda_model is necessary.
This is necessary for grids of models (e.g. BT-SETTL) where the wavelength
sampling is not the same depending on parameters (e.g. between 4000K
and 4100K models for BT-SETTL): resampling preserving original
resolution is too prohibitive computationally.</p></li>
<li><p><strong>verbose</strong> (<em>bool</em><em>, </em><em>optional</em>) – Whether to print more information during resampling.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul>
<li><p><strong>model</strong> (<em>2d numpy array</em>) – Interpolated model for input parameters. First column corresponds
to wavelengths, and the second contains model values.</p></li>
<li><p><em>Example file_reader</em></p></li>
<li><p><em>——————-</em></p></li>
<li><p><em>def _example_file_reader(params)</em> – ‘’’This is a minimal example for the file_reader routine to be provided
as argument to model_interpolation. The routine should only take as
inputs grid parameters, and returns as output: both the wavelengths and
model values as a 2D numpy array.
This example assumes the model is in a fits file, that is already a 2D
numpy array, where the first column is the wavelength, and 2nd column
is the corresponding model values.’’’</p>
<p>model = open_fits(filename.format(params[0],params[1]))</p>
<p>return model</p>
</li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="special.model_resampling.make_model_from_params">
<span class="sig-prename descclassname"><span class="pre">special.model_resampling.</span></span><span class="sig-name descname"><span class="pre">make_model_from_params</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">params</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">labels</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">grid_param_list</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dist</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lbda_obs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">model_grid</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">model_reader</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">em_lines</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">{}</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">em_grid</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">{}</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dlbda_obs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">instru_fwhm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">instru_idx</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">filter_reader</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">AV_bef_bb</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">units_obs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'si'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">units_mod</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'si'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">interp_order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/special/model_resampling.html#make_model_from_params"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#special.model_resampling.make_model_from_params" title="Permalink to this definition"></a></dt>
<dd><p>Routine to make the model from input parameters.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>params</strong> (<em>tuple</em>) – Set of models parameters for which the model grid has to be
interpolated.</p></li>
<li><p><strong>labels</strong> (<em>Tuple of strings</em>) – Tuple of labels in the same order as initial_state, that is:
* first all parameters related to loaded models (e.g. ‘Teff’, ‘logg’)
* then the planet photometric radius ‘R’, in Jupiter radius
* (optionally) the flux of emission lines (labels should match those         in the em_lines dictionary), in units of the model spectrum (times mu)
* (optionally) the optical extinction ‘Av’, in mag
* (optionally) the ratio of total to selective optical extinction ‘Rv’
* (optionally) ‘Tbb1’, ‘Rbb1’, ‘Tbb2’, ‘Rbb2’, etc. for each extra bb         contribution.</p></li>
<li><p><strong>grid_param_list</strong> (<em>list of 1d numpy arrays/lists OR None</em>) – <ul>
<li><p>If list, should contain list/numpy 1d arrays with available grid of         model parameters.</p></li>
<li><p>Set to None for a pure n-blackbody fit, n=1,2,…</p></li>
<li><p>Note1: model grids should not contain grids on radius and Av, but         these should still be passed in initial_state (Av optional).</p></li>
<li><p>Note2: for a combined grid model + black body, just provide         the grid parameter list here, and provide values for ‘Tbbn’ and         ‘Rbbn’ in initial_state, labels and bounds.</p></li>
</ul>
</p></li>
<li><p><strong>dist</strong> (<em>float</em>) – Distance in parsec, used for flux scaling of the models.</p></li>
<li><p><strong>lbda_obs</strong> (<em>numpy 1d ndarray</em><em> or </em><em>list</em><em>, </em><em>opt</em>) – Wavelength of observed spectrum. If provided, the model spectrum will
be resampled to match lbda_obs. If several instruments, should be
ordered per instrument, not necessarily as monotonically increasing
wavelength. Hereafter, n_ch = len(lbda_obs).</p></li>
<li><p><strong>model_grid</strong> (<em>numpy N-d array</em><em>, </em><em>optional</em>) – If provided, should contain the grid of model spectra for each
free parameter of the given grid. I.e. for a grid of n_T values of Teff
and n_g values of Logg, the numpy array should be n_T x n_g x n_ch x 2,
where n_ch is the number of wavelengths for the observed spectrum,
and the last 2 dims are for wavelength and fluxes respectively.
If provided, takes precedence over model_name/model_reader.</p></li>
<li><p><strong>model_reader</strong> (<em>python routine</em><em>, </em><em>opt</em>) – External routine that reads a model file and returns a 2D numpy array,
where the first column corresponds to wavelengths, and the second
contains model values. See example routine in interpolate_model()
description.</p></li>
<li><p><strong>em_lines</strong> (<em>dictionary</em><em>, </em><em>opt</em>) – Dictionary of emission lines to be added on top of the model spectrum.
Each dict entry should be the name of the line, assigned to a tuple of
3 values: 1) the wavelength (in mu), 2) a string indicating whether line
intensity is expressed in flux (‘F’), luminosity (‘L’) or log(L/LSun)
(“LogL”), and 3) the latter quantity. The intensity of the emission
lines can be sampled by MCMC, in that case the last element of the
tuple can be set to None. If not to be sampled, a value for the
intensity should be provided (in the same system of units as the model
spectra, multiplied by mu). Examples:
em_lines = {‘BrG’:(2.1667,’F’,263)};
em_lines = {‘BrG’:(2.1667,’LogL’,-5.1)}</p></li>
<li><p><strong>em_grid</strong> (<em>dictionary pointing to lists</em><em>, </em><em>opt</em>) – Dictionary where each entry corresponds to an emission line and points
to a list of values to inject for emission line fluxes. For computation
efficiency, interpolation will be performed between the points of this
grid during the MCMC sampling. Dict entries should match labels and
em_lines.</p></li>
<li><p><strong>dlbda_obs</strong> (<em>numpy 1d ndarray</em><em> or </em><em>list</em><em>, </em><em>optional</em>) – Spectral channel width for the observed spectrum. It should be provided
IF one wants to weigh each point based on the spectral
resolution of the respective instruments (as in Olofsson et al. 2016).</p></li>
<li><p><strong>instru_fwhm</strong> (<em>float</em><em> or </em><em>list</em><em>, </em><em>optional</em>) – The instrumental spectral fwhm provided in nm. This is used to convolve
the model spectrum. If several instruments are used, provide a list of
instru_fwhm values, one for each instrument whose spectral resolution
is coarser than the model - including broad band
filter FWHM if relevant.</p></li>
<li><p><strong>instru_idx</strong> (<em>numpy 1d array</em><em>, </em><em>optional</em>) – 1d array containing an index representing each instrument used
to obtain the spectrum, label them from 0 to n_instru. Zero for points
that don’t correspond to any instru_fwhm provided above, and i in
[1,n_instru] for points associated to instru_fwhm[i-1]. This parameter
must be provided if the spectrum consists of points obtained with
different instruments.</p></li>
<li><p><strong>filter_reader</strong> (<em>python routine</em><em>, </em><em>optional</em>) – External routine that reads a filter file and returns a 2D numpy array,
where the first column corresponds to wavelengths, and the second
contains transmission values. Important: if not provided, but strings
are detected in instru_fwhm, the default format assumed for the files:
- first row containing header;
- starting from 2nd row: 1st column: WL in mu, 2nd column: transmission
Note: files should all have the same format and wavelength units.</p></li>
<li><p><strong>AV_bef_bb</strong> (<em>bool</em><em>, </em><em>optional</em>) – If both extinction and an extra bb component are free parameters,
whether to apply extinction before adding the BB component (e.g.
extinction mostly from circumplanetary dust) or after the BB component
(e.g. mostly insterstellar extinction).</p></li>
<li><p><strong>units_obs</strong> (<em>str</em><em>, </em><em>opt {'si'</em><em>,</em><em>'cgs'</em><em>,</em><em>'jy'}</em>) – Units of observed spectrum. ‘si’ for W/m^2/mu; ‘cgs’ for ergs/s/cm^2/mu
or ‘jy’ for janskys.</p></li>
<li><p><strong>units_mod</strong> (<em>str</em><em>, </em><em>opt {'si'</em><em>,</em><em>'cgs'</em><em>,</em><em>'jy'}</em>) – Units of the model. ‘si’ for W/m^2/mu; ‘cgs’ for ergs/s/cm^2/mu or ‘jy’
for janskys. If different to units_obs, the spectrum units will be
converted.</p></li>
<li><p><strong>interp_order</strong> (<em>int</em><em>, </em><em>opt</em><em>, </em><em>{-1</em><em>,</em><em>0</em><em>,</em><em>1}</em>) – Interpolation mode for model interpolation.
-1: log interpolation (i.e. linear interpolatlion on log(Flux))
0: nearest neighbour model.
1: Order 1 spline interpolation.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>out</strong> – The model wavelength and spectrum</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>numpy array</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="special.model_resampling.make_resampled_models">
<span class="sig-prename descclassname"><span class="pre">special.model_resampling.</span></span><span class="sig-name descname"><span class="pre">make_resampled_models</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">lbda_obs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">grid_param_list</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">model_grid</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">model_reader</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">em_lines</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">{}</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">em_grid</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dlbda_obs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">instru_fwhm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">instru_idx</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">filter_reader</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">interp_nonexist</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/special/model_resampling.html#make_resampled_models"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#special.model_resampling.make_resampled_models" title="Permalink to this definition"></a></dt>
<dd><p>Returns a cube of models after convolution and resampling as in the
observations.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>lbda_obs</strong> (<em>numpy 1d ndarray</em><em> or </em><em>list</em>) – Wavelength of observed spectrum. If several instruments, should be
ordered per instrument, not necessarily as monotonically increasing
wavelength. Hereafter, n_ch = len(lbda_obs).</p></li>
<li><p><strong>grid_param_list</strong> (<em>list of 1d numpy arrays/lists</em>) – Should contain list/numpy 1d arrays with available grid of model
parameters. Note: model grids shouldn’t contain grids on radius and Av.</p></li>
<li><p><strong>model_grid</strong> (<em>list of 1d numpy arrays</em><em>, or </em><em>list of lists.</em>) – Available grid of model parameters (should only contain the parameter
values, not the models themselves). The latter will be loaded.
Important: 1) Make sure the bounds are within the model grid to avoid
extrapolation. 2) All keywords that are neither ‘R’, ‘Av’ nor ‘M’ will
be considered model grid parameters.
length of params, with the same order. OR ‘1bb’ or ‘2bb’ for black-body
models. In that case the model will be created on the fly at each
iteration using 1 or 2 Planck functions respectively. There are 2 params
for each Planck function: Teff and radius.</p></li>
<li><p><strong>model_reader</strong> (<em>python routine</em>) – External routine that reads a model file, converts it to required
units and returns a 2D numpy array, where the first column corresponds
to wavelengths, and the second contains model values. Example below.</p></li>
<li><p><strong>em_lines</strong> (<em>dictionary</em><em>, </em><em>opt</em>) – Dictionary of emission lines to be added on top of the model spectrum.
Each dict entry should be the name of the line, assigned to a tuple of
3 values: 1) the wavelength (in mu), 2) a string indicating whether line
intensity is expressed in flux (‘F’), luminosity (‘L’) or log(L/LSun)
(“LogL”), and 3) the latter quantity. The intensity of the emission
lines can be sampled by MCMC, in that case the last element of the
tuple can be set to None. If not to be sampled, a value for the
intensity should be provided (in the same system of units as the model
spectra, multiplied by mu). Example:
em_lines = {‘BrG’:(2.1667,’F’,263)}</p></li>
<li><p><strong>em_grid</strong> (<em>dictionary pointing to lists</em><em>, </em><em>opt</em>) – Dictionary where each entry corresponds to an emission line and points
to a list of values to inject for emission line fluxes. For computation
efficiency, interpolation will be performed between the points of this
grid during the MCMC sampling. Dict entries should match labels and
em_lines. Note: length of this dictionary can be different of em_lines;
i.e. if a line is in em_lines but not in em_grid, it will not be
considered an MCMC parameter.</p></li>
<li><p><strong>lbda_mod</strong> (<em>numpy 1d ndarray</em><em> or </em><em>list</em>) – Wavelength of tested model. Should have a wider wavelength extent than
the observed spectrum.</p></li>
<li><p><strong>spec_mod</strong> (<em>numpy 1d ndarray</em>) – Model spectrum. It does not require the same wavelength sampling as the
observed spectrum. If higher spectral resolution, it will be convolved
with the instrumental spectral psf (if instru_fwhm is provided) and
then binned to the same sampling. If lower spectral resolution, a
linear interpolation is performed to infer the value at the observed
spectrum wavelength sampling.</p></li>
<li><p><strong>dlbda_obs</strong> (<em>numpy 1d ndarray</em><em> or </em><em>list</em><em>, </em><em>optional</em>) – Spectral channel width for the observed spectrum. It should be provided
IF one wants to weigh each point based on the spectral
resolution of the respective instruments (as in Olofsson et al. 2016).</p></li>
<li><p><strong>instru_fwhm</strong> (<em>float</em><em> or </em><em>list</em><em>, </em><em>optional</em>) – The instrumental spectral fwhm provided in nm. This is used to convolve
the model spectrum. If several instruments are used, provide a list of
instru_fwhm values, one for each instrument whose spectral resolution
is coarser than the model - including broad band
filter FWHM if relevant.</p></li>
<li><p><strong>instru_idx</strong> (<em>numpy 1d array</em><em>, </em><em>optional</em>) – 1d array containing an index representing each instrument used
to obtain the spectrum, label them from 0 to n_instru. Zero for points
that don’t correspond to any instru_fwhm provided above, and i in
[1,n_instru] for points associated to instru_fwhm[i-1]. This parameter
must be provided if the spectrum consists of points obtained with
different instruments.</p></li>
<li><p><strong>filter_reader</strong> (<em>python routine</em><em>, </em><em>optional</em>) – External routine that reads a filter file and returns a 2D numpy array,
where the first column corresponds to wavelengths, and the second
contains transmission values. Important: if not provided, but strings
are detected in instru_fwhm, the default format assumed for the files:
- first row containing header
- starting from 2nd row: 1st column: WL in mu, 2nd column: transmission
Note: files should all have the same format and wavelength units.</p></li>
<li><p><strong>interp_nonexist</strong> (<em>bool</em><em>, </em><em>opt</em>) – Whether to interpolate if models do not exist, based on closest model(s)</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>resamp_mod</strong> – Grid of model spectra resampled at wavelengths matching the observed
spectrum.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>1d numpy array</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="special.model_resampling.resample_model">
<span class="sig-prename descclassname"><span class="pre">special.model_resampling.</span></span><span class="sig-name descname"><span class="pre">resample_model</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">lbda_obs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lbda_mod</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">spec_mod</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dlbda_obs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">instru_fwhm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">instru_idx</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">filter_reader</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">no_constraint</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/special/model_resampling.html#resample_model"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#special.model_resampling.resample_model" title="Permalink to this definition"></a></dt>
<dd><p>Convolve, interpolate and resample a model spectrum to match observed
spectrum.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>lbda_obs</strong> (<em>numpy 1d ndarray</em><em> or </em><em>list</em>) – Wavelength of observed spectrum. If several instruments, should be
ordered per instrument, not necessarily as monotonically increasing
wavelength. Hereafter, n_ch = len(lbda_obs).</p></li>
<li><p><strong>lbda_mod</strong> (<em>numpy 1d ndarray</em><em> or </em><em>list</em>) – Wavelength of tested model. Should have a wider wavelength extent than
the observed spectrum.</p></li>
<li><p><strong>spec_mod</strong> (<em>numpy 1d ndarray</em>) – Model spectrum. It does not require the same wavelength sampling as the
observed spectrum. If higher spectral resolution, it will be convolved
with the instrumental spectral psf (if instru_fwhm is provided) and
then binned to the same sampling. If lower spectral resolution, a
linear interpolation is performed to infer the value at the observed
spectrum wavelength sampling.</p></li>
<li><p><strong>dlbda_obs</strong> (<em>numpy 1d ndarray</em><em> or </em><em>list</em><em>, </em><em>optional</em>) – Spectral channel width for the observed spectrum. It should be provided
IF one wants to weigh each point based on the spectral
resolution of the respective instruments (as in Olofsson et al. 2016).</p></li>
<li><p><strong>instru_fwhm</strong> (<em>float</em><em> or </em><em>list</em><em>, </em><em>optional</em>) – The instrumental spectral fwhm provided in nm. This is used to convolve
the model spectrum. If several instruments are used, provide a list of
instru_fwhm values, one for each instrument whose spectral resolution
is coarser than the model - including broad band
filter FWHM if relevant.</p></li>
<li><p><strong>instru_idx</strong> (<em>numpy 1d array</em><em>, </em><em>optional</em>) – 1d array containing an index representing each instrument used
to obtain the spectrum, label them from 0 to n_instru. Zero for points
that don’t correspond to any instru_fwhm provided above, and i in
[1,n_instru] for points associated to instru_fwhm[i-1]. This parameter
must be provided if the spectrum consists of points obtained with
different instruments.</p></li>
<li><p><strong>filter_reader</strong> (<em>python routine</em><em>, </em><em>optional</em>) – External routine that reads a filter file and returns a 2D numpy array,
where the first column corresponds to wavelengths, and the second
contains transmission values. Important: if not provided, but strings
are detected in instru_fwhm, the default format assumed for the files:
- first row containing header
- starting from 2nd row: 1st column: WL in mu, 2nd column: transmission
Note: files should all have the same format and wavelength units.</p></li>
<li><p><strong>no_constraint</strong> (<em>bool</em><em>, </em><em>optional</em>) – If set to True, will not use ‘floor’ and ‘ceil’ constraints when
cropping the model wavelength ranges, i.e. faces the risk of
extrapolation. May be useful, if the bounds of the wavelength ranges
are known to match exactly.</p></li>
<li><p><strong>verbose</strong> (<em>bool</em><em>, </em><em>optional</em>) – Whether to print more information during resampling.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>lbda_obs, spec_mod_res</strong> – Observed lambdas, and resampled model spectrum (at those lambdas)</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>2x 1d numpy array</p>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-special.nested_sampling">
<span id="special-nested-sampling"></span><h1>special.nested_sampling<a class="headerlink" href="#module-special.nested_sampling" title="Permalink to this headline"></a></h1>
<p>Module with functions for posterior sampling of the model spectra parameters
using nested sampling (<code class="docutils literal notranslate"><span class="pre">nestle</span></code>).</p>
<dl class="py function">
<dt class="sig sig-object py" id="special.nested_sampling.nested_sampling_results">
<span class="sig-prename descclassname"><span class="pre">special.nested_sampling.</span></span><span class="sig-name descname"><span class="pre">nested_sampling_results</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ns_object</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">labels</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">burnin</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.4</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bins</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cfd</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">68.27</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">units</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ndig</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">labels_plot</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">save</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">output_dir</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'/'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">plot</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/special/nested_sampling.html#nested_sampling_results"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#special.nested_sampling.nested_sampling_results" title="Permalink to this definition"></a></dt>
<dd><p>Shows the results of the Nested Sampling, summary, parameters with
errors, walk and corner plots. Returns best-fit values and uncertatinties.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ns_object</strong> (<em>numpy.array</em>) – The nestle object returned from <cite>nested_spec_sampling</cite>.</p></li>
<li><p><strong>labels</strong> (<em>Tuple of strings</em>) – Tuple of labels in the same order as initial_state, that is:
- first all parameters related to loaded models (e.g. ‘Teff’, ‘logg’)
- then the planet photometric radius ‘R’, in Jupiter radius
- (optionally) the flux of emission lines (labels should match those         in the em_lines dictionary), in units of the model spectrum (times mu)
- (optionally) the optical extinction ‘Av’, in mag
- (optionally) the ratio of total to selective optical extinction ‘Rv’
- (optionally) ‘Tbb1’, ‘Rbb1’, ‘Tbb2’, ‘Rbb2’, etc. for each extra bb         contribution.</p></li>
<li><p><strong>burnin</strong> (<em>float</em><em>, </em><em>default: 0</em>) – The fraction of a walker we want to discard.</p></li>
<li><p><strong>bins</strong> (<em>int</em><em>, </em><em>optional</em>) – The number of bins used to sample the posterior distributions.</p></li>
<li><p><strong>cfd</strong> (<em>float</em><em>, </em><em>optional</em>) – The confidence level given in percentage.</p></li>
<li><p><strong>units</strong> (<em>tuple</em><em>, </em><em>opt</em>) – Tuple of strings containing units for each parameter. If provided,
mcmc_res will be printed on top of each 1d posterior distribution along
with these units.</p></li>
<li><p><strong>ndig</strong> (<em>tuple</em><em>, </em><em>opt</em>) – Number of digits precision for each printed parameter</p></li>
<li><p><strong>labels_plot</strong> (<em>tuple</em><em>, </em><em>opt</em>) – Labels corresponding to parameter names, used for the plot. If None,
will use “labels” passed in kwargs.</p></li>
<li><p><strong>save</strong> (<em>boolean</em><em>, </em><em>default: False</em>) – If True, a pdf file is created.</p></li>
<li><p><strong>output_dir</strong> (<em>str</em><em>, </em><em>optional</em>) – The name of the output directory which contains the output files in the
case  <code class="docutils literal notranslate"><span class="pre">save</span></code> is True.</p></li>
<li><p><strong>plot</strong> (<em>bool</em><em>, </em><em>optional</em>) – Whether to show the plots (instead of saving them).</p></li>
<li><p><strong>kwargs</strong> – Additional optional arguments passed to <cite>confidence</cite> (matplotlib
optional arguments for histograms).</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>final_res</strong> – Best-fit parameters and uncertainties (corresponding to 68% confidence
interval). Dimensions: nparams x 2.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>numpy ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="special.nested_sampling.nested_spec_sampling">
<span class="sig-prename descclassname"><span class="pre">special.nested_sampling.</span></span><span class="sig-name descname"><span class="pre">nested_spec_sampling</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">init</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lbda_obs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">spec_obs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">err_obs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dist</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">grid_param_list</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">labels</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bounds</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">resamp_before</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">model_grid</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">model_reader</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">em_lines</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">{}</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">em_grid</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">{}</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dlbda_obs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">instru_corr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">instru_fwhm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">instru_idx</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">filter_reader</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">AV_bef_bb</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">units_obs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'si'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">units_mod</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'si'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">interp_order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">priors</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">physical</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">interp_nonexist</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">output_dir</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'special/'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">grid_name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'resamp_grid.fits'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'single'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">npoints</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dlogz</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">decline_factor</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rstate</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/special/nested_sampling.html#nested_spec_sampling"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#special.nested_sampling.nested_spec_sampling" title="Permalink to this definition"></a></dt>
<dd><p>Runs a nested sampling algorithm in order to determine the position and
the flux of the planet using the ‘Negative Fake Companion’ technique. The
result of this procedure is a a <code class="docutils literal notranslate"><span class="pre">nestle</span></code> object containing the samples
from the posterior distributions of each of the 3 parameters. It provides
pretty good results (value plus error bars) compared to a more CPU intensive
Monte Carlo approach with the affine invariant sampler (<code class="docutils literal notranslate"><span class="pre">emcee</span></code>).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>init</strong> (<em>numpy ndarray</em><em> or </em><em>tuple</em>) – Initial guess on the best fit parameters of the spectral fit. Length of
the tuple should match the total number of free parameters.
- first all parameters related to loaded models (e.g. ‘Teff’, ‘logg’)
- then the planet photometric radius ‘R’, in Jupiter radius
- (optionally) the intensity of emission lines (labels must match         those in the em_lines dict), in units of the model spectrum (x mu)
- (optionally) the optical extinction ‘Av’, in mag
- (optionally) the ratio of total to selective optical extinction ‘Rv’
- (optionally) ‘Tbb1’, ‘Rbb1’, ‘Tbb2’, ‘Rbb2’, etc. for each extra bb         contribution</p></li>
<li><p><strong>lbda_obs</strong> (<em>numpy 1d ndarray</em><em> or </em><em>list</em>) – Wavelength of observed spectrum. If several instruments, should be
ordered per instrument, not necessarily as monotonically increasing
wavelength. Hereafter, n_ch = len(lbda_obs).</p></li>
<li><p><strong>spec_obs</strong> (<em>numpy 1d ndarray</em><em> or </em><em>list</em>) – Observed spectrum for each value of lbda_obs.</p></li>
<li><p><strong>err_obs</strong> (<em>numpy 1d/2d ndarray</em><em> or </em><em>list</em>) – Uncertainties on the observed spectrum. If 2d array, should be [2,n_ch]
where the first (resp. second) column corresponds to lower (upper)
uncertainty, and n_ch is the length of lbda_obs and spec_obs.</p></li>
<li><p><strong>dist</strong> (<em>float</em>) – Distance in parsec, used for flux scaling of the models.</p></li>
<li><p><strong>grid_param_list</strong> (<em>list of 1d numpy arrays/lists OR None</em>) – <ul>
<li><p>If list, should contain list/numpy 1d arrays with available grid of         model parameters.</p></li>
<li><p>Set to None for a pure n-blackbody fit, n=1,2,…</p></li>
<li><p>Note1: model grids should not contain grids on radius and Av, but         these should still be passed in initial_state (Av optional).</p></li>
<li><p>Note2: for a combined grid model + black body, just provide         the grid parameter list here, and provide values for ‘Tbbn’ and ‘Rbbn’         in initial_state, labels and bounds.</p></li>
</ul>
</p></li>
<li><p><strong>labels</strong> (<em>Tuple of strings</em>) – Tuple of labels in the same order as initial_state, that is:
- first all parameters related to loaded models (e.g. ‘Teff’, ‘logg’)
- then the planet photometric radius ‘R’, in Jupiter radius
- (optionally) the flux of emission lines (labels should match those         in the em_lines dictionary), in units of the model spectrum (times mu)
- (optionally) the optical extinction ‘Av’, in mag
- (optionally) the ratio of total to selective optical extinction ‘Rv’
- (optionally) ‘Tbb1’, ‘Rbb1’, ‘Tbb2’, ‘Rbb2’, etc. for each extra bb         contribution.</p></li>
<li><p><strong>bounds</strong> (<em>dictionary</em>) – Each entry should be associated with a tuple corresponding to lower and
upper bounds respectively. Bounds should be provided for ALL model
parameters, including ‘R’ (planet photometric radius). ‘Av’ (optical
extinction) is optional. If provided here, Av will also be fitted.
Example for BT-SETTL: bounds = {‘Teff’:(1000,2000), ‘logg’:(3.0,4.5),
‘R’:(0.1,5), ‘Av’:(0.,2.5)}
‘M’ can be used for a prior on the mass of the planet. In that case the
corresponding prior log probability is computed from the values for
parameters ‘logg’ and ‘R’ (if both exist).</p></li>
<li><p><strong>resamp_before</strong> (<em>bool</em><em>, </em><em>optional</em>) – Whether to prepare the whole grid of resampled models before entering
the MCMC, i.e. to avoid doing it at every MCMC step. Recommended.
Only reason not to: model grid is too large and individual models
require being opened and resampled at each step.</p></li>
<li><p><strong>model_grid</strong> (<em>numpy N-d array</em><em>, </em><em>optional</em>) – If provided, should contain the grid of model spectra for each
free parameter of the given grid. I.e. for a grid of n_T values of Teff
and n_g values of Logg, the numpy array should be n_T x n_g x n_ch x 2,
where n_ch is the number of wavelengths for the observed spectrum,
and the last 2 dims are for wavelength and fluxes respectively.
If provided, takes precedence over filename/file_reader.</p></li>
<li><p><strong>model_reader</strong> (<em>python routine</em><em>, </em><em>optional</em>) – External routine that reads a model file and returns a 2D numpy array,
where the first column corresponds to wavelengths, and the second
contains model values. See example routine in model_interpolation()
description.</p></li>
<li><p><strong>em_lines</strong> (<em>dictionary</em><em>, </em><em>opt</em>) – Dictionary of emission lines to be added on top of the model spectrum.
Each dict entry should be the name of the line, assigned to a tuple of
4 values:
1) the wavelength (in mu);
2) a string indicating whether line intensity is expressed in flux
(‘F’), luminosity (‘L’) or log(L/LSun) (“LogL”);
3) the FWHM of the gaussian (or None if to be set automatically);
4) whether the FWHM is expressed in ‘nm’, ‘mu’ or ‘km/s’.
The third and fourth can also be set to None. In that case, the FWHM of
the gaussian will automatically be set to the equivalent width of the
line, calculated from the flux to be injected and the continuum
level (measured in the grid model to which the line is injected).
Examples:
em_lines = {‘BrG’:(2.1667,’F’, None, None)};
em_lines = {‘BrG’:(2.1667,’LogL’, 100, ‘km/s’)}</p></li>
<li><p><strong>em_grid</strong> (<em>dictionary pointing to lists</em><em>, </em><em>opt</em>) – Dictionary where each entry corresponds to an emission line and points
to a list of values to inject for emission line fluxes. For computation
efficiency, interpolation will be performed between the points of this
grid during the MCMC sampling. Dict entries should match labels and
em_lines.</p></li>
<li><p><strong>dlbda_obs</strong> (<em>numpy 1d ndarray</em><em> or </em><em>list</em><em>, </em><em>optional</em>) – Spectral channel width for the observed spectrum. It should be provided
IF one wants to weigh each point based on the spectral
resolution of the respective instruments (as in Olofsson et al. 2016).</p></li>
<li><p><strong>instru_corr</strong> (<em>numpy 2d ndarray</em><em> or </em><em>list</em><em>, </em><em>optional</em>) – Spectral correlation throughout post-processed images in which the
spectrum is measured. It is specific to the combination of instrument,
algorithm and radial separation of the companion from the central star.
Can be computed using distances.spectral_correlation(). In case of
a spectrum obtained with different instruments, build it with
distances.combine_corrs(). If not provided, it will consider the
uncertainties in each spectral channels are independent. See Greco &amp;
Brandt (2017) for details.</p></li>
<li><p><strong>instru_fwhm</strong> (<em>float OR list of either floats</em><em> or </em><em>strings</em><em>, </em><em>optional</em>) – The instrumental spectral fwhm provided in nm. This is used to convolve
the model spectrum. If several instruments are used, provide a list of
instru_fwhm values, one for each instrument whose spectral resolution
is coarser than the model - including broad band filter FWHM if
relevant.
If strings are provided, they should correspond to filenames (including
full paths) of text files containing the filter information for each
observed wavelength. Strict format:</p></li>
<li><p><strong>instru_idx</strong> (<em>numpy 1d array</em><em>, </em><em>optional</em>) – 1d array containing an index representing each instrument used
to obtain the spectrum, label them from 0 to n_instru. Zero for points
that don’t correspond to any instru_fwhm provided above, and i in
[1,n_instru] for points associated to instru_fwhm[i-1]. This parameter
must be provided if the spectrum consists of points obtained with
different instruments.</p></li>
<li><p><strong>filter_reader</strong> (<em>python routine</em><em>, </em><em>optional</em>) – External routine that reads a filter file and returns a 2D numpy array,
where the first column corresponds to wavelengths, and the second
contains transmission values. Important: if not provided, but strings
are detected in instru_fwhm, the default file reader will be used.
It assumes the following format for the files:
- first row containing header
- starting from 2nd row: 1st column: wavelength, 2nd col.: transmission
- Unit of wavelength can be provided in parentheses of first header         key name: e.g. “WL(AA)” for angstrom, “wavelength(mu)” for micrometer         or “lambda(nm)” for nanometer. Note: Only what is in parentheses         matters.
Important: filter files should all have the same format and WL units.</p></li>
<li><p><strong>AV_bef_bb</strong> (<em>bool</em><em>, </em><em>optional</em>) – If both extinction and an extra bb component are free parameters,
whether to apply extinction before adding the BB component (e.g.
extinction mostly from circumplanetary dust) or after the BB component
(e.g. mostly insterstellar extinction).</p></li>
<li><p><strong>units_obs</strong> (<em>str</em><em>, </em><em>opt {'si'</em><em>,</em><em>'cgs'</em><em>,</em><em>'jy'}</em>) – Units of observed spectrum. ‘si’ for W/m^2/mu; ‘cgs’ for ergs/s/cm^2/mu
or ‘jy’ for janskys.</p></li>
<li><p><strong>units_mod</strong> (<em>str</em><em>, </em><em>opt {'si'</em><em>,</em><em>'cgs'</em><em>,</em><em>'jy'}</em>) – Units of the model. ‘si’ for W/m^2/mu; ‘cgs’ for ergs/s/cm^2/mu or ‘jy’
for janskys. If different to units_obs, the spectrum units will be
converted.</p></li>
<li><p><strong>interp_order</strong> (<em>int</em><em>, </em><em>opt</em><em>, </em><em>{-1</em><em>,</em><em>0</em><em>,</em><em>1}</em>) – Interpolation mode for model interpolation.
-1: log interpolation (i.e. linear interpolatlion on log(Flux))
0: nearest neighbour model.
1: Order 1 spline interpolation.</p></li>
<li><p><strong>priors</strong> (<em>dictionary</em><em>, </em><em>opt</em>) – If not None, sets prior estimates for each parameter of the model. Each
entry should be set to either None (no prior) or a tuple of 2 elements
containing prior estimate and uncertainty on the estimate.
Missing entries (i.e. provided in bounds dictionary but not here) will
be associated no prior.
e.g. priors = {‘Teff’:(1600,100), ‘logg’:(3.5,0.5), ‘R’:(1.6,0.1),
‘Av’:(1.8,0.2), ‘M’:(10,3)}
Important: dictionary entry names should match exactly those of bounds.</p></li>
<li><p><strong>physical</strong> (<em>bool</em><em>, </em><em>opt</em>) – In case of extra black body component(s) to a photosphere, whether to
force lower temperature than the photosphere effective temperature.</p></li>
<li><p><strong>interp_nonexist</strong> (<em>bool</em><em>, </em><em>opt</em>) – Whether to interpolate non-existing models in the grid. Only used if
resamp_before is set to True.</p></li>
<li><p><strong>w</strong> (<em>float</em><em> or </em><em>tuple</em>) – The relative size of the bounds (around the initial state <code class="docutils literal notranslate"><span class="pre">init</span></code>) for
each parameter. If a float the same relative size is considered for
each parameter. E.g. if 0.1, bounds will be set to:
(0.9*params[0], 1.1*params[0]),
…
(0.9*params[N-1], 1.1*params[N-1]),
to True), or make it and write it if it does not.</p></li>
<li><p><strong>output_dir</strong> (<em>str</em><em>, </em><em>optional</em>) – The name of the output directory which contains the output files in the
case  <code class="docutils literal notranslate"><span class="pre">save</span></code> is True.</p></li>
<li><p><strong>grid_name</strong> (<em>str</em><em>, </em><em>optional</em>) – Name of the fits file containing the model grid (numpy array) AFTER
convolution+resampling as the observed spectrum given as input.
If provided, will read it if it exists (and resamp_before is set</p></li>
<li><p><strong>method</strong> (<em>{&quot;single&quot;</em><em>, </em><em>&quot;multi&quot;</em><em>, </em><em>&quot;classic&quot;}</em><em>, </em><em>str optional</em>) – Flavor of nested sampling.</p></li>
<li><p><strong>npoints</strong> (<em>int optional</em>) – Number of active points. At least ndim+1 (4 will produce bad results).
For problems with just a few parameters (&lt;=5) like the NEGFC, good
results are obtained with 100 points (default).</p></li>
<li><p><strong>dlogz</strong> (<em>Estimated remaining evidence</em>) – Iterations will stop when the estimated contribution of the remaining
prior volume to the total evidence falls below this threshold.
Explicitly, the stopping criterion is log(z + z_est) - log(z) &lt; dlogz
where z is the current evidence from all saved samples, and z_est is the
estimated contribution from the remaining volume. This option and
decline_factor are mutually exclusive. If neither is specified, the
default is dlogz=0.5.</p></li>
<li><p><strong>decline_factor</strong> (<em>float</em><em>, </em><em>optional</em>) – If supplied, iteration will stop when the weight (likelihood times prior
volume) of newly saved samples has been declining for
decline_factor * nsamples consecutive samples. A value of 1.0 seems to
work pretty well.</p></li>
<li><p><strong>rstate</strong> (<em>random instance</em><em>, </em><em>optional</em>) – RandomState instance. If not given, the global random state of the
numpy.random module will be used.</p></li>
<li><p><strong>kwargs</strong> (<em>optional</em>) – Additional optional arguments to the <cite>nestle.sample</cite> function.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>res</strong> – <code class="docutils literal notranslate"><span class="pre">Nestle</span></code> object with the nested sampling results, including the
posterior samples.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>nestle object</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Nested Sampling is a computational approach for integrating posterior
probability in order to compare models in Bayesian statistics. It is similar
to Markov Chain Monte Carlo (MCMC) in that it generates samples that can be
used to estimate the posterior probability distribution. Unlike MCMC, the
nature of the sampling also allows one to calculate the integral of the
distribution. It also happens to be a pretty good method for robustly
finding global maxima.</p>
<p>Nestle documentation:
<a class="reference external" href="http://kbarbary.github.io/nestle/">http://kbarbary.github.io/nestle/</a></p>
<p>Convergence:
<a class="reference external" href="http://kbarbary.github.io/nestle/stopping.html">http://kbarbary.github.io/nestle/stopping.html</a>
Nested sampling has no well-defined stopping point. As iterations continue,
the active points sample a smaller and smaller region of prior space.
This can continue indefinitely. Unlike typical MCMC methods, we don’t gain
any additional precision on the results by letting the algorithm run longer;
the precision is determined at the outset by the number of active points.
So, we want to stop iterations as soon as we think the active points are
doing a pretty good job sampling the remaining prior volume - once we’ve
converged to the highest-likelihood regions such that the likelihood is
relatively flat within the remaining prior volume.</p>
<p>Method:
The trick in nested sampling is to, at each step in the algorithm,
efficiently choose a new point in parameter space drawn with uniform
probability from the parameter space with likelihood greater than the
current likelihood constraint. The different methods all use the
current set of active points as an indicator of where the target
parameter space lies, but differ in how they select new points from  it.
“classic” is close to the method described in Skilling (2004).
“single”, Mukherjee, Parkinson &amp; Liddle (2006), Determines a single
ellipsoid that bounds all active points,
enlarges the ellipsoid by a user-settable factor, and selects a new point
at random from within the ellipsoid.
“multiple”, Shaw, Bridges &amp; Hobson (2007) and Feroz, Hobson &amp; Bridges 2009
(Multinest). In cases where the posterior is multi-modal,
the single-ellipsoid method can be extremely inefficient: In such
situations, there are clusters of active points on separate
high-likelihood regions separated by regions of lower likelihood.
Bounding all points in a single ellipsoid means that the ellipsoid
includes the lower-likelihood regions we wish to avoid
sampling from.
The solution is to detect these clusters and bound them in separate
ellipsoids. For this, we use a recursive process where we perform
K-means clustering with K=2. If the resulting two ellipsoids have a
significantly lower total volume than the parent ellipsoid (less than half),
we accept the split and repeat the clustering and volume test on each of
the two subset of points. This process continues recursively.
Alternatively, if the total ellipse volume is significantly greater
than expected (based on the expected density of points) this indicates
that there may be more than two clusters and that K=2 was not an
appropriate cluster division.
We therefore still try to subdivide the clusters recursively. However,
we still only accept the final split into N clusters if the total volume
decrease is significant.</p>
</dd></dl>

</div>
<div class="section" id="module-special.spec_corr">
<span id="special-spec-corr"></span><h1>special.spec_corr<a class="headerlink" href="#module-special.spec_corr" title="Permalink to this headline"></a></h1>
<p>Module to estimate the spectral correlation between channels of an IFS datacube.</p>
<dl class="py function">
<dt class="sig sig-object py" id="special.spec_corr.spectral_correlation">
<span class="sig-prename descclassname"><span class="pre">special.spec_corr.</span></span><span class="sig-name descname"><span class="pre">spectral_correlation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">array</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">awidth</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">r_in</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">r_out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pl_xy</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask_r</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">4</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fwhm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">4</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sp_fwhm_guess</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">3</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">full_output</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/special/spec_corr.html#spectral_correlation"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#special.spec_corr.spectral_correlation" title="Permalink to this definition"></a></dt>
<dd><p>Computes the spectral correlation between (post-processed) IFS frames,
as a function of radius, implemented as Eq. 7 of Greco &amp; Brandt 2017. This
is a crucial step for an unbias fit of a measured IFS spectrum to either
synthetic or template spectra.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>array</strong> (<em>numpy ndarray</em>) – Input cube or 3d array, of dimensions n_ch x n_y x n_x; where n_y and
n_x should be odd values (star should be centered on central pixel).</p></li>
<li><p><strong>awidth</strong> (<em>int</em><em>, </em><em>optional</em>) – Width in pixels of the concentric annuli used to compute the spectral
correlation as a function of radial separation. Greco &amp; Brandt 2017
noted no significant differences for annuli between 1 and 3 pixels
width on GPI data.</p></li>
<li><p><strong>r_in</strong> (<em>int</em><em>, </em><em>optional</em>) – Innermost radius where the spectral correlation starts to be computed.</p></li>
<li><p><strong>r_out</strong> (<em>int</em><em>, </em><em>optional</em>) – Outermost radius where the spectral correlation is computed.If left as
None, it will automatically be computed up to the edge of the frame.</p></li>
<li><p><strong>pl_xy</strong> (<em>tuple of tuples of 2 floats</em><em>, </em><em>optional</em>) – x,y coordiantes of all companions present in the images. If provided,
a circle centered on the location of each companion will be masked out
for the spectral correlation computation.</p></li>
<li><p><strong>mask_r</strong> (<em>float</em><em>, </em><em>optional</em>) – if pl_xy is provided, this should also be provided. Size of the
aperture around each companion (in terms of fwhm) that is discarded to
not bias the spectral correlation computation.</p></li>
<li><p><strong>fwhm</strong> (<em>float</em><em>, </em><em>optional</em>) – if pl_xy is provided, this should also be provided. By default we
consider a 2FWHM aperture mask around each companion to not bias the
spectral correlation computation.</p></li>
<li><p><strong>sp_fwhm_guess</strong> (<em>float</em><em>, </em><em>optional</em>) – Initial guess on the spectral FWHM of all channels.</p></li>
<li><p><strong>full_output</strong> (<em>bool</em><em>, </em><em>opt</em>) – Whether to also output the fitted spectral FWHM for each channel, and
the vector of radial separation at which each spectral correlation
matrix is calculated.</p></li>
<li><p><strong>Note</strong> (<em>radii that are skipped will be filled with zeros in the output cube.</em>) – </p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>sp_corr</strong> (<em>numpy ndarray</em>) – 3d array of spectral correlation, as a function of radius with
dimensions: n_rad x n_ch x n_ch, where n_rad = int((r_out-r_in)/2)</p></li>
<li><p><strong>sp_fwhm</strong> (<em>numpy ndarray</em>) – (if full_output is True) 2d array containing the spectral fwhm at each
radius, for each spectral channel. Dims: n_rad x n_ch</p></li>
<li><p><strong>sp_rad</strong> (<em>numpy ndarray</em>) – (if full_output is True) 1d array containing the radial separation of
each measured spectral correlation matrix. Dims: n_rad</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-special.spec_indices">
<span id="special-spec-indices"></span><h1>special.spec_indices<a class="headerlink" href="#module-special.spec_indices" title="Permalink to this headline"></a></h1>
<p>Module with utilities to estimate the spectral type and gravity of an object
based on spectral indices.</p>
<dl class="py function">
<dt class="sig sig-object py" id="special.spec_indices.idx_to_spt">
<span class="sig-prename descclassname"><span class="pre">special.spec_indices.</span></span><span class="sig-name descname"><span class="pre">idx_to_spt</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">idx</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">convention</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'splat'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/special/spec_indices.html#idx_to_spt"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#special.spec_indices.idx_to_spt" title="Permalink to this definition"></a></dt>
<dd><p>Converts an integer index into spectral type.
Convention (from splat): K0 = 0, M0=10, L0=20, T0=30, Y9 = 49
Convention (from Allers+07): M5 = 5, L5 = 15</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>idx</strong> (<em>float</em><em> or </em><em>int</em>) – Index value of the spectral type</p></li>
<li><p><strong>verbose</strong> (<em>bool</em><em>, </em><em>optional</em>) – Whther to print more information.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>spt</strong> – String representing the spectral index</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>str</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="special.spec_indices.sp_idx_to_spt">
<span class="sig-prename descclassname"><span class="pre">special.spec_indices.</span></span><span class="sig-name descname"><span class="pre">sp_idx_to_spt</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">idx</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">line</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'H2O-1.5'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">idx_err</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/special/spec_indices.html#sp_idx_to_spt"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#special.spec_indices.sp_idx_to_spt" title="Permalink to this definition"></a></dt>
<dd><dl class="simple">
<dt>Estimates a spectral type from a spectral index. Implemented so far:</dt><dd><ul class="simple">
<li><p>the H2O 1.5 mu index (Allers et al. 2007)</p></li>
</ul>
</dd>
<dt>Note on scale of SpT:</dt><dd><p>5 = M5
15 = L5</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>idx</strong> (<em>float</em>) – Value of spectral index</p></li>
<li><p><strong>line</strong> (<em>str</em><em>, </em><em>optional {'H2O-1.5'}</em>) – The line corresponding to the spectral index.</p></li>
<li><p><strong>idx_err</strong> (<em>float</em><em>, </em><em>optional</em>) – Uncertainty on the spectral index value</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>spt</strong> (<em>float</em>) – Value of the spectral type</p></li>
<li><p><strong>spt_err</strong> (<em>float</em>) – [if idx_err is provided] Uncertainty on the spectral type.</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="special.spec_indices.spectral_idx">
<span class="sig-prename descclassname"><span class="pre">special.spec_indices.</span></span><span class="sig-name descname"><span class="pre">spectral_idx</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">lbda</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">spec</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">line</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'H2O-1.5'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">spec_err</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/special/spec_indices.html#spectral_idx"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#special.spec_indices.spectral_idx" title="Permalink to this definition"></a></dt>
<dd><dl class="simple">
<dt>Computes a spectral index. Implemented so far:</dt><dd><ul class="simple">
<li><p>the H2O 1.5 mu index (Allers et al. 2007)</p></li>
<li><p>the Na 1.1 mu index (Allers et al. 2007)</p></li>
</ul>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>lbda</strong> (<em>numpy ndarray</em>) – 1d numpy array containing the wavelengths of the spectrum in microns.</p></li>
<li><p><strong>spec</strong> (<em>numpy ndarray</em>) – 1d numpy array containing the measured flux (arbitrary units accepted).</p></li>
<li><p><strong>line</strong> (<em>str</em><em>, </em><em>optional {'H2O-1.5'</em><em>, </em><em>'Na-1.1'}</em>) – Which line to use for the calculation of the spectral index.</p></li>
<li><p><strong>spec_err</strong> (<em>numpy ndarray</em><em>, </em><em>optional</em>) – 1d numpy array containing the uncertainties on the measured flux
(arbitrary units accepted). If provided the uncertainty on the spectral
index will also be returned.</p></li>
<li><p><strong>verbose</strong> (<em>bool</em><em>, </em><em>optional</em>) – Whther to print more information.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>index</strong> (<em>float</em>) – Value of the spectral index</p></li>
<li><p><strong>index_err</strong> (<em>float</em>) – [if spec_err is provided] Uncertainty on the spectral index.</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="special.spec_indices.spt_to_idx">
<span class="sig-prename descclassname"><span class="pre">special.spec_indices.</span></span><span class="sig-name descname"><span class="pre">spt_to_idx</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">spt</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/special/spec_indices.html#spt_to_idx"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#special.spec_indices.spt_to_idx" title="Permalink to this definition"></a></dt>
<dd><p>Converts a string representing spectral type into an integer index.
Convention (from splat): K0 = 0, M0=10, L0=20, T0=30, Y9 = 49</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>spt</strong> (<em>str</em>) – String representing the spectral index</p></li>
<li><p><strong>verbose</strong> (<em>bool</em><em>, </em><em>optional</em>) – Whther to print more information.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>idx</strong> – Index value of the spectral type</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>float or int</p>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-special.template_fit">
<span id="special-template-fit"></span><h1>special.template_fit<a class="headerlink" href="#module-special.template_fit" title="Permalink to this headline"></a></h1>
<p>Module for simplex or grid search of best fit spectrum in a template library.</p>
<dl class="py function">
<dt class="sig sig-object py" id="special.template_fit.best_fit_tmp">
<span class="sig-prename descclassname"><span class="pre">special.template_fit.</span></span><span class="sig-name descname"><span class="pre">best_fit_tmp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">lbda_obs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">spec_obs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">err_obs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tmp_reader</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">search_mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'simplex'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_best</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lambda_scal</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scale_range</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">(0.1,</span> <span class="pre">10,</span> <span class="pre">0.01)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ext_range</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">simplex_options</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dlbda_obs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">instru_corr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">instru_fwhm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">instru_idx</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">filter_reader</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lib_dir</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'tmp_lib/'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tmp_endswith</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'.fits'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">red_chi2</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">remove_nan</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nproc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbosity</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">force_continue</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/special/template_fit.html#best_fit_tmp"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#special.template_fit.best_fit_tmp" title="Permalink to this definition"></a></dt>
<dd><p>Finds the best fit template spectrum to a given observed spectrum,
within a spectral library.  By default, a single free parameter is
considered: the scaling factor of the spectrum. A first automatic scaling
is performed by comparing the flux of the observed and template spectra at
lambda_scal. Then a more refined scaling is performed, either through
simplex or grid search (within scale_range).
If fit_extinction is set to True, the exctinction is also considered as a
free parameter.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>lbda_obs</strong> (<em>numpy 1d ndarray</em><em> or </em><em>list</em>) – Wavelength of observed spectrum. If several instruments, should be
ordered per instrument, not necessarily as monotonically increasing
wavelength. Hereafter, n_ch = len(lbda_obs).</p></li>
<li><p><strong>spec_obs</strong> (<em>numpy 1d ndarray</em><em> or </em><em>list</em>) – Observed spectrum for each value of lbda_obs.</p></li>
<li><p><strong>err_obs</strong> (<em>numpy 1d/2d ndarray</em><em> or </em><em>list</em>) – Uncertainties on the observed spectrum. If 2d array, should be [2,n_ch]
where the first (resp. second) column corresponds to lower (upper)
uncertainty, and n_ch is the length of lbda_obs and spec_obs.</p></li>
<li><p><strong>tmp_reader</strong> (<em>python routine</em>) – External routine that reads a model file and returns a 3D numpy array,
where the first column corresponds to wavelengths, the second
contains flux values, and the third the uncertainties on the flux.</p></li>
<li><p><strong>search_mode</strong> (<em>str</em><em>, </em><em>optional</em><em>, </em><em>{'simplex'</em><em>,</em><em>'grid'}</em>) – How is the best fit template found? Simplex or grid search.</p></li>
<li><p><strong>n_best</strong> (<em>int</em><em>, </em><em>optional</em>) – Number of best templates to be returned (default: 1)</p></li>
<li><p><strong>lambda_scal</strong> (<em>float</em><em>, </em><em>optional</em>) – Wavelength where a first scaling will be performed between template
and observed spectra. If not provided, the middle wavelength of the
osberved spectra will be considered.</p></li>
<li><p><strong>scale_range</strong> (<em>tuple</em><em>, </em><em>opt</em>) – If grid search, this parameter should be provided as a tuple of 3
floats: lower limit, upper limit and step of the grid search for the
scaling factor to be applied AFTER the first rough scaling (i.e.
scale_range should always encompass 1).</p></li>
<li><p><strong>ext_range</strong> (<em>tuple</em><em> or </em><em>None</em><em>, </em><em>opt</em>) – If None: differential extinction is not to be considered as a free
parameter. Elif a tuple of 3 floats is provided, differential extinction
will be considered, with the floats as lower limit, upper limit and step
of the grid search.
Note: if simplex search, the range is still used to set a chi of
np.inf outside of the range.</p></li>
<li><p><strong>dlbda_obs</strong> (<em>numpy 1d ndarray</em><em> or </em><em>list</em><em>, </em><em>optional</em>) – Spectral channel width for the observed spectrum. It should be provided
IF one wants to weigh each point based on the spectral
resolution of the respective instruments (as in Olofsson et al. 2016).</p></li>
<li><p><strong>instru_corr</strong> (<em>numpy 2d ndarray</em><em> or </em><em>list</em><em>, </em><em>optional</em>) – Spectral correlation throughout post-processed images in which the
spectrum is measured. It is specific to the combination of instrument,
algorithm and radial separation of the companion from the central star.
Can be computed using distances.spectral_correlation(). In case of
a spectrum obtained with different instruments, build it with
distances.combine_corrs(). If not provided, it will consider the
uncertainties in each spectral channels are independent. See Greco &amp;
Brandt (2017) for details.</p></li>
<li><p><strong>instru_fwhm</strong> (<em>float OR list of either floats</em><em> or </em><em>strings</em><em>, </em><em>optional</em>) – The instrumental spectral fwhm provided in nm. This is used to convolve
the model spectrum. If several instruments are used, provide a list of
instru_fwhm values, one for each instrument whose spectral resolution
is coarser than the model - including broad band filter FWHM if
relevant.
If strings are provided, they should correspond to filenames (including
full paths) of text files containing the filter information for each
observed wavelength. Strict format:</p></li>
<li><p><strong>instru_idx</strong> (<em>numpy 1d array</em><em>, </em><em>optional</em>) – 1d array containing an index representing each instrument used
to obtain the spectrum, label them from 0 to n_instru. Zero for points
that don’t correspond to any instru_fwhm provided above, and i in
[1,n_instru] for points associated to instru_fwhm[i-1]. This parameter
must be provided if the spectrum consists of points obtained with
different instruments.</p></li>
<li><p><strong>filter_reader</strong> (<em>python routine</em><em>, </em><em>optional</em>) – External routine that reads a filter file and returns a 2D numpy array,
where the first column corresponds to wavelengths, and the second
contains transmission values. Important: if not provided, but strings
are detected in instru_fwhm, the default file reader will be used.
It assumes the following format for the files:
- first row containing header
- starting from 2nd row: 1st column: wavelength, 2nd col.: transmission
- Unit of wavelength can be provided in parentheses of first header key
name: e.g. “WL(AA)” for angstrom, “wavelength(mu)” for micrometer or
“lambda(nm)” for nanometer. Note: Only what is in parentheses matters.
Important: filter files should all have the same format and WL units.</p></li>
<li><p><strong>simplex_options</strong> (<em>dict</em><em>, </em><em>optional</em>) – The scipy.optimize.minimize simplex (Nelder-Mead) options.</p></li>
<li><p><strong>red_chi2</strong> (<em>bool</em><em>, </em><em>optional</em>) – Whether to compute the reduced chi square. If False, considers chi^2.</p></li>
<li><p><strong>remove_nan</strong> (<em>bool</em><em>, </em><em>optional</em>) – Whether to remove NaN values from template spectrum BEFORE resampling
to the wavelength sampling of the observed spectrum. Whether it is set
to True or False, a check is made just before chi^2 is calculated
(after resampling), and only non-NaN values will be considered.</p></li>
<li><p><strong>nproc</strong> (<em>int</em><em>, </em><em>optional</em>) – The number of processes to use for parallelization.</p></li>
<li><p><strong>verbosity</strong> (<em>0</em><em>, </em><em>1</em><em> or </em><em>2</em><em>, </em><em>optional</em>) – Verbosity level. 0 for no output and 2 for full information.</p></li>
<li><p><strong>force_continue</strong> (<em>bool</em><em>, </em><em>optional</em>) – In case of issue with the fit, whether to continue regardless (this may
be useful in an uneven spectral library, where some templates have too
few points for the fit to be performed).</p></li>
<li><p><strong>**kwargs</strong> (<em>optional</em>) – Optional arguments to the scipy.optimize.minimize function</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>final_tmpname</strong> (<em>tuple of n_best str</em>) – Best-fit template filenames</p></li>
<li><p><strong>final_tmp</strong> (<em>tuple of n_best 3D numpy array</em>) – Best-fit template spectra (3D: lbda+spec+spec_err)</p></li>
<li><p><strong>final_chi</strong> (<em>1D numpy array of length n_best</em>) – Best-fit template chi^2</p></li>
<li><p><strong>final_params</strong> (<em>2D numpy array (2xn_best)</em>) – Best-fit parameters (optimal scaling and optical extinction). Note if
extinction is not fitted, optimal AV will be set to 0.</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="special.template_fit.get_chi">
<span class="sig-prename descclassname"><span class="pre">special.template_fit.</span></span><span class="sig-name descname"><span class="pre">get_chi</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">lbda_obs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">spec_obs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">err_obs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tmp_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tmp_reader</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">search_mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'simplex'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lambda_scal</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scale_range</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">(0.1,</span> <span class="pre">10,</span> <span class="pre">0.01)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ext_range</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dlbda_obs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">instru_corr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">instru_fwhm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">instru_idx</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">filter_reader</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">simplex_options</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">red_chi2</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">remove_nan</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">force_continue</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/special/template_fit.html#get_chi"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#special.template_fit.get_chi" title="Permalink to this definition"></a></dt>
<dd><p>Routine calculating chi^2, optimal scaling factor and optimal
extinction for a given template spectrum to match an observed spectrum.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>lbda_obs</strong> (<em>numpy 1d ndarray</em><em> or </em><em>list</em>) – Wavelength of observed spectrum. If several instruments, should be
ordered per instrument, not necessarily as monotonically increasing
wavelength. Hereafter, n_ch = len(lbda_obs).</p></li>
<li><p><strong>spec_obs</strong> (<em>numpy 1d ndarray</em><em> or </em><em>list</em>) – Observed spectrum for each value of lbda_obs.</p></li>
<li><p><strong>err_obs</strong> (<em>numpy 1d/2d ndarray</em><em> or </em><em>list</em>) – Uncertainties on the observed spectrum. If 2d array, should be [2,n_ch]
where the first (resp. second) column corresponds to lower (upper)
uncertainty, and n_ch is the length of lbda_obs and spec_obs.</p></li>
<li><p><strong>tmp_name</strong> (<em>str</em>) – Template spectrum filename.</p></li>
<li><p><strong>tmp_reader</strong> (<em>python routine</em>) – External routine that reads a model file and returns a 3D numpy array,
where the first column corresponds to wavelengths, the second
contains flux values, and the third the uncertainties on the flux.</p></li>
<li><p><strong>search_mode</strong> (<em>str</em><em>, </em><em>opt {'simplex'</em><em>, </em><em>'grid'}</em>) – How is the best fit template found? Simplex or grid search.</p></li>
<li><p><strong>lambda_scal</strong> (<em>float</em><em>, </em><em>optional</em>) – Wavelength where a first scaling will be performed between template
and observed spectra. If not provided, the middle wavelength of the
osberved spectra will be considered.</p></li>
<li><p><strong>scale_range</strong> (<em>tuple</em><em>, </em><em>opt</em>) – If grid search, this parameter should be provided as a tuple of 3
floats: lower limit, upper limit and step of the grid search for the
scaling factor to be applied AFTER the first rough scaling (i.e.
scale_range should always encompass 1).</p></li>
<li><p><strong>ext_range</strong> (<em>tuple</em><em> or </em><em>None</em><em>, </em><em>opt</em>) – If None: differential extinction is not to be considered as a free
parameter. Elif a tuple of 3 floats is provided, differential extinction
will be considered, with the floats as lower limit, upper limit and step
of the grid search.
Note: if simplex search, the range is still used to set a chi of
np.inf outside of the range.</p></li>
<li><p><strong>dlbda_obs</strong> (<em>numpy 1d ndarray</em><em> or </em><em>list</em><em>, </em><em>optional</em>) – Spectral channel width for the observed spectrum. It should be provided
IF one wants to weigh each point based on the spectral
resolution of the respective instruments (as in Olofsson et al. 2016).</p></li>
<li><p><strong>instru_corr</strong> (<em>numpy 2d ndarray</em><em> or </em><em>list</em><em>, </em><em>optional</em>) – Spectral correlation throughout post-processed images in which the
spectrum is measured. It is specific to the combination of instrument,
algorithm and radial separation of the companion from the central star.
Can be computed using distances.spectral_correlation(). In case of
a spectrum obtained with different instruments, build it with
distances.combine_corrs(). If not provided, it will consider the
uncertainties in each spectral channels are independent. See Greco &amp;
Brandt (2017) for details.</p></li>
<li><p><strong>instru_fwhm</strong> (<em>float</em><em> or </em><em>list</em><em>, </em><em>optional</em>) – The instrumental spectral fwhm provided in nm. This is used to convolve
the model spectrum. If several instruments are used, provide a list of
instru_fwhm values, one for each instrument whose spectral resolution
is coarser than the model - including broad band
filter FWHM if relevant.</p></li>
<li><p><strong>instru_idx</strong> (<em>numpy 1d array</em><em>, </em><em>optional</em>) – 1d array containing an index representing each instrument used
to obtain the spectrum, label them from 0 to n_instru. Zero for points
that don’t correspond to any instru_fwhm provided above, and i in
[1,n_instru] for points associated to instru_fwhm[i-1]. This parameter
must be provided if the spectrum consists of points obtained with
different instruments.</p></li>
<li><p><strong>filter_reader</strong> (<em>python routine</em><em>, </em><em>optional</em>) – External routine that reads a filter file and returns a 2D numpy array,
where the first column corresponds to wavelengths, and the second
contains transmission values. Important: if not provided, but strings
are detected in instru_fwhm, the default format assumed for the files:
- first row containing header
- starting from 2nd row: 1st column: WL in mu, 2nd column: transmission
Note: files should all have the same format and wavelength units.</p></li>
<li><p><strong>red_chi2</strong> (<em>bool</em><em>, </em><em>optional</em>) – Whether to compute the reduced chi square. If False, considers chi^2.</p></li>
<li><p><strong>remove_nan</strong> (<em>bool</em><em>, </em><em>optional</em>) – Whether to remove NaN values from template spectrum BEFORE resampling
to the wavelength sampling of the observed spectrum. Whether it is set
to True or False, a check is made just before chi^2 is calculated
(after resampling), and only non-NaN values will be considered.</p></li>
<li><p><strong>simplex_options</strong> (<em>dict</em><em>, </em><em>optional</em>) – The scipy.optimize.minimize simplex (Nelder-Mead) options.</p></li>
<li><p><strong>force_continue</strong> (<em>bool</em><em>, </em><em>optional</em>) – In case of issue with the fit, whether to continue regardless (this may
be useful in an uneven spectral library, where some templates have too
few points for the fit to be performed).</p></li>
<li><p><strong>verbose</strong> (<em>str</em><em>, </em><em>optional</em>) – Whether to print more information when fit fails.</p></li>
<li><p><strong>**kwargs</strong> (<em>optional</em>) – Optional arguments to the scipy.optimize.minimize function.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>best_chi</strong> (<em>float</em>) – goodness of fit scored by the template</p></li>
<li><p><em>best_scal</em> – best-fit scaling factor for the considered template</p></li>
<li><p><em>best_ext</em> – best-fit optical extinction for the considered template</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-special.utils_mcmc">
<span id="special-utils-mcmc"></span><h1>special.utils_mcmc<a class="headerlink" href="#module-special.utils_mcmc" title="Permalink to this headline"></a></h1>
<p>Module with utility functions to the MCMC (<code class="docutils literal notranslate"><span class="pre">emcee</span></code>) sampling for
parameter estimation.</p>
<dl class="py function">
<dt class="sig sig-object py" id="special.utils_mcmc.auto_window">
<span class="sig-prename descclassname"><span class="pre">special.utils_mcmc.</span></span><span class="sig-name descname"><span class="pre">auto_window</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">taus</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">c</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/special/utils_mcmc.html#auto_window"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#special.utils_mcmc.auto_window" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="special.utils_mcmc.autocorr">
<span class="sig-prename descclassname"><span class="pre">special.utils_mcmc.</span></span><span class="sig-name descname"><span class="pre">autocorr</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">c</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">5.0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/special/utils_mcmc.html#autocorr"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#special.utils_mcmc.autocorr" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="special.utils_mcmc.autocorr_func_1d">
<span class="sig-prename descclassname"><span class="pre">special.utils_mcmc.</span></span><span class="sig-name descname"><span class="pre">autocorr_func_1d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">norm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/special/utils_mcmc.html#autocorr_func_1d"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#special.utils_mcmc.autocorr_func_1d" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="special.utils_mcmc.autocorr_test">
<span class="sig-prename descclassname"><span class="pre">special.utils_mcmc.</span></span><span class="sig-name descname"><span class="pre">autocorr_test</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">chain</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/special/utils_mcmc.html#autocorr_test"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#special.utils_mcmc.autocorr_test" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="special.utils_mcmc.gelman_rubin">
<span class="sig-prename descclassname"><span class="pre">special.utils_mcmc.</span></span><span class="sig-name descname"><span class="pre">gelman_rubin</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/special/utils_mcmc.html#gelman_rubin"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#special.utils_mcmc.gelman_rubin" title="Permalink to this definition"></a></dt>
<dd><p>Determine the Gelman-Rubin hat{R} statistical test between Markov chains.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>x</strong> (<em>numpy.array</em>) – The numpy.array on which the Gelman-Rubin test is applied. This array
should contain at least 2 set of data, i.e. x.shape &gt;= (2,).</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>out</strong> – The Gelman-Rubin hat{R}.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span><span class="mf">1.0</span><span class="p">,(</span><span class="mi">1</span><span class="p">,</span><span class="mi">100</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="mf">0.1</span><span class="p">,</span><span class="mf">1.3</span><span class="p">,(</span><span class="mi">1</span><span class="p">,</span><span class="mi">100</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">x1</span><span class="p">,</span><span class="n">x2</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gelman_rubin</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">1.0366629898991262</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gelman_rubin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">x1</span><span class="p">,</span><span class="n">x1</span><span class="p">)))</span>
<span class="go">0.99</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="special.utils_mcmc.gelman_rubin_from_chain">
<span class="sig-prename descclassname"><span class="pre">special.utils_mcmc.</span></span><span class="sig-name descname"><span class="pre">gelman_rubin_from_chain</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">chain</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">burnin</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/special/utils_mcmc.html#gelman_rubin_from_chain"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#special.utils_mcmc.gelman_rubin_from_chain" title="Permalink to this definition"></a></dt>
<dd><p>Pack the MCMC chain and determine the Gelman-Rubin hat{R} statistical
test. In other words, two sub-sets are extracted from the chain (burnin
parts are taken into account) and the Gelman-Rubin statistical test is
performed.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>chain</strong> (<em>numpy.array</em>) – The MCMC chain with the shape walkers x steps x model_parameters</p></li>
<li><p><strong>burnin</strong> (<em>float in</em><em> [</em><em>0</em><em>,</em><em>1</em><em>]</em>) – The fraction of a walker which is discarded.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>out</strong> – The Gelman-Rubin hat{R}.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-special.utils_spec">
<span id="special-utils-spec"></span><h1>special.utils_spec<a class="headerlink" href="#module-special.utils_spec" title="Permalink to this headline"></a></h1>
<p>Utility functions for spectral fitting.</p>
<dl class="py function">
<dt class="sig sig-object py" id="special.utils_spec.akaike">
<span class="sig-prename descclassname"><span class="pre">special.utils_spec.</span></span><span class="sig-name descname"><span class="pre">akaike</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">LnL</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">k</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/special/utils_spec.html#akaike"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#special.utils_spec.akaike" title="Permalink to this definition"></a></dt>
<dd><p>Computes the Akaike Information Criterion: 2k-2ln(L),
where k is the number of estimated parameters in the model and LnL is the
max ln-likelihood for the model.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>LnL</strong> (<em>float</em>) – Max ln-likelihood for the considered model.</p></li>
<li><p><strong>k</strong> (<em>int</em>) – Number of estimated parameters in the model.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>aic</strong> – Akaike Information Criterion</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="special.utils_spec.blackbody">
<span class="sig-prename descclassname"><span class="pre">special.utils_spec.</span></span><span class="sig-name descname"><span class="pre">blackbody</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">lbda</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">T</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/special/utils_spec.html#blackbody"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#special.utils_spec.blackbody" title="Permalink to this definition"></a></dt>
<dd><p>Planck function. Returns specific intensity for an input wavelength vector
lbda (in micrometers) and a given input temperature.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>lbda</strong> (<em>numpy array</em>) – 1d numpy array corresponding to the wavelengths (in microns) for the
desired output specific intensities.</p></li>
<li><p><strong>T</strong> (<em>float</em>) – Temperature</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>B_lambda</strong> – Specific intensity corresponding to the Planck function.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="special.utils_spec.combine_spec_corrs">
<span class="sig-prename descclassname"><span class="pre">special.utils_spec.</span></span><span class="sig-name descname"><span class="pre">combine_spec_corrs</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">arr_list</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/special/utils_spec.html#combine_spec_corrs"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#special.utils_spec.combine_spec_corrs" title="Permalink to this definition"></a></dt>
<dd><p>Combines the spectral correlation matrices of different instruments
into a single square matrix (required for input of spectral fit).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>arr_list</strong> (<em>list</em><em> or </em><em>tuple of numpy ndarrays</em>) – List/tuple containing the distinct square spectral correlation matrices
OR ones (for independent photometric measurements).</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>combi_corr</strong> – 2d square ndarray representing the combined spectral correlation.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>numpy 2d ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="special.utils_spec.convert_F_units">
<span class="sig-prename descclassname"><span class="pre">special.utils_spec.</span></span><span class="sig-name descname"><span class="pre">convert_F_units</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">F</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lbda</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">in_unit</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'cgs'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out_unit</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'si'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/special/utils_spec.html#convert_F_units"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#special.utils_spec.convert_F_units" title="Permalink to this definition"></a></dt>
<dd><p>Function to convert Flux density between [ergs s-1 cm-2 um-1],
[W m-2 um-1] and [Jy].</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>F</strong> (<em>float</em><em> or </em><em>1d array</em>) – Flux</p></li>
<li><p><strong>lbda</strong> (<em>float</em><em> or </em><em>1d array</em>) – Wavelength of the flux (in um)</p></li>
<li><p><strong>in_unit</strong> (<em>str</em><em>, </em><em>opt</em><em>, </em><em>{&quot;si&quot;</em><em>, </em><em>&quot;cgs&quot;</em><em>, </em><em>&quot;jy&quot;</em><em>, </em><em>&quot;cgsA&quot;}</em>) – Input flux units.
‘si’: W/m^2/mu;
‘cgs’: ergs/s/cm^2/mu
‘jy’: janskys
‘cgsA’: erg/s/cm^2/AA</p></li>
<li><p><strong>out_unit</strong> (<em>str</em><em>, </em><em>opt {&quot;si&quot;</em><em>, </em><em>&quot;cgs&quot;</em><em>, </em><em>&quot;jy&quot;}</em>) – Output flux units.</p></li>
</ul>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>Flux in output units.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="special.utils_spec.convert_F_vs_mag">
<span class="sig-prename descclassname"><span class="pre">special.utils_spec.</span></span><span class="sig-name descname"><span class="pre">convert_F_vs_mag</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">value</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">F_0</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">band</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'H'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">system</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'Johnson'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">conversion</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'to_mag'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/special/utils_spec.html#convert_F_vs_mag"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#special.utils_spec.convert_F_vs_mag" title="Permalink to this definition"></a></dt>
<dd><p>Function to convert Flux density (in Jy) to magnitude in a given band, or
the opposite.</p>
<dl class="simple">
<dt>Sources for zero points:</dt><dd><ul class="simple">
<li><p>TOKUNAGA chapter on IR astronomy (from Cohen 1992)</p></li>
<li><p>UKIRT webpage:         (<a class="reference external" href="http://www.jach.hawaii.edu/UKIRT/astronomy/calib/phot_cal/conver.html">http://www.jach.hawaii.edu/UKIRT/astronomy/calib/phot_cal/conver.html</a>)</p></li>
<li><p>van der Bliek et al. 1996 (ESO standard stars)</p></li>
</ul>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>value</strong> (<em>float</em>) – Flux or magnitude to be converted.</p></li>
<li><p><strong>F_0</strong> (<em>float</em><em>, </em><em>opt</em>) – Zero-point flux. If provided will take precedence over band.</p></li>
<li><p><strong>band</strong> (<em>str</em><em>, </em><em>opt</em>) – Band of the given flux or magnitude. Choice between: {‘U’,’B’,’V’, ‘R’,
‘I’, ‘J’, ‘H’, ‘K’, “L”, “L’”, ‘M’, ‘N’, ‘O’}
(but not for all band systems).</p></li>
<li><p><strong>system</strong> (<em>str</em><em>, </em><em>opt</em>) – Band system. Choice between: {‘Johnson;,’2MASS’, ‘UKIRT’, ‘ESO’}</p></li>
<li><p><strong>conversion</strong> (<em>str</em><em>, </em><em>opt</em>) – In which sense to convert: flux to mag (‘to_mag’) or mag to flux
(‘to_flux’)</p></li>
</ul>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>Converted flux or magnitude.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="special.utils_spec.extinction">
<span class="sig-prename descclassname"><span class="pre">special.utils_spec.</span></span><span class="sig-name descname"><span class="pre">extinction</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">lbda</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">AV</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">RV</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">3.1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/special/utils_spec.html#extinction"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#special.utils_spec.extinction" title="Permalink to this definition"></a></dt>
<dd><p>Calculates the A(lambda) extinction for a given combination of A_V and R_V.
If R_V is not provided, assumes an ISM value of R_V=3.1
Uses the Cardelli et al. (1989) empirical formulas.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>lbda</strong> (<em>1d np.ndarray</em>) – Array with the wavelengths (um) for which the extinction is calculated.</p></li>
<li><p><strong>AV</strong> (<em>float</em>) – Extinction (mag) in the V band.</p></li>
<li><p><strong>RV</strong> (<em>float</em><em>, </em><em>opt</em>) – Reddening in the V band: R_V = A_V / E(B-V)</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>Albda</strong> – Extinction (mag) at wavelengths lbda.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>1d np.ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="special.utils_spec.find_nearest">
<span class="sig-prename descclassname"><span class="pre">special.utils_spec.</span></span><span class="sig-name descname"><span class="pre">find_nearest</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">array</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">value</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">output</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'index'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">constraint</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/special/utils_spec.html#find_nearest"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#special.utils_spec.find_nearest" title="Permalink to this definition"></a></dt>
<dd><p>Function to find the indices, and optionally the values, of an array’s n
closest elements to a certain value.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>array</strong> (<em>1d numpy array</em><em> or </em><em>list</em>) – Array in which to check the closest element to value.</p></li>
<li><p><strong>value</strong> (<em>float</em>) – Value for which the algorithm searches for the n closest elements in
the array.</p></li>
<li><p><strong>output</strong> (<em>str</em><em>, </em><em>opt {'index'</em><em>,</em><em>'value'</em><em>,</em><em>'both' }</em>) – Set what is returned</p></li>
<li><p><strong>constraint</strong> (<em>str</em><em>, </em><em>opt {None</em><em>, </em><em>'ceil'</em><em>, </em><em>'floor'}</em>) – If not None, will check for the closest element larger than value (ceil)
or closest element smaller than value (floor).</p></li>
<li><p><strong>n</strong> (<em>int</em><em>, </em><em>opt</em>) – Number of elements to be returned, sorted by proximity to the values.
Default: only the closest value is returned.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><em>Either</em> – (output=’index’): index/indices of the closest n value(s) in the array;
(output=’value’): the closest n value(s) in the array,
(output=’both’): closest value(s) and index/-ices, respectively.</p></li>
<li><p><em>By default, only returns the index/indices.</em></p></li>
<li><p><strong>Possible constraints</strong> (<em>‘ceil’, ‘floor’, None (“ceil” will return the closest</em>)</p></li>
<li><p><em>element with a value greater than ‘value’, “floor” the opposite)</em></p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="special.utils_spec.inject_em_line">
<span class="sig-prename descclassname"><span class="pre">special.utils_spec.</span></span><span class="sig-name descname"><span class="pre">inject_em_line</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">wl</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">flux</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lbda</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">spec</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">width</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">height</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">em</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/special/utils_spec.html#inject_em_line"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#special.utils_spec.inject_em_line" title="Permalink to this definition"></a></dt>
<dd><p>Injects an emission (or absorption) line in a spectrum.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>wl</strong> (<em>float</em>) – Wavelength of the line</p></li>
<li><p><strong>flux</strong> (<em>float</em>) – Flux of the line to be injected</p></li>
<li><p><strong>lbda</strong> (<em>1d np.ndarray</em>) – Array with the wavelengths (um) of the input spectrum.</p></li>
<li><p><strong>spec</strong> (<em>1d np.ndarray</em>) – Input spectrum fluxes</p></li>
<li><p><strong>width</strong> (<em>float</em><em>, </em><em>opt</em>) – Full width of the line in mu (see also height). The line will be
injected assuming a gaussian profile. If not provided, the width will
be set to the ‘equivalent width’ of the line.</p></li>
<li><p><strong>height</strong> (<em>float</em><em>, </em><em>opt</em>) – Ratio to peak where the line width is considered. E.g. if
height=10%, the width will be the full width at 10% maximum.</p></li>
<li><p><strong>em</strong> (<em>bool</em><em>, </em><em>opt</em>) – Whether emission (True) or absorption (False) line.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>spec</strong> – Spectrum with the injected line</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>1d np.ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="special.utils_spec.mj_from_rj_and_logg">
<span class="sig-prename descclassname"><span class="pre">special.utils_spec.</span></span><span class="sig-name descname"><span class="pre">mj_from_rj_and_logg</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rp</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">logg</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/special/utils_spec.html#mj_from_rj_and_logg"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#special.utils_spec.mj_from_rj_and_logg" title="Permalink to this definition"></a></dt>
<dd><p>Estimates a planet mass in Jupiter mass for a given radius in Jupiter
radius and the log of the surface gravity.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>rp</strong> (<em>float</em>) – Planet radius in Jupiter radii</p></li>
<li><p><strong>logg</strong> (<em>float</em>) – Log of the surface gravity</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>mj</strong> – Planet mass in Jupiter masses</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="special.utils_spec.nrefrac">
<span class="sig-prename descclassname"><span class="pre">special.utils_spec.</span></span><span class="sig-name descname"><span class="pre">nrefrac</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">wavelength</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">density</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/special/utils_spec.html#nrefrac"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#special.utils_spec.nrefrac" title="Permalink to this definition"></a></dt>
<dd><p>Calculates refractive index of air from Cauchy formula.
For comparisong to measurements from the ground, the wavelenghts of model
spectra must be slightly shifted using:
lbda_shift = lbda_model/(1+(nrefrac*1e-6))</p>
<p>Input: wavelength in Angstrom,
Returns N = (n-1) * 1.e6.
Credit: France Allard.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>wavelength</strong> (<em>numpy array</em>) – 1d numpy array corresponding to the wavelengths of the input spectrum
in Angstrom</p></li>
<li><p><strong>density</strong> (<em>float</em>) – density of air in amagat (relative to STP, e.g. ~10% decrease per 1000m
above sea level).</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>N</strong> – Refractive index</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

</div>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="about.html" class="btn btn-neutral float-left" title="Contributions" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2019-2022, Valentin Christiaens.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>