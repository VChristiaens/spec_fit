<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>special package &mdash; special  documentation</title>
      <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
        <script>window.MathJax = {"tex": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true}, "options": {"ignoreHtmlClass": "tex2jax_ignore|mathjax_ignore|document", "processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
        <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="author" title="About these documents" href="about.html" />
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="prev" title="Contributions" href="about.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="index.html">
            <img src="_static/Special_logo.jpeg" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Getting started</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="features.html">What makes it <cite>special</cite>?</a></li>
<li class="toctree-l1"><a class="reference internal" href="trimmed_readme.html">TL;DR setup guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="trimmed_readme.html#installation-and-dependencies">Installation and dependencies</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Tutorial</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="tutorials/walkthrough.html"><em>special</em> tutorial</a></li>
<li class="toctree-l1"><a class="reference internal" href="tutorials/walkthrough.html#1.-Loading-the-data">1. Loading the data</a></li>
<li class="toctree-l1"><a class="reference internal" href="tutorials/walkthrough.html#2.-Spectral-correlation-matrix">2. Spectral correlation matrix</a></li>
<li class="toctree-l1"><a class="reference internal" href="tutorials/walkthrough.html#3.-Preliminary-spectral-analysis">3. Preliminary spectral analysis</a></li>
<li class="toctree-l1"><a class="reference internal" href="tutorials/walkthrough.html#4.-MCMC-sampler-examples">4. MCMC sampler examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="tutorials/walkthrough.html#5.-Comparison-of-results">5. Comparison of results</a></li>
<li class="toctree-l1"><a class="reference internal" href="tutorials/walkthrough.html#6.-Nested-sampler-examples">6. Nested sampler examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="tutorials/walkthrough.html#7.-Best-fit-template-spectrum">7. Best-fit template spectrum</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">About</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="about.html">Contributions</a></li>
<li class="toctree-l1"><a class="reference internal" href="about.html#questions-and-suggestions">Questions and suggestions</a></li>
<li class="toctree-l1"><a class="reference internal" href="about.html#acknowledgements">Acknowledgements</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Package content</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="current reference internal" href="#">special package</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#submodules">Submodules</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-special.chi">special.chi module</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-special.config">special.config module</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-special.fits">special.fits module</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-special.mcmc_sampling">special.mcmc_sampling module</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-special.model_resampling">special.model_resampling module</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-special.nested_sampling">special.nested_sampling module</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-special.spec_corr">special.spec_corr module</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-special.spec_indices">special.spec_indices module</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-special.template_fit">special.template_fit module</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-special.utils_mcmc">special.utils_mcmc module</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-special.utils_nested">special.utils_nested module</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-special.utils_spec">special.utils_spec module</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-special">Module contents</a></li>
</ul>
</li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">special</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
      <li>special package</li>
      <li class="wy-breadcrumbs-aside">
              <a href="https://github.com/VChristiaens/special/blob/main/docs/special.rst" class="fa fa-github"> Edit on GitHub</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  
<style>
/* CSS overrides for sphinx_rtd_theme */

/* 24px margin */
.nbinput.nblast.container,
.nboutput.nblast.container {
    margin-bottom: 19px;  /* padding has already 5px */
}

/* ... except between code cells! */
.nblast.container + .nbinput.container {
    margin-top: -19px;
}

.admonition > p:before {
    margin-right: 4px;  /* make room for the exclamation icon */
}

/* Fix math alignment, see https://github.com/rtfd/sphinx_rtd_theme/pull/686 */
.math {
    text-align: unset;
}
</style>
<section id="special-package">
<h1>special package<a class="headerlink" href="#special-package" title="Permalink to this headline"></a></h1>
<section id="submodules">
<h2>Submodules<a class="headerlink" href="#submodules" title="Permalink to this headline"></a></h2>
</section>
<section id="module-special.chi">
<span id="special-chi-module"></span><h2>special.chi module<a class="headerlink" href="#module-special.chi" title="Permalink to this headline"></a></h2>
<p>Function defining the goodness of fit.</p>
<dl class="citation">
<dt class="label" id="olo16"><span class="brackets">OLO16</span><span class="fn-backref">(<a href="#id1">1</a>,<a href="#id3">2</a>,<a href="#id5">3</a>,<a href="#id7">4</a>,<a href="#id9">5</a>,<a href="#id13">6</a>,<a href="#id16">7</a>,<a href="#id17">8</a>,<a href="#id18">9</a>,<a href="#id24">10</a>,<a href="#id41">11</a>,<a href="#id43">12</a>)</span></dt>
<dd><div class="line-block">
<div class="line">Olofsson et al. 2016</div>
<div class="line"><strong>Azimuthal asymmetries in the debris disk around HD 61005. A massive collision of planetesimals?</strong></div>
<div class="line"><em>Astronomy &amp; Astrophysics, Volume 591, p. 108</em></div>
<div class="line"><a class="reference external" href="https://arxiv.org/abs/1601.07861">https://arxiv.org/abs/1601.07861</a></div>
</div>
</dd>
<dt class="label" id="gre16"><span class="brackets">GRE16</span><span class="fn-backref">(<a href="#id2">1</a>,<a href="#id4">2</a>,<a href="#id6">3</a>,<a href="#id8">4</a>,<a href="#id10">5</a>,<a href="#id14">6</a>,<a href="#id25">7</a>,<a href="#id29">8</a>,<a href="#id42">9</a>,<a href="#id44">10</a>)</span></dt>
<dd><div class="line-block">
<div class="line">Greco &amp; Brandt 2016</div>
<div class="line"><strong>The Measurement, Treatment, and Impact of Spectral Covariance and
Bayesian Priors in Integral-field Spectroscopy of Exoplanets</strong></div>
<div class="line"><em>The Astrophysical Journal, Volume 833, Issue 1, p. 134</em></div>
<div class="line"><a class="reference external" href="https://arxiv.org/abs/1602.00691">https://arxiv.org/abs/1602.00691</a></div>
</div>
</dd>
</dl>
<dl class="py function">
<dt class="sig sig-object py" id="special.chi.gof_scal">
<span class="sig-prename descclassname"><span class="pre">special.chi.</span></span><span class="sig-name descname"><span class="pre">gof_scal</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">params</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lbda_obs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">spec_obs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">err_obs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lbda_tmp</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">spec_tmp</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dlbda_obs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">instru_corr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">instru_res</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">instru_idx</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_weights</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">filter_reader</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ext_range</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/special/chi.html#gof_scal"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#special.chi.gof_scal" title="Permalink to this definition"></a></dt>
<dd><p>Wrapper of routine <code class="docutils literal notranslate"><span class="pre">special.chi.goodness_of_fit</span></code> for the goodness of
fit used to search for the best-fit library template spectrum to an observed
spectrum. It has a <code class="docutils literal notranslate"><span class="pre">params</span></code> argument to consider the scaling factor and
optionnally the differential extinction as free parameter(s).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>params</strong> (<em>tuple</em>) – Tuple of 1 or 2 elements: scaling factor and (optionally) differential
optical extinction <span class="math notranslate nohighlight">\(\Delta A_V\)</span> (<span class="math notranslate nohighlight">\(\Delta A_V\)</span> can be
negative if template spectra are not dereddened).</p></li>
<li><p><strong>lbda_obs</strong> (<em>numpy 1d ndarray</em><em> or </em><em>list</em>) – Wavelengths of observed spectrum. If several instruments were used, the
wavelengths should be ordered per instrument, not necessarily as
monotonically increasing wavelength. Hereafter, <span class="math notranslate nohighlight">\(n_{ch}\)</span> is the
length of <code class="docutils literal notranslate"><span class="pre">lbda_obs</span></code>.</p></li>
<li><p><strong>spec_obs</strong> (<em>numpy 1d ndarray</em><em> or </em><em>list</em>) – Observed spectrum for each value of <code class="docutils literal notranslate"><span class="pre">lbda_obs</span></code>. Should have a length
of <span class="math notranslate nohighlight">\(n_{ch}\)</span>.</p></li>
<li><p><strong>err_obs</strong> (<em>numpy 1d/2d ndarray</em><em> or </em><em>list</em>) – Uncertainties on the observed spectrum. The array (list) can have either a
length of <span class="math notranslate nohighlight">\(n_{ch}\)</span>, or a shape of <span class="math notranslate nohighlight">\((2,n_{ch})\)</span> for lower
(first column) and upper (second column) uncertainties provided.</p></li>
<li><p><strong>lbda_tmp</strong> (<em>numpy 1d ndarray</em><em> or </em><em>list</em>) – Wavelengths of tested template. Should have a wider wavelength extent
than the observed spectrum.</p></li>
<li><p><strong>spec_tmp</strong> (<em>numpy 1d ndarray</em>) – Template spectrum. It does not require the same wavelength sampling as
the observed spectrum. If higher spectral resolution, it will be
convolved with the instrumental spectral PSF (if <code class="docutils literal notranslate"><span class="pre">instru_res</span></code> is
provided) and then binned to the same sampling. If lower spectral
resolution, a linear interpolation is performed to infer the value at
the observed spectrum wavelength sampling.</p></li>
<li><p><strong>dlbda_obs</strong> (<em>numpy 1d ndarray</em><em> or </em><em>list</em><em>, </em><em>optional</em>) – Respective spectral channel width or FWHM of the photometric filters
used for each point of the observed spectrum. This vector is used to
infer which part(s) of a combined spectro+photometric spectrum should
involve convolution+subsampling (model resolution higher than
measurements), interpolation (the opposite), or convolution by the
transmission curve of a photometric filter. If not provided, it will be
inferred from the difference between consecutive lbda_obs points (i.e.
inaccurate for a combined spectrum). It must be provided IF one wants to
weigh each measurement based on the spectral resolution of each
instrument (as in <a class="reference internal" href="#olo16" id="id1"><span>[OLO16]</span></a>), through the <code class="docutils literal notranslate"><span class="pre">use_weights</span></code> argument.</p></li>
<li><p><strong>instru_corr</strong> (<em>numpy 2d ndarray</em><em>, </em><em>optional</em>) – Spectral correlation between post-processed images in which the
spectrum is measured. It is specific to the instrument, PSF subtraction
algorithm and radial separation of the companion from the central star.
Can be computed using <code class="docutils literal notranslate"><span class="pre">special.spec_corr.spectral_correlation</span></code>. In
case of a spectrum obtained with different instruments, it is
recommended to construct the final spectral_correlation matrix with
<code class="docutils literal notranslate"><span class="pre">special.spec_corr.combine_corrs</span></code>. If <code class="docutils literal notranslate"><span class="pre">instru_corr</span></code> is not provided,
the uncertainties in each spectral channel will be considered
independent. See <a class="reference internal" href="#gre16" id="id2"><span>[GRE16]</span></a> for more details.</p></li>
<li><p><strong>instru_res</strong> (<em>float</em><em> or </em><em>list of floats/strings</em><em>, </em><em>optional</em>) – The mean instrumental resolving power(s) OR filter names. This is
used to convolve the model spectrum. If several instruments are used,
provide a list of resolving power values / filter names, one for
each instrument used.</p></li>
<li><p><strong>instru_idx</strong> (<em>numpy 1d array</em><em>, </em><em>optional</em>) – 1d array containing an index representing each instrument used
to obtain the spectrum, label them from 0 to the number of instruments
(<span class="math notranslate nohighlight">\(n_{ins}\)</span>). Zero for points that don’t correspond to any of the
<code class="docutils literal notranslate"><span class="pre">instru_res</span></code> values provided, and i in <span class="math notranslate nohighlight">\([1,n_{ins}]\)</span> for points
associated to instru_res[i-1]. This parameter must be provided if the
spectrum consists of points obtained with different instruments.</p></li>
<li><p><strong>use_weights</strong> (<em>bool</em><em>, </em><em>optional</em>) – For the likelihood calculation, whether to weigh each point of the
spectrum based on the spectral resolution or bandwidth of photometric
filters used. Weights will be proportional to <code class="docutils literal notranslate"><span class="pre">dlbda_obs/lbda_obs</span></code> if
<code class="docutils literal notranslate"><span class="pre">dlbda_obs</span></code> is provided, or set to 1 for all points otherwise.</p></li>
<li><p><strong>filter_reader</strong> (<em>python routine</em><em>, </em><em>optional</em>) – <p>External routine that reads a filter file and returns a 2D numpy array,
where the first column corresponds to wavelengths, and the second
contains transmission values. Important: if not provided, but strings
are detected in instru_res, the default file reader will be used.
It assumes the following format for the files:</p>
<ul>
<li><p>first row contains headers (titles of each column)</p></li>
<li><p>starting from 2nd row: 1st column: wavelength, 2nd col.: transmission</p></li>
<li><p>Unit of wavelength can be provided in parentheses of first header         key name: e.g. “WL(AA)” for angstrom, “wavelength(mu)” for micrometer         or “lambda(nm)” for nanometer. Note: only what is in parentheses         matters for the units.</p></li>
</ul>
</p></li>
<li><p><strong>ext_range</strong> (<em>tuple</em><em> or </em><em>None</em><em>, </em><em>opt</em>) – <ul>
<li><p>If None: differential extinction is not considered as a free parameter.</p></li>
<li><p>If a tuple: it should contain 2 floats (for simplex         <code class="docutils literal notranslate"><span class="pre">search_mode</span></code>) or 3 floats (for grid search <code class="docutils literal notranslate"><span class="pre">search_mode</span></code>)         corresponding to the lower limit, upper limit (and step for the grid         search). For the simplex search, the lower and upper limits are used         to set a chi square of infinity outside of the range.</p></li>
</ul>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>chi_sq</strong> – Goodness of fit indicator.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If several filter filenames are provided in <code class="docutils literal notranslate"><span class="pre">instru_res</span></code>, the filter files
must all have the same format and wavelength units (for reading by the same
<code class="docutils literal notranslate"><span class="pre">filter_reader</span></code> snippet or default function).</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="special.chi.goodness_of_fit">
<span class="sig-prename descclassname"><span class="pre">special.chi.</span></span><span class="sig-name descname"><span class="pre">goodness_of_fit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">lbda_obs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">spec_obs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">err_obs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lbda_mod</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">spec_mod</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dlbda_obs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">instru_corr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">instru_res</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">instru_idx</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_weights</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">filter_reader</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">plot</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">outfile</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/special/chi.html#goodness_of_fit"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#special.chi.goodness_of_fit" title="Permalink to this definition"></a></dt>
<dd><p>Function to estimate the goodness of fit indicator defined as in
<a class="reference internal" href="#olo16" id="id3"><span>[OLO16]</span></a> (Eq. 8). In addition, if a spectral correlation matrix is provided,
it is used to take into account the correlated noise between spectral
channels (see <a class="reference internal" href="#gre16" id="id4"><span>[GRE16]</span></a>). The goodness of fit indicator is identical to a
<span class="math notranslate nohighlight">\(\chi^2\)</span> if all points are obtained with the same instrument (or
<code class="docutils literal notranslate"><span class="pre">use_weights</span></code> set to False) and in absence of spectrally correlated noise.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>lbda_obs</strong> (<em>numpy 1d ndarray</em><em> or </em><em>list</em>) – Wavelengths of observed spectrum. If several instruments were used, the
wavelengths should be ordered per instrument, not necessarily as
monotonically increasing wavelength. Hereafter, <span class="math notranslate nohighlight">\(n_{ch}\)</span> is the
length of <code class="docutils literal notranslate"><span class="pre">lbda_obs</span></code>.</p></li>
<li><p><strong>spec_obs</strong> (<em>numpy 1d ndarray</em><em> or </em><em>list</em>) – Observed spectrum for each value of <code class="docutils literal notranslate"><span class="pre">lbda_obs</span></code>. Should have a length
of <span class="math notranslate nohighlight">\(n_{ch}\)</span>.</p></li>
<li><p><strong>err_obs</strong> (<em>numpy 1d/2d ndarray</em><em> or </em><em>list</em>) – Uncertainties on the observed spectrum. The array (list) can have either
a length of <span class="math notranslate nohighlight">\(n_{ch}\)</span>, or a shape of <span class="math notranslate nohighlight">\((2,n_{ch})\)</span> for lower
(first column) and upper (second column) uncertainties provided.</p></li>
<li><p><strong>lbda_mod</strong> (<em>numpy 1d ndarray</em><em> or </em><em>list</em>) – Wavelengths of tested model. Should have a wider (or equal) wavelength
extent than the observed spectrum.</p></li>
<li><p><strong>spec_mod</strong> (<em>numpy 1d ndarray</em>) – Model spectrum. It does not require the same wavelength sampling as
the observed spectrum. If higher spectral resolution, it will be
convolved with the instrumental spectral PSF (if <code class="docutils literal notranslate"><span class="pre">instru_res</span></code> is
provided) and then binned to the same sampling. If lower spectral
resolution, a linear interpolation is performed to infer the value at
the observed spectrum wavelength sampling.</p></li>
<li><p><strong>dlbda_obs</strong> (<em>numpy 1d ndarray</em><em> or </em><em>list</em><em>, </em><em>optional</em>) – Respective spectral channel width or FWHM of the photometric filters
used for each point of the observed spectrum. This vector is used to
infer which part(s) of a combined spectro+photometric spectrum should
involve convolution+subsampling (model resolution higher than
measurements), interpolation (the opposite), or convolution by the
transmission curve of a photometric filter. If not provided, it will be
inferred from the difference between consecutive lbda_obs points (i.e.
inaccurate for a combined spectrum). It must be provided IF one wants to
weigh each measurement based on the spectral resolution of each
instrument (as in <a class="reference internal" href="#olo16" id="id5"><span>[OLO16]</span></a>), through the <code class="docutils literal notranslate"><span class="pre">use_weights</span></code> argument.</p></li>
<li><p><strong>instru_corr</strong> (<em>numpy 2d ndarray</em><em>, </em><em>optional</em>) – Spectral correlation between post-processed images in which the
spectrum is measured. It is specific to the instrument, PSF subtraction
algorithm and radial separation of the companion from the central star.
Can be computed using <code class="docutils literal notranslate"><span class="pre">special.spec_corr.spectral_correlation</span></code>. In
case of a spectrum obtained with different instruments, it is
recommended to construct the final spectral_correlation matrix with
<code class="docutils literal notranslate"><span class="pre">special.spec_corr.combine_corrs</span></code>. If <code class="docutils literal notranslate"><span class="pre">instru_corr</span></code> is not provided,
the uncertainties in each spectral channel will be considered
independent. See <a class="reference internal" href="#gre16" id="id6"><span>[GRE16]</span></a> for more details.</p></li>
<li><p><strong>instru_res</strong> (<em>float</em><em> or </em><em>list of floats/strings</em><em>, </em><em>optional</em>) – The mean instrumental resolving power(s) OR filter names. This is
used to convolve the model spectrum. If several instruments are used,
provide a list of resolving power values / filter names, one for
each instrument used.</p></li>
<li><p><strong>instru_idx</strong> (<em>numpy 1d array</em><em>, </em><em>optional</em>) – 1d array containing an index representing each instrument used
to obtain the spectrum, label them from 0 to the number of instruments
(<span class="math notranslate nohighlight">\(n_{ins}\)</span>). Zero for points that don’t correspond to any of the
<code class="docutils literal notranslate"><span class="pre">instru_res</span></code> values provided, and i in <span class="math notranslate nohighlight">\([1,n_{ins}]\)</span> for points
associated to instru_res[i-1]. This parameter must be provided if the
spectrum consists of points obtained with different instruments.</p></li>
<li><p><strong>use_weights</strong> (<em>bool</em><em>, </em><em>optional</em>) – For the likelihood calculation, whether to weigh each point of the
spectrum based on the spectral resolution or bandwidth of photometric
filters used. Weights will be proportional to <code class="docutils literal notranslate"><span class="pre">dlbda_obs/lbda_obs</span></code> if
<code class="docutils literal notranslate"><span class="pre">dlbda_obs</span></code> is provided, or set to 1 for all points otherwise.</p></li>
<li><p><strong>filter_reader</strong> (<em>python routine</em><em>, </em><em>optional</em>) – <p>External routine that reads a filter file and returns a 2D numpy array,
where the first column corresponds to wavelengths, and the second
contains transmission values. Important: if not provided, but strings
are detected in instru_res, the default file reader will be used.
It assumes the following format for the files:</p>
<ul>
<li><p>first row contains headers (titles of each column)</p></li>
<li><p>starting from 2nd row: 1st column: wavelength, 2nd col.: transmission</p></li>
<li><p>Unit of wavelength can be provided in parentheses of first header         key name: e.g. “WL(AA)” for angstrom, “wavelength(mu)” for micrometer         or “lambda(nm)” for nanometer. Note: only what is in parentheses         matters for the units.</p></li>
</ul>
</p></li>
<li><p><strong>plot</strong> (<em>bool</em><em>, </em><em>optional</em>) – Whether to plot the measured spectrum and the model spectrum.</p></li>
<li><p><strong>outfile</strong> (<em>string</em><em>, </em><em>optional</em>) – Path+filename for the plot to be saved (won’t be saved if not provided).</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>chi_sq</strong> – Goodness of fit indicator.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-special.config">
<span id="special-config-module"></span><h2>special.config module<a class="headerlink" href="#module-special.config" title="Permalink to this headline"></a></h2>
<p>Module with configuration parameters, timing functions and multiprocessing
utilities (inspired from <code class="docutils literal notranslate"><span class="pre">VIP</span></code>).</p>
<dl class="py function">
<dt class="sig sig-object py" id="special.config.time_fin">
<span class="sig-prename descclassname"><span class="pre">special.config.</span></span><span class="sig-name descname"><span class="pre">time_fin</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">start_time</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/special/config.html#time_fin"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#special.config.time_fin" title="Permalink to this definition"></a></dt>
<dd><p>Return the execution time of a script.</p>
<p>It requires the initialization  with the function time_ini().</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="special.config.time_ini">
<span class="sig-prename descclassname"><span class="pre">special.config.</span></span><span class="sig-name descname"><span class="pre">time_ini</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/special/config.html#time_ini"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#special.config.time_ini" title="Permalink to this definition"></a></dt>
<dd><p>Set and print the time at which the script started.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>start_time</strong> – Starting time.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>string</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="special.config.timing">
<span class="sig-prename descclassname"><span class="pre">special.config.</span></span><span class="sig-name descname"><span class="pre">timing</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">start_time</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/special/config.html#timing"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#special.config.timing" title="Permalink to this definition"></a></dt>
<dd><p>Print the execution time of a script.</p>
<p>It requires the initialization  with the function time_ini().</p>
</dd></dl>

</section>
<section id="module-special.fits">
<span id="special-fits-module"></span><h2>special.fits module<a class="headerlink" href="#module-special.fits" title="Permalink to this headline"></a></h2>
<p>Module with various fits handling functions (same as in <code class="docutils literal notranslate"><span class="pre">VIP</span></code>)</p>
<dl class="py function">
<dt class="sig sig-object py" id="special.fits.info_fits">
<span class="sig-prename descclassname"><span class="pre">special.fits.</span></span><span class="sig-name descname"><span class="pre">info_fits</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fitsfilename</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/special/fits.html#info_fits"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#special.fits.info_fits" title="Permalink to this definition"></a></dt>
<dd><p>Print the information about a fits file.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>fitsfilename</strong> (<em>str</em>) – Path to the fits file.</p></li>
<li><p><strong>**kwargs</strong> (<em>optional</em>) – Optional arguments to the astropy.io.fits.open() function. E.g.
“output_verify” can be set to ignore, in case of non-standard header.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="special.fits.open_fits">
<span class="sig-prename descclassname"><span class="pre">special.fits.</span></span><span class="sig-name descname"><span class="pre">open_fits</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fitsfilename</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n=0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">header=False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ignore_missing_end=False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">precision=&lt;class</span> <span class="pre">'numpy.float32'&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_memmap=False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose=True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">**kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/special/fits.html#open_fits"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#special.fits.open_fits" title="Permalink to this definition"></a></dt>
<dd><p>Load a fits file into a memory as numpy array.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>fitsfilename</strong> (<em>string</em><em> or </em><em>pathlib.Path</em>) – Name of the fits file or <code class="docutils literal notranslate"><span class="pre">pathlib.Path</span></code> object</p></li>
<li><p><strong>n</strong> (<em>int</em><em>, </em><em>optional</em>) – It chooses which HDU to open. Default is the first one.</p></li>
<li><p><strong>header</strong> (<em>bool</em><em>, </em><em>optional</em>) – Whether to return the header along with the data or not.</p></li>
<li><p><strong>precision</strong> (<em>numpy dtype</em><em>, </em><em>optional</em>) – Float precision, by default np.float32 or single precision float.</p></li>
<li><p><strong>ignore_missing_end</strong> (<em>bool optional</em>) – Allows to open fits files with a header missing END card.</p></li>
<li><p><strong>return_memmap</strong> (<em>bool</em><em>, </em><em>optional</em>) – If True, the function returns the handle to the FITS file opened by
mmap. With the hdulist, array data of each HDU to be accessed with mmap,
rather than being read into memory all at once. This is particularly
useful for working with very large arrays that cannot fit entirely into
physical memory.</p></li>
<li><p><strong>verbose</strong> (<em>bool</em><em>, </em><em>optional</em>) – If True prints message of completion.</p></li>
<li><p><strong>**kwargs</strong> (<em>optional</em>) – Optional arguments to the astropy.io.fits.open() function. E.g.
“output_verify” can be set to ignore, in case of non-standard header.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>hdulist</strong> (<em>hdulist</em>) – [memmap=True] FITS file <code class="docutils literal notranslate"><span class="pre">n</span></code> hdulist.</p></li>
<li><p><strong>data</strong> (<em>numpy ndarray</em>) – [memmap=False] Array containing the frames of the fits-cube.</p></li>
<li><p><strong>header</strong> (<em>dict</em>) – [memmap=False, header=True] Dictionary containing the fits header.</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="special.fits.write_fits">
<span class="sig-prename descclassname"><span class="pre">special.fits.</span></span><span class="sig-name descname"><span class="pre">write_fits</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fitsfilename</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">array</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">header=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">output_verify='exception'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">precision=&lt;class</span> <span class="pre">'numpy.float32'&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose=True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/special/fits.html#write_fits"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#special.fits.write_fits" title="Permalink to this definition"></a></dt>
<dd><p>Write array and header into FITS file.</p>
<p>If there is a previous file with the same filename then it’s replaced.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>fitsfilename</strong> (<em>string</em>) – Full path of the fits file to be written.</p></li>
<li><p><strong>array</strong> (<em>numpy ndarray</em>) – Array to be written into a fits file.</p></li>
<li><p><strong>header</strong> (<em>numpy ndarray</em><em>, </em><em>optional</em>) – Array with header.</p></li>
<li><p><strong>output_verify</strong> (<em>str</em><em>, </em><em>optional</em>) – {“fix”, “silentfix”, “ignore”, “warn”, “exception”}
Verification options:
<a class="reference external" href="https://docs.astropy.org/en/stable/io/fits/api/verification.html">https://docs.astropy.org/en/stable/io/fits/api/verification.html</a></p></li>
<li><p><strong>precision</strong> (<em>numpy dtype</em><em>, </em><em>optional</em>) – Float precision, by default np.float32 or single precision float.</p></li>
<li><p><strong>verbose</strong> (<em>bool</em><em>, </em><em>optional</em>) – If True prints message.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-special.mcmc_sampling">
<span id="special-mcmc-sampling-module"></span><h2>special.mcmc_sampling module<a class="headerlink" href="#module-special.mcmc_sampling" title="Permalink to this headline"></a></h2>
<p>Module with the MCMC (<code class="docutils literal notranslate"><span class="pre">emcee</span></code>) sampling for model spectra parameter
estimation.</p>
<dl class="citation">
<dt class="label" id="for13"><span class="brackets"><a class="fn-backref" href="#id11">FOR13</a></span></dt>
<dd><div class="line-block">
<div class="line">Foreman-Mackey et al. 2013</div>
<div class="line"><strong>emcee: The MCMC Hammer</strong></div>
<div class="line"><em>PASP, Volume 125, Issue 925, p. 306</em></div>
<div class="line"><a class="reference external" href="https://arxiv.org/abs/1202.3665">https://arxiv.org/abs/1202.3665</a></div>
</div>
</dd>
<dt class="label" id="for19"><span class="brackets"><a class="fn-backref" href="#id12">FOR19</a></span></dt>
<dd><div class="line-block">
<div class="line">Foreman-Mackey et al. 2019</div>
<div class="line"><strong>emcee v3: A Python ensemble sampling toolkit for affine-invariant MCMC</strong></div>
<div class="line"><em>JOSS, Volume 4, Issue 43, p. 1864</em></div>
<div class="line"><a class="reference external" href="https://arxiv.org/abs/1911.07688">https://arxiv.org/abs/1911.07688</a></div>
</div>
</dd>
<dt class="label" id="goo10"><span class="brackets"><a class="fn-backref" href="#id15">GOO10</a></span></dt>
<dd><div class="line-block">
<div class="line">Goodman &amp; Weare 2010</div>
<div class="line"><strong>Ensemble samplers with affine invariance</strong></div>
<div class="line"><em>Comm. App. Math. Comp. Sci., Vol. 5, Issue 1, pp. 65-80.</em></div>
<div class="line"><a class="reference external" href="https://ui.adsabs.harvard.edu/abs/2010CAMCS...5...65G">https://ui.adsabs.harvard.edu/abs/2010CAMCS…5…65G</a></div>
</div>
</dd>
</dl>
<dl class="py function">
<dt class="sig sig-object py" id="special.mcmc_sampling.chain_zero_truncated">
<span class="sig-prename descclassname"><span class="pre">special.mcmc_sampling.</span></span><span class="sig-name descname"><span class="pre">chain_zero_truncated</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">chain</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ln_proba</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ar</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/special/mcmc_sampling.html#chain_zero_truncated"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#special.mcmc_sampling.chain_zero_truncated" title="Permalink to this definition"></a></dt>
<dd><p>Return the Markov chain with the dimension: walkers x steps* x parameters,
where steps* is the last step before having 0 (not yet constructed chain).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>chain</strong> (<em>numpy.array</em>) – The MCMC chain.</p></li>
<li><p><strong>ln_proba</strong> (<em>numpy.array</em><em>, </em><em>opt</em>) – Corresponding ln-probabilities.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>out</strong> (<em>numpy.array</em>) – The truncated MCMC chain, that is to say, the chain which only contains
relevant information.</p></li>
<li><p><strong>out_ln_proba</strong> (<em>numpy.array</em>) – If ln_proba is provided as input, out_ln_proba contains the
zero-truncated ln-proba (i.e. matching shape with non-zero samples)</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="special.mcmc_sampling.confidence">
<span class="sig-prename descclassname"><span class="pre">special.mcmc_sampling.</span></span><span class="sig-name descname"><span class="pre">confidence</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">isamples</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">labels</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cfd</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">68.27</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bins</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gaussian_fit</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weights</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">save</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">output_dir</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">''</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bounds</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">priors</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/special/mcmc_sampling.html#confidence"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#special.mcmc_sampling.confidence" title="Permalink to this definition"></a></dt>
<dd><p>Determine the highly probable value for each model parameter, as well as
the 1-sigma confidence interval.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>isamples</strong> (<em>numpy.array</em>) – The independent samples for each model parameter.</p></li>
<li><p><strong>labels</strong> (<em>Tuple of strings</em>) – <dl class="simple">
<dt>Tuple of labels in the same order as initial_state:</dt><dd><ul>
<li><p>first all parameters related to loaded models (e.g. ‘Teff’, ‘logg’)</p></li>
<li><p>then the planet photometric radius ‘R’, in Jupiter radius</p></li>
<li><p>(optionally) the flux of emission lines (labels should match those             in the em_lines dictionary), in units of the model spectrum (times mu)</p></li>
<li><p>(optionally) the optical extinction ‘Av’, in mag</p></li>
<li><p>(optionally) the ratio of total to selective optical extinction ‘Rv’</p></li>
<li><p>(optionally) ‘Tbb1’, ‘Rbb1’, ‘Tbb2’, ‘Rbb2’, etc. for each extra bb             contribution.</p></li>
</ul>
</dd>
</dl>
</p></li>
<li><p><strong>cfd</strong> (<em>float</em><em>, </em><em>optional</em>) – The confidence level given in percentage.</p></li>
<li><p><strong>bins</strong> (<em>int</em><em>, </em><em>optional</em>) – The number of bins used to sample the posterior distributions.</p></li>
<li><p><strong>gaussian_fit</strong> (<em>boolean</em><em>, </em><em>optional</em>) – If True, a gaussian fit is performed in order to determine (mu,sigma)</p></li>
<li><p><strong>weights</strong> (<em>1d numpy ndarray</em><em> or </em><em>None</em><em>, </em><em>optional</em>) – An array of weights for each sample.</p></li>
<li><p><strong>verbose</strong> (<em>boolean</em><em>, </em><em>optional</em>) – Display information in the shell.</p></li>
<li><p><strong>save</strong> (<em>boolean</em><em>, </em><em>optional</em>) – If “True”, a txt file with the results is saved in the output
repository.</p></li>
<li><p><strong>bounds</strong> (<em>dictionary</em><em>, </em><em>opt</em>) – Only used if a text file is saved summarizing results+bounds+priors.
Should be the same <code class="docutils literal notranslate"><span class="pre">bounds</span></code> as provided to the MCMC.</p></li>
<li><p><strong>priors</strong> (<em>dictionary</em><em>, </em><em>opt</em>) – Only used if a text file is saved summarizing results+bounds+priors.
Should be the same <code class="docutils literal notranslate"><span class="pre">priors</span></code> as provided to the MCMC.</p></li>
<li><p><strong>kwargs</strong> (<em>optional</em>) – Additional attributes are passed to the matplotlib hist() method.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>out</strong> – A 2 elements tuple with the highly probable solution and the confidence
interval.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>tuple</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="special.mcmc_sampling.lnlike">
<span class="sig-prename descclassname"><span class="pre">special.mcmc_sampling.</span></span><span class="sig-name descname"><span class="pre">lnlike</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">params</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">labels</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">grid_param_list</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lbda_obs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">spec_obs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">err_obs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dist</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">model_grid</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">model_reader</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">em_lines</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">{}</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">em_grid</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">{}</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dlbda_obs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">instru_corr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">instru_res</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">instru_idx</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_weights</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">filter_reader</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">AV_bef_bb</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">units_obs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'si'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">units_mod</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'si'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">interp_order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/special/mcmc_sampling.html#lnlike"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#special.mcmc_sampling.lnlike" title="Permalink to this definition"></a></dt>
<dd><p>Define the likelihood log-function.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>params</strong> (<em>tuple</em>) – Set of models parameters for which the model grid has to be
interpolated.</p></li>
<li><p><strong>labels</strong> (<em>Tuple of strings</em>) – <dl class="simple">
<dt>Tuple of labels in the same order as initial_state:</dt><dd><ul>
<li><p>first all parameters related to loaded models (e.g. ‘Teff’, ‘logg’)</p></li>
<li><p>then the planet photometric radius ‘R’, in Jupiter radius</p></li>
<li><p>(optionally) the flux of emission lines (labels should match those             in the em_lines dictionary), in units of the model spectrum (times mu)</p></li>
<li><p>(optionally) the optical extinction ‘Av’, in mag</p></li>
<li><p>(optionally) the ratio of total to selective optical extinction ‘Rv’</p></li>
<li><p>(optionally) ‘Tbb1’, ‘Rbb1’, ‘Tbb2’, ‘Rbb2’, etc. for each extra bb             contribution.</p></li>
</ul>
</dd>
</dl>
</p></li>
<li><p><strong>grid_param_list</strong> (<em>list of 1d numpy arrays/lists</em>) – Should contain list/numpy 1d arrays with available grid of model
parameters (should only contain the sampled parameters, not the models
themselves). The models will be loaded with <code class="docutils literal notranslate"><span class="pre">model_reader</span></code>.</p></li>
<li><p><strong>lbda_obs</strong> (<em>numpy 1d ndarray</em><em> or </em><em>list</em>) – Wavelengths of observed spectrum. If several instruments were used, the
wavelengths should be ordered per instrument, not necessarily as
monotonically increasing wavelength. Hereafter, <span class="math notranslate nohighlight">\(n_{ch}\)</span> is the
length of <code class="docutils literal notranslate"><span class="pre">lbda_obs</span></code>.</p></li>
<li><p><strong>spec_obs</strong> (<em>numpy 1d ndarray</em><em> or </em><em>list</em>) – Observed spectrum for each value of <code class="docutils literal notranslate"><span class="pre">lbda_obs</span></code>. Should have a length
of <span class="math notranslate nohighlight">\(n_{ch}\)</span>.</p></li>
<li><p><strong>err_obs</strong> (<em>numpy 1d/2d ndarray</em><em> or </em><em>list</em>) – Uncertainties on the observed spectrum. The array (list) can have either
a length of <span class="math notranslate nohighlight">\(n_{ch}\)</span>, or a shape of <span class="math notranslate nohighlight">\((2,n_{ch})\)</span> for lower
(first column) and upper (second column) uncertainties provided.</p></li>
<li><p><strong>dist</strong> (<em>float</em>) – Distance in parsec, used for flux scaling of the models.</p></li>
<li><p><strong>model_grid</strong> (<em>numpy N-d array</em><em>, </em><em>optional</em>) – If provided, should contain the grid of model spectra for each
free parameter of the given grid. I.e. for a grid of <span class="math notranslate nohighlight">\(n_T\)</span> values
of <span class="math notranslate nohighlight">\(T_{eff}\)</span> and <span class="math notranslate nohighlight">\(n_g\)</span> values of log(<span class="math notranslate nohighlight">\(g\)</span>), the numpy
array should have a shape of <span class="math notranslate nohighlight">\((n_T, n_g, n_{ch}, 2)\)</span>, where the
last 2 dimensions correspond to wavelength and fluxes respectively. If
provided, <code class="docutils literal notranslate"><span class="pre">model_grid</span></code> takes precedence over <code class="docutils literal notranslate"><span class="pre">model_name</span></code>/
<code class="docutils literal notranslate"><span class="pre">model_reader</span></code>.</p></li>
<li><p><strong>model_reader</strong> (<em>python routine</em><em>, </em><em>opt</em>) – External routine that reads a model file and returns a 2D numpy array,
where the first column corresponds to wavelengths, and the second
contains model values. See example routine in
<code class="docutils literal notranslate"><span class="pre">special.model_resampling.interpolate_model</span></code> description.</p></li>
<li><p><strong>em_lines</strong> (<em>dictionary</em><em>, </em><em>opt</em>) – <p>Dictionary of emission lines to be added on top of the model spectrum.
Each dict entry should be the name of the line, assigned to a tuple of
4 values:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>the wavelength (in <span class="math notranslate nohighlight">\(\mu\)</span> m);</p></li>
<li><p>a string indicating whether line intensity is expressed in flux             (‘F’), luminosity (‘L’) or log(L/LSun) (“LogL”);</p></li>
<li><p>the FWHM of the gaussian (or None if to be set automatically);</p></li>
<li><p>whether the FWHM is expressed in ‘nm’, ‘mu’ or ‘km/s’.</p></li>
</ol>
</div></blockquote>
<p>The third and fourth can also be set to None. In that case, the FWHM of
the gaussian will automatically be set to the equivalent width of the
line, calculated from the flux to be injected and the continuum
level (measured in the grid model to which the line is injected).</p>
<dl>
<dt>Examples:</dt><dd><div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">em_lines</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;BrG&#39;</span><span class="p">:(</span><span class="mf">2.1667</span><span class="p">,</span><span class="s1">&#39;F&#39;</span><span class="p">,</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">)};</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em_lines</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;BrG&#39;</span><span class="p">:(</span><span class="mf">2.1667</span><span class="p">,</span><span class="s1">&#39;LogL&#39;</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="s1">&#39;km/s&#39;</span><span class="p">)}</span>
</pre></div>
</div>
</dd>
</dl>
</p></li>
<li><p><strong>em_grid</strong> (<em>dictionary pointing to lists</em><em>, </em><em>opt</em>) – <p>Dictionary where each entry corresponds to an emission line and points
to a list of values to inject for emission line fluxes. For computation
efficiency, interpolation will be performed between the points of this
grid during the MCMC sampling. Dictionary entries should match those in
<code class="docutils literal notranslate"><span class="pre">labels</span></code> and <code class="docutils literal notranslate"><span class="pre">em_lines</span></code>.</p>
<dl>
<dt>Examples:</dt><dd><div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">BrGmin</span><span class="p">,</span> <span class="n">BrGmax</span> <span class="o">=</span> <span class="o">-</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em_grid</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;BrG&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">BrGmin</span><span class="p">,</span> <span class="n">BrGmax</span><span class="p">,</span> <span class="mi">20</span><span class="p">)}</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">BrGmin</span><span class="p">,</span> <span class="n">BrGmax</span> <span class="o">=</span> <span class="o">-</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">PaBmin</span><span class="p">,</span> <span class="n">PaBmax</span> <span class="o">=</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">7</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em_grid</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;PaB&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">PaBmin</span><span class="p">,</span> <span class="n">PaBmax</span><span class="p">,</span> <span class="mi">20</span><span class="p">),</span>
<span class="gp">&gt;&gt;&gt; </span>           <span class="s1">&#39;BrG&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">BrGmin</span><span class="p">,</span> <span class="n">BrGmax</span><span class="p">,</span> <span class="mi">20</span><span class="p">)}</span>
</pre></div>
</div>
</dd>
</dl>
</p></li>
<li><p><strong>dlbda_obs</strong> (<em>numpy 1d ndarray</em><em> or </em><em>list</em><em>, </em><em>optional</em>) – Respective spectral channel width or FWHM of the photometric filters
used for each point of the observed spectrum. This vector is used to
infer which part(s) of a combined spectro+photometric spectrum should
involve convolution+subsampling (model resolution higher than
measurements), interpolation (the opposite), or convolution by the
transmission curve of a photometric filter. If not provided, it will be
inferred from the difference between consecutive lbda_obs points (i.e.
inaccurate for a combined spectrum). It must be provided IF one wants to
weigh each measurement based on the spectral resolution of each
instrument (as in <a class="reference internal" href="#olo16" id="id7"><span>[OLO16]</span></a>), through the <code class="docutils literal notranslate"><span class="pre">use_weights</span></code> argument.</p></li>
<li><p><strong>instru_corr</strong> (<em>numpy 2d ndarray</em><em>, </em><em>optional</em>) – Spectral correlation between post-processed images in which the
spectrum is measured. It is specific to the instrument, PSF subtraction
algorithm and radial separation of the companion from the central star.
Can be computed using <code class="docutils literal notranslate"><span class="pre">special.spec_corr.spectral_correlation</span></code>. In
case of a spectrum obtained with different instruments, it is
recommended to construct the final spectral_correlation matrix with
<code class="docutils literal notranslate"><span class="pre">special.spec_corr.combine_corrs</span></code>. If <code class="docutils literal notranslate"><span class="pre">instru_corr</span></code> is not provided,
the uncertainties in each spectral channel will be considered
independent. See <a class="reference internal" href="#gre16" id="id8"><span>[GRE16]</span></a> for more details.</p></li>
<li><p><strong>instru_res</strong> (<em>float</em><em> or </em><em>list of floats/strings</em><em>, </em><em>optional</em>) – The mean instrumental resolving power(s) OR filter names. This is
used to convolve the model spectrum. If several instruments are used,
provide a list of resolving power values / filter names, one for
each instrument used.</p></li>
<li><p><strong>instru_idx</strong> (<em>numpy 1d array</em><em>, </em><em>optional</em>) – 1d array containing an index representing each instrument used
to obtain the spectrum, label them from 0 to the number of instruments
(<span class="math notranslate nohighlight">\(n_{ins}\)</span>). Zero for points that don’t correspond to any of the
<code class="docutils literal notranslate"><span class="pre">instru_res</span></code> values provided, and i in <span class="math notranslate nohighlight">\([1,n_{ins}]\)</span> for points
associated to instru_res[i-1]. This parameter must be provided if the
spectrum consists of points obtained with different instruments.</p></li>
<li><p><strong>use_weights</strong> (<em>bool</em><em>, </em><em>optional</em>) – For the likelihood calculation, whether to weigh each point of the
spectrum based on the spectral resolution or bandwidth of photometric
filters used. Weights will be proportional to <code class="docutils literal notranslate"><span class="pre">dlbda_obs/lbda_obs</span></code> if
<code class="docutils literal notranslate"><span class="pre">dlbda_obs</span></code> is provided, or set to 1 for all points otherwise.</p></li>
<li><p><strong>filter_reader</strong> (<em>python routine</em><em>, </em><em>optional</em>) – <p>External routine that reads a filter file and returns a 2D numpy array,
where the first column corresponds to wavelengths, and the second
contains transmission values. Important: if not provided, but strings
are detected in instru_res, the default file reader will be used.
It assumes the following format for the files:</p>
<ul>
<li><p>first row contains headers (titles of each column)</p></li>
<li><p>starting from 2nd row: 1st column: wavelength, 2nd col.: transmission</p></li>
<li><p>Unit of wavelength can be provided in parentheses of first header         key name: e.g. “WL(AA)” for angstrom, “wavelength(mu)” for micrometer         or “lambda(nm)” for nanometer. Note: only what is in parentheses         matters for the units.</p></li>
</ul>
</p></li>
<li><p><strong>AV_bef_bb</strong> (<em>bool</em><em>, </em><em>optional</em>) – If both extinction and an extra bb component are free parameters,
whether to apply extinction before adding the BB component (e.g.
extinction mostly from circumplanetary dust) or after the BB component
(e.g. mostly insterstellar extinction).</p></li>
<li><p><strong>units_obs</strong> (<em>str</em><em>, </em><em>opt {'si'</em><em>,</em><em>'cgs'</em><em>,</em><em>'jy'}</em>) – Units of observed spectrum. ‘si’ for W/m^2/mu; ‘cgs’ for ergs/s/cm^2/mu
or ‘jy’ for janskys.</p></li>
<li><p><strong>units_mod</strong> (<em>str</em><em>, </em><em>opt {'si'</em><em>,</em><em>'cgs'</em><em>,</em><em>'jy'}</em>) – Units of the model. ‘si’ for W/m^2/mu; ‘cgs’ for ergs/s/cm^2/mu or ‘jy’
for janskys. If different to units_obs, the spectrum units will be
converted.</p></li>
<li><p><strong>interp_order</strong> (<em>int</em><em>, </em><em>opt</em><em>, </em><em>{-1</em><em>,</em><em>0</em><em>,</em><em>1}</em>) – <dl class="simple">
<dt>Interpolation mode for model interpolation.</dt><dd><ul>
<li><p>-1: log interpolation (i.e. linear interpolatlion on log(Flux))</p></li>
<li><p>0: nearest neighbour model</p></li>
<li><p>1: Order 1 spline interpolation</p></li>
</ul>
</dd>
</dl>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>out</strong> – The log of the likelihood.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="special.mcmc_sampling.lnprob">
<span class="sig-prename descclassname"><span class="pre">special.mcmc_sampling.</span></span><span class="sig-name descname"><span class="pre">lnprob</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">params</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">labels</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bounds</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">grid_param_list</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lbda_obs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">spec_obs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">err_obs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dist</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">model_grid</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">model_reader</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">em_lines</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">{}</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">em_grid</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">{}</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dlbda_obs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">instru_corr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">instru_res</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">instru_idx</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_weights</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">filter_reader</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">AV_bef_bb</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">units_obs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'si'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">units_mod</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'si'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">interp_order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">priors</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">physical</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/special/mcmc_sampling.html#lnprob"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#special.mcmc_sampling.lnprob" title="Permalink to this definition"></a></dt>
<dd><p>Define the probability log-function as the sum between the prior and
likelihood log-functions.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>params</strong> (<em>tuple</em>) – The model parameters.</p></li>
<li><p><strong>labels</strong> (<em>Tuple of strings</em>) – <dl class="simple">
<dt>Tuple of labels in the same order as initial_state:</dt><dd><ul>
<li><p>first all parameters related to loaded models (e.g. ‘Teff’, ‘logg’)</p></li>
<li><p>then the planet photometric radius ‘R’, in Jupiter radius</p></li>
<li><p>(optionally) the flux of emission lines (labels should match those             in the <code class="docutils literal notranslate"><span class="pre">em_lines</span></code> dictionary), in units of the model spectrum (times mu)</p></li>
<li><p>(optionally) the optical extinction ‘Av’, in mag</p></li>
<li><p>(optionally) the ratio of total to selective optical extinction ‘Rv’</p></li>
<li><p>(optionally) ‘Tbb1’, ‘Rbb1’, ‘Tbb2’, ‘Rbb2’, etc. for each extra bb             contribution.</p></li>
</ul>
</dd>
</dl>
</p></li>
<li><p><strong>bounds</strong> (<em>dictionary</em>) – <p>Each entry should be associated with a tuple corresponding to lower and
upper bounds respectively. Bounds should be provided for ALL model
parameters, including ‘R’ (planet photometric radius). ‘Av’ (optical
extinction) is optional. If provided here, Av will also be fitted.
All keywords that are neither ‘R’, ‘Av’ nor ‘M’ will
be considered model grid parameters.</p>
<dl>
<dt>Examples:</dt><dd><div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">bounds</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;Teff&#39;</span><span class="p">:(</span><span class="mi">1000</span><span class="p">,</span><span class="mi">2000</span><span class="p">),</span> <span class="s1">&#39;logg&#39;</span><span class="p">:(</span><span class="mf">3.0</span><span class="p">,</span><span class="mf">4.5</span><span class="p">),</span> <span class="s1">&#39;R&#39;</span><span class="p">:(</span><span class="mf">0.1</span><span class="p">,</span><span class="mi">5</span><span class="p">)}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bounds</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;Teff&#39;</span><span class="p">:(</span><span class="mi">1000</span><span class="p">,</span><span class="mi">2000</span><span class="p">),</span> <span class="s1">&#39;logg&#39;</span><span class="p">:(</span><span class="mf">3.0</span><span class="p">,</span><span class="mf">4.5</span><span class="p">),</span> <span class="s1">&#39;R&#39;</span><span class="p">:(</span><span class="mf">0.1</span><span class="p">,</span><span class="mi">5</span><span class="p">),</span>
<span class="gp">&gt;&gt;&gt; </span>          <span class="s1">&#39;Av&#39;</span><span class="p">:(</span><span class="mf">0.</span><span class="p">,</span><span class="mf">2.5</span><span class="p">),</span> <span class="s1">&#39;Rv&#39;</span><span class="p">:(</span><span class="mi">1</span><span class="p">,</span><span class="mi">5</span><span class="p">)}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bounds</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;Teff&#39;</span><span class="p">:(</span><span class="mi">1000</span><span class="p">,</span><span class="mi">2000</span><span class="p">),</span> <span class="s1">&#39;logg&#39;</span><span class="p">:(</span><span class="mf">3.0</span><span class="p">,</span><span class="mf">4.5</span><span class="p">),</span> <span class="s1">&#39;R&#39;</span><span class="p">:(</span><span class="mf">0.1</span><span class="p">,</span><span class="mi">5</span><span class="p">),</span>
<span class="gp">&gt;&gt;&gt; </span>          <span class="s1">&#39;Av&#39;</span><span class="p">:(</span><span class="mf">0.</span><span class="p">,</span><span class="mf">2.5</span><span class="p">),</span> <span class="s1">&#39;BrG&#39;</span><span class="p">:(</span><span class="mf">1e-17</span><span class="p">,</span><span class="mf">1e-15</span><span class="p">)}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bounds</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;Teff&#39;</span><span class="p">:(</span><span class="mi">2000</span><span class="p">,</span><span class="mi">3000</span><span class="p">),</span> <span class="s1">&#39;logg&#39;</span><span class="p">:(</span><span class="mf">3.0</span><span class="p">,</span><span class="mf">4.5</span><span class="p">),</span> <span class="s1">&#39;R&#39;</span><span class="p">:(</span><span class="mf">1.</span><span class="p">,</span><span class="mf">5.</span><span class="p">),</span>
<span class="gp">&gt;&gt;&gt; </span>          <span class="s1">&#39;Tbb1&#39;</span><span class="p">:(</span><span class="mi">500</span><span class="p">,</span><span class="mi">1500</span><span class="p">),</span> <span class="s1">&#39;Rbb1&#39;</span><span class="p">:(</span><span class="mf">0.1</span><span class="p">,</span><span class="mf">1.</span><span class="p">)}</span>
</pre></div>
</div>
</dd>
</dl>
</p></li>
<li><p><strong>grid_param_list</strong> (<em>list of 1d numpy arrays/lists</em>) – Should contain list/numpy 1d arrays with available grid of model
parameters (should only contain the sampled parameters, not the models
themselves). The models will be loaded with <code class="docutils literal notranslate"><span class="pre">model_reader</span></code>.</p></li>
<li><p><strong>lbda_obs</strong> (<em>numpy 1d ndarray</em><em> or </em><em>list</em>) – Wavelengths of observed spectrum. If several instruments were used, the
wavelengths should be ordered per instrument, not necessarily as
monotonically increasing wavelength. Hereafter, <span class="math notranslate nohighlight">\(n_{ch}\)</span> is the
length of <code class="docutils literal notranslate"><span class="pre">lbda_obs</span></code>.</p></li>
<li><p><strong>spec_obs</strong> (<em>numpy 1d ndarray</em><em> or </em><em>list</em>) – Observed spectrum for each value of <code class="docutils literal notranslate"><span class="pre">lbda_obs</span></code>. Should have a length
of <span class="math notranslate nohighlight">\(n_{ch}\)</span>.</p></li>
<li><p><strong>err_obs</strong> (<em>numpy 1d/2d ndarray</em><em> or </em><em>list</em>) – Uncertainties on the observed spectrum. The array (list) can have either
a length of <span class="math notranslate nohighlight">\(n_{ch}\)</span>, or a shape of <span class="math notranslate nohighlight">\((2,n_{ch})\)</span> for lower
(first column) and upper (second column) uncertainties provided.</p></li>
<li><p><strong>dist</strong> (<em>float</em>) – Distance in parsec, used for flux scaling of the models.</p></li>
<li><p><strong>model_grid</strong> (<em>numpy N-d array</em><em>, </em><em>optional</em>) – If provided, should contain the grid of model spectra for each
free parameter of the given grid. I.e. for a grid of <span class="math notranslate nohighlight">\(n_T\)</span> values
of <span class="math notranslate nohighlight">\(T_{eff}\)</span> and <span class="math notranslate nohighlight">\(n_g\)</span> values of log(<span class="math notranslate nohighlight">\(g\)</span>), the numpy
array should have a shape of <span class="math notranslate nohighlight">\((n_T, n_g, n_{ch}, 2)\)</span>, where the
last 2 dimensions correspond to wavelength and fluxes respectively. If
provided, <code class="docutils literal notranslate"><span class="pre">model_grid</span></code> takes precedence over <code class="docutils literal notranslate"><span class="pre">model_name</span></code>/
<code class="docutils literal notranslate"><span class="pre">model_reader</span></code>.</p></li>
<li><p><strong>model_reader</strong> (<em>python routine</em><em>, </em><em>opt</em>) – External routine that reads a model file and returns a 2D numpy array,
where the first column corresponds to wavelengths, and the second
contains model values. See example routine in
<code class="docutils literal notranslate"><span class="pre">special.model_resampling.interpolate_model</span></code> description.</p></li>
<li><p><strong>em_lines</strong> (<em>dictionary</em><em>, </em><em>opt</em>) – <p>Dictionary of emission lines to be added on top of the model spectrum.
Each dict entry should be the name of the line, assigned to a tuple of
4 values:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>the wavelength (in <span class="math notranslate nohighlight">\(\mu\)</span> m);</p></li>
<li><p>a string indicating whether line intensity is expressed in flux
(‘F’), luminosity (‘L’) or log(L/LSun) (“LogL”);</p></li>
<li><p>the FWHM of the gaussian (or None if to be set automatically);</p></li>
<li><p>whether the FWHM is expressed in ‘nm’, ‘mu’ or ‘km/s’.</p></li>
</ol>
</div></blockquote>
<p>The third and fourth can also be set to None. In that case, the FWHM of
the gaussian will automatically be set to the equivalent width of the
line, calculated from the flux to be injected and the continuum
level (measured in the grid model to which the line is injected).</p>
<dl>
<dt>Examples:</dt><dd><div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">em_lines</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;BrG&#39;</span><span class="p">:(</span><span class="mf">2.1667</span><span class="p">,</span><span class="s1">&#39;F&#39;</span><span class="p">,</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">)};</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em_lines</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;BrG&#39;</span><span class="p">:(</span><span class="mf">2.1667</span><span class="p">,</span><span class="s1">&#39;LogL&#39;</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="s1">&#39;km/s&#39;</span><span class="p">)}</span>
</pre></div>
</div>
</dd>
</dl>
</p></li>
<li><p><strong>em_grid</strong> (<em>dictionary pointing to lists</em><em>, </em><em>opt</em>) – <p>Dictionary where each entry corresponds to an emission line and points
to a list of values to inject for emission line fluxes. For computation
efficiency, interpolation will be performed between the points of this
grid during the MCMC sampling. Dictionary entries should match those in
<code class="docutils literal notranslate"><span class="pre">labels</span></code> and <code class="docutils literal notranslate"><span class="pre">em_lines</span></code>.</p>
<dl>
<dt>Examples:</dt><dd><div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">BrGmin</span><span class="p">,</span> <span class="n">BrGmax</span> <span class="o">=</span> <span class="o">-</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em_grid</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;BrG&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">BrGmin</span><span class="p">,</span> <span class="n">BrGmax</span><span class="p">,</span> <span class="mi">20</span><span class="p">)}</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">BrGmin</span><span class="p">,</span> <span class="n">BrGmax</span> <span class="o">=</span> <span class="o">-</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">PaBmin</span><span class="p">,</span> <span class="n">PaBmax</span> <span class="o">=</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">7</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em_grid</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;PaB&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">PaBmin</span><span class="p">,</span> <span class="n">PaBmax</span><span class="p">,</span> <span class="mi">20</span><span class="p">),</span>
<span class="gp">&gt;&gt;&gt; </span>           <span class="s1">&#39;BrG&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">BrGmin</span><span class="p">,</span> <span class="n">BrGmax</span><span class="p">,</span> <span class="mi">20</span><span class="p">)}</span>
</pre></div>
</div>
</dd>
</dl>
</p></li>
<li><p><strong>dlbda_obs</strong> (<em>numpy 1d ndarray</em><em> or </em><em>list</em><em>, </em><em>optional</em>) – Respective spectral channel width or FWHM of the photometric filters
used for each point of the observed spectrum. This vector is used to
infer which part(s) of a combined spectro+photometric spectrum should
involve convolution+subsampling (model resolution higher than
measurements), interpolation (the opposite), or convolution by the
transmission curve of a photometric filter. If not provided, it will be
inferred from the difference between consecutive lbda_obs points (i.e.
inaccurate for a combined spectrum). It must be provided IF one wants to
weigh each measurement based on the spectral resolution of each
instrument (as in <a class="reference internal" href="#olo16" id="id9"><span>[OLO16]</span></a>), through the <code class="docutils literal notranslate"><span class="pre">use_weights</span></code> argument.</p></li>
<li><p><strong>instru_corr</strong> (<em>numpy 2d ndarray</em><em>, </em><em>optional</em>) – Spectral correlation between post-processed images in which the
spectrum is measured. It is specific to the instrument, PSF subtraction
algorithm and radial separation of the companion from the central star.
Can be computed using <code class="docutils literal notranslate"><span class="pre">special.spec_corr.spectral_correlation</span></code>. In
case of a spectrum obtained with different instruments, it is
recommended to construct the final spectral_correlation matrix with
<code class="docutils literal notranslate"><span class="pre">special.spec_corr.combine_corrs</span></code>. If <code class="docutils literal notranslate"><span class="pre">instru_corr</span></code> is not provided,
the uncertainties in each spectral channel will be considered
independent. See <a class="reference internal" href="#gre16" id="id10"><span>[GRE16]</span></a> for more details.</p></li>
<li><p><strong>instru_res</strong> (<em>float</em><em> or </em><em>list of floats/strings</em><em>, </em><em>optional</em>) – The mean instrumental resolving power(s) OR filter names. This is
used to convolve the model spectrum. If several instruments are used,
provide a list of resolving power values / filter names, one for
each instrument used.</p></li>
<li><p><strong>instru_idx</strong> (<em>numpy 1d array</em><em>, </em><em>optional</em>) – 1d array containing an index representing each instrument used
to obtain the spectrum, label them from 0 to the number of instruments
(<span class="math notranslate nohighlight">\(n_{ins}\)</span>). Zero for points that don’t correspond to any of the
<code class="docutils literal notranslate"><span class="pre">instru_res</span></code> values provided, and i in <span class="math notranslate nohighlight">\([1,n_{ins}]\)</span> for points
associated to instru_res[i-1]. This parameter must be provided if the
spectrum consists of points obtained with different instruments.</p></li>
<li><p><strong>use_weights</strong> (<em>bool</em><em>, </em><em>optional</em>) – For the likelihood calculation, whether to weigh each point of the
spectrum based on the spectral resolution or bandwidth of photometric
filters used. Weights will be proportional to <code class="docutils literal notranslate"><span class="pre">dlbda_obs/lbda_obs</span></code> if
<code class="docutils literal notranslate"><span class="pre">dlbda_obs</span></code> is provided, or set to 1 for all points otherwise.</p></li>
<li><p><strong>filter_reader</strong> (<em>python routine</em><em>, </em><em>optional</em>) – <p>External routine that reads a filter file and returns a 2D numpy array,
where the first column corresponds to wavelengths, and the second
contains transmission values. Important: if not provided, but strings
are detected in instru_res, the default file reader will be used.
It assumes the following format for the files:</p>
<ul>
<li><p>first row contains headers (titles of each column)</p></li>
<li><p>starting from 2nd row: 1st column: wavelength, 2nd col.: transmission</p></li>
<li><p>Unit of wavelength can be provided in parentheses of first header         key name: e.g. “WL(AA)” for angstrom, “wavelength(mu)” for micrometer         or “lambda(nm)” for nanometer. Note: only what is in parentheses         matters for the units.</p></li>
</ul>
</p></li>
<li><p><strong>AV_bef_bb</strong> (<em>bool</em><em>, </em><em>optional</em>) – If both extinction and an extra bb component are free parameters,
whether to apply extinction before adding the BB component (e.g.
extinction mostly from circumplanetary dust) or after the BB component
(e.g. mostly insterstellar extinction).</p></li>
<li><p><strong>units_obs</strong> (<em>str</em><em>, </em><em>opt {'si'</em><em>,</em><em>'cgs'</em><em>,</em><em>'jy'}</em>) – Units of observed spectrum. ‘si’ for W/m^2/mu; ‘cgs’ for ergs/s/cm^2/mu
or ‘jy’ for janskys.</p></li>
<li><p><strong>units_mod</strong> (<em>str</em><em>, </em><em>opt {'si'</em><em>,</em><em>'cgs'</em><em>,</em><em>'jy'}</em>) – Units of the model. ‘si’ for W/m^2/mu; ‘cgs’ for ergs/s/cm^2/mu or ‘jy’
for janskys. If different to units_obs, the spectrum units will be
converted.</p></li>
<li><p><strong>interp_order</strong> (<em>int</em><em>, </em><em>opt</em><em>, </em><em>{-1</em><em>,</em><em>0</em><em>,</em><em>1}</em>) – <dl class="simple">
<dt>Interpolation mode for model interpolation.</dt><dd><ul>
<li><p>-1: log interpolation (i.e. linear interpolatlion on log(Flux))</p></li>
<li><p>0: nearest neighbour model</p></li>
<li><p>1: Order 1 spline interpolation</p></li>
</ul>
</dd>
</dl>
</p></li>
<li><p><strong>priors</strong> (<em>dictionary</em><em>, </em><em>opt</em>) – <p>If not None, sets prior estimates for each parameter of the model. Each
entry should be set to either None (no prior) or a tuple of 2 elements
containing prior estimate and uncertainty on the estimate.
Missing entries (i.e. provided in <code class="docutils literal notranslate"><span class="pre">bounds</span></code> dictionary but not here)
will be associated no prior.
‘M’ can be used for a prior on the mass of the planet. In that case the
corresponding prior log probability is computed from the values for
parameters ‘logg’ and ‘R’.</p>
<dl>
<dt>Examples:</dt><dd><div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">priors</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;logg&#39;</span><span class="p">:(</span><span class="mf">3.5</span><span class="p">,</span><span class="mf">0.2</span><span class="p">),</span> <span class="s1">&#39;Rv&#39;</span><span class="p">:(</span><span class="mf">3.1</span><span class="p">,</span><span class="mf">0.2</span><span class="p">)}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">priors</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;Teff&#39;</span><span class="p">:(</span><span class="mi">1600</span><span class="p">,</span><span class="mi">100</span><span class="p">),</span> <span class="s1">&#39;logg&#39;</span><span class="p">:(</span><span class="mf">3.5</span><span class="p">,</span><span class="mf">0.5</span><span class="p">),</span> <span class="s1">&#39;R&#39;</span><span class="p">:(</span><span class="mf">1.6</span><span class="p">,</span><span class="mf">0.1</span><span class="p">),</span>
<span class="gp">&gt;&gt;&gt; </span>          <span class="s1">&#39;Av&#39;</span><span class="p">:(</span><span class="mf">1.8</span><span class="p">,</span><span class="mf">0.2</span><span class="p">),</span> <span class="s1">&#39;M&#39;</span><span class="p">:(</span><span class="mi">10</span><span class="p">,</span><span class="mi">3</span><span class="p">)}</span>
</pre></div>
</div>
</dd>
</dl>
<p>Important: dictionary entry names should match exactly those of
<code class="docutils literal notranslate"><span class="pre">bounds</span></code>.</p>
</p></li>
<li><p><strong>physical</strong> (<em>bool</em><em>, </em><em>opt</em>) – In case of extra black body component(s) to a photosphere, whether to
force lower temperature than the photosphere effective temperature.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>out</strong> – The probability log-function.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="special.mcmc_sampling.mcmc_spec_sampling">
<span class="sig-prename descclassname"><span class="pre">special.mcmc_sampling.</span></span><span class="sig-name descname"><span class="pre">mcmc_spec_sampling</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">lbda_obs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">spec_obs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">err_obs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dist</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">grid_param_list</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">initial_state</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">labels</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bounds</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">resamp_before</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">model_grid</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">model_reader</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">em_lines</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">{}</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">em_grid</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">{}</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dlbda_obs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">instru_corr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">instru_res</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">instru_idx</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_weights</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">filter_reader</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">AV_bef_bb</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">units_obs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'si'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">units_mod</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'si'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">interp_order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">priors</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">physical</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">interp_nonexist</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ini_ball</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">a</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nwalkers</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1000</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">niteration_min</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">niteration_limit</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1000</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">niteration_supp</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">check_maxgap</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">20</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">conv_test</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'ac'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ac_c</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">50</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ac_count_thr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">3</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">burnin</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.3</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rhat_threshold</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.01</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rhat_count_threshold</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">grid_name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'resamp_grid.fits'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">output_dir</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'special/'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">output_file</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nproc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">display</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbosity</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">save</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/special/mcmc_sampling.html#mcmc_spec_sampling"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#special.mcmc_sampling.mcmc_spec_sampling" title="Permalink to this definition"></a></dt>
<dd><p>Runs an affine invariant MCMC sampling algorithm in order to determine
the most likely parameters for given spectral model and observed spectrum.
The code relies on <code class="docutils literal notranslate"><span class="pre">emcee</span></code> (<a class="reference internal" href="#for13" id="id11"><span>[FOR13]</span></a> &amp; <a class="reference internal" href="#for19" id="id12"><span>[FOR19]</span></a>).</p>
<dl class="simple">
<dt>Allowed features:</dt><dd><ul class="simple">
<li><p>Spectral models can either be read from a grid (e.g. BT-SETTL) or         be purely parametric (e.g. a blackbody model).</p></li>
<li><p>Extinction (A_V) and total-to-selective optical extinction ratio         (R_V) can be sampled. Default: A_V=0. If non-zero, default R_V=3.1 (ISM).</p></li>
<li><p>A dictionary of emission lines can be provided and their flux can         be sampled too.</p></li>
<li><p>Gaussian priors can be provided for each parameter, including the         mass of the object. The latter will be used if ‘logg’ is a parameter.</p></li>
<li><p>Spectral correlation between measurements will be taken into account         if provided in ‘instru_corr’.</p></li>
<li><p>Convolution of the model spectra with instrumental FWHM or         photometric filter can be performed using ‘instru_res’ and/or         ‘filter_reader’ (done before resampling to observed).</p></li>
<li><p>The weight of each observed point will be directly proportional to         Delta lbda_i/lbda_i, where Delta lbda_i is either the FWHM of the         photometric filter (imager) or the width of the spectral channel (IFS).</p></li>
<li><p>MCMC convergence criterion can either be based on auto-correlation         time (default) or the Gelman-Rubin test.</p></li>
</ul>
</dd>
</dl>
<p>The result of this procedure is a chain with the samples from the posterior
distributions of each of the free parameters in the model.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>lbda_obs</strong> (<em>numpy 1d ndarray</em><em> or </em><em>list</em>) – Wavelengths of observed spectrum. If several instruments were used, the
wavelengths should be ordered per instrument, not necessarily as
monotonically increasing wavelength. Hereafter, <span class="math notranslate nohighlight">\(n_{ch}\)</span> is the
length of <code class="docutils literal notranslate"><span class="pre">lbda_obs</span></code>.</p></li>
<li><p><strong>spec_obs</strong> (<em>numpy 1d ndarray</em><em> or </em><em>list</em>) – Observed spectrum for each value of <code class="docutils literal notranslate"><span class="pre">lbda_obs</span></code>. Should have a length
of <span class="math notranslate nohighlight">\(n_{ch}\)</span>.</p></li>
<li><p><strong>err_obs</strong> (<em>numpy 1d/2d ndarray</em><em> or </em><em>list</em>) – Uncertainties on the observed spectrum. The array (list) can have either
a length of <span class="math notranslate nohighlight">\(n_{ch}\)</span>, or a shape of <span class="math notranslate nohighlight">\((2,n_{ch})\)</span> for lower
(first column) and upper (second column) uncertainties provided.</p></li>
<li><p><strong>dist</strong> (<em>float</em>) – Distance in parsec, used for flux scaling of the models.</p></li>
<li><p><strong>grid_param_list</strong> (<em>list of 1d numpy arrays/lists</em>) – Should contain list/numpy 1d arrays with available grid of model
parameters (should only contain the sampled parameters, not the models
themselves). The models will be loaded with <code class="docutils literal notranslate"><span class="pre">model_reader</span></code>.</p></li>
<li><p><strong>initial_state</strong> (<em>tuple of floats</em>) – <p>Initial guess on the best fit parameters of the spectral fit. Length of
the tuple should match the total number of free parameters. Walkers
will all be initialised in a small ball of parameter space around that
first guess.</p>
<ul>
<li><p>first all parameters related to loaded models (e.g. ‘Teff’, ‘logg’)</p></li>
<li><p>then the planet photometric radius ‘R’, in Jupiter radius</p></li>
<li><p>(optionally) the intensity of emission lines (labels must match         those in the em_lines dict), in units of the model spectrum (x mu)</p></li>
<li><p>(optionally) the optical extinction ‘Av’, in mag</p></li>
<li><p>(optionally) the ratio of total to selective optical extinction ‘Rv’</p></li>
<li><p>(optionally) ‘Tbb1’, ‘Rbb1’, ‘Tbb2’, ‘Rbb2’, etc. for each extra bb         contribution</p></li>
</ul>
</p></li>
<li><p><strong>labels</strong> (<em>Tuple of strings</em>) – <dl class="simple">
<dt>Tuple of labels in the same order as initial_state:</dt><dd><ul>
<li><p>first all parameters related to loaded models (e.g. ‘Teff’, ‘logg’)</p></li>
<li><p>then the planet photometric radius ‘R’, in Jupiter radius</p></li>
<li><p>(optionally) the flux of emission lines (labels should match those             in the em_lines dictionary), in units of the model spectrum (times mu)</p></li>
<li><p>(optionally) the optical extinction ‘Av’, in mag</p></li>
<li><p>(optionally) the ratio of total to selective optical extinction ‘Rv’</p></li>
<li><p>(optionally) ‘Tbb1’, ‘Rbb1’, ‘Tbb2’, ‘Rbb2’, etc. for each extra bb             contribution.</p></li>
</ul>
</dd>
</dl>
</p></li>
<li><p><strong>bounds</strong> (<em>dictionary</em>) – <p>Each entry should be associated with a tuple corresponding to lower and
upper bounds respectively. Bounds should be provided for ALL model
parameters, including ‘R’ (planet photometric radius). ‘Av’ (optical
extinction) is optional. If provided here, Av will also be fitted.
All keywords that are neither ‘R’, ‘Av’ nor ‘M’ will
be considered model grid parameters.</p>
<dl>
<dt>Examples:</dt><dd><div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">bounds</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;Teff&#39;</span><span class="p">:(</span><span class="mi">1000</span><span class="p">,</span><span class="mi">2000</span><span class="p">),</span> <span class="s1">&#39;logg&#39;</span><span class="p">:(</span><span class="mf">3.0</span><span class="p">,</span><span class="mf">4.5</span><span class="p">),</span> <span class="s1">&#39;R&#39;</span><span class="p">:(</span><span class="mf">0.1</span><span class="p">,</span><span class="mi">5</span><span class="p">)}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bounds</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;Teff&#39;</span><span class="p">:(</span><span class="mi">1000</span><span class="p">,</span><span class="mi">2000</span><span class="p">),</span> <span class="s1">&#39;logg&#39;</span><span class="p">:(</span><span class="mf">3.0</span><span class="p">,</span><span class="mf">4.5</span><span class="p">),</span> <span class="s1">&#39;R&#39;</span><span class="p">:(</span><span class="mf">0.1</span><span class="p">,</span><span class="mi">5</span><span class="p">),</span>
<span class="gp">&gt;&gt;&gt; </span>          <span class="s1">&#39;Av&#39;</span><span class="p">:(</span><span class="mf">0.</span><span class="p">,</span><span class="mf">2.5</span><span class="p">),</span> <span class="s1">&#39;Rv&#39;</span><span class="p">:(</span><span class="mi">1</span><span class="p">,</span><span class="mi">5</span><span class="p">)}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bounds</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;Teff&#39;</span><span class="p">:(</span><span class="mi">1000</span><span class="p">,</span><span class="mi">2000</span><span class="p">),</span> <span class="s1">&#39;logg&#39;</span><span class="p">:(</span><span class="mf">3.0</span><span class="p">,</span><span class="mf">4.5</span><span class="p">),</span> <span class="s1">&#39;R&#39;</span><span class="p">:(</span><span class="mf">0.1</span><span class="p">,</span><span class="mi">5</span><span class="p">),</span>
<span class="gp">&gt;&gt;&gt; </span>          <span class="s1">&#39;Av&#39;</span><span class="p">:(</span><span class="mf">0.</span><span class="p">,</span><span class="mf">2.5</span><span class="p">),</span> <span class="s1">&#39;BrG&#39;</span><span class="p">:(</span><span class="mf">1e-17</span><span class="p">,</span><span class="mf">1e-15</span><span class="p">)}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bounds</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;Teff&#39;</span><span class="p">:(</span><span class="mi">2000</span><span class="p">,</span><span class="mi">3000</span><span class="p">),</span> <span class="s1">&#39;logg&#39;</span><span class="p">:(</span><span class="mf">3.0</span><span class="p">,</span><span class="mf">4.5</span><span class="p">),</span> <span class="s1">&#39;R&#39;</span><span class="p">:(</span><span class="mf">1.</span><span class="p">,</span><span class="mf">5.</span><span class="p">),</span>
<span class="gp">&gt;&gt;&gt; </span>          <span class="s1">&#39;Tbb1&#39;</span><span class="p">:(</span><span class="mi">500</span><span class="p">,</span><span class="mi">1500</span><span class="p">),</span> <span class="s1">&#39;Rbb1&#39;</span><span class="p">:(</span><span class="mf">0.1</span><span class="p">,</span><span class="mf">1.</span><span class="p">)}</span>
</pre></div>
</div>
</dd>
</dl>
</p></li>
<li><p><strong>resamp_before</strong> (<em>bool</em><em>, </em><em>optional</em>) – Whether to prepare the whole grid of resampled models before entering
the MCMC, i.e. to avoid doing it at every MCMC step. Recommended.
Only reason not to: model grid is too large and individual models
require being opened and resampled at each step.</p></li>
<li><p><strong>model_grid</strong> (<em>numpy N-d array</em><em>, </em><em>optional</em>) – If provided, should contain the grid of model spectra for each
free parameter of the given grid. I.e. for a grid of <span class="math notranslate nohighlight">\(n_T\)</span> values
of <span class="math notranslate nohighlight">\(T_{eff}\)</span> and <span class="math notranslate nohighlight">\(n_g\)</span> values of log(<span class="math notranslate nohighlight">\(g\)</span>), the numpy
array should have a shape of <span class="math notranslate nohighlight">\((n_T, n_g, n_{ch}, 2)\)</span>, where the
last 2 dimensions correspond to wavelength and fluxes respectively. If
provided, <code class="docutils literal notranslate"><span class="pre">model_grid</span></code> takes precedence over <code class="docutils literal notranslate"><span class="pre">model_name</span></code>/
<code class="docutils literal notranslate"><span class="pre">model_reader</span></code>.</p></li>
<li><p><strong>model_reader</strong> (<em>python routine</em><em>, </em><em>opt</em>) – External routine that reads a model file and returns a 2D numpy array,
where the first column corresponds to wavelengths, and the second
contains model values. See example routine in
<code class="docutils literal notranslate"><span class="pre">special.model_resampling.interpolate_model</span></code> description.</p></li>
<li><p><strong>em_lines</strong> (<em>dictionary</em><em>, </em><em>opt</em>) – <p>Dictionary of emission lines to be added on top of the model spectrum.
Each dict entry should be the name of the line, assigned to a tuple of
4 values:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>the wavelength (in <span class="math notranslate nohighlight">\(\mu\)</span> m);</p></li>
<li><p>a string indicating whether line intensity is expressed in flux
(‘F’), luminosity (‘L’) or log(L/LSun) (“LogL”);</p></li>
<li><p>the FWHM of the gaussian (or None if to be set automatically);</p></li>
<li><p>whether the FWHM is expressed in ‘nm’, ‘mu’ or ‘km/s’.</p></li>
</ol>
</div></blockquote>
<p>The third and fourth can also be set to None. In that case, the FWHM of
the gaussian will automatically be set to the equivalent width of the
line, calculated from the flux to be injected and the continuum
level (measured in the grid model to which the line is injected).</p>
<dl>
<dt>Examples:</dt><dd><div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">em_lines</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;BrG&#39;</span><span class="p">:(</span><span class="mf">2.1667</span><span class="p">,</span><span class="s1">&#39;F&#39;</span><span class="p">,</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">)}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em_lines</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;BrG&#39;</span><span class="p">:(</span><span class="mf">2.1667</span><span class="p">,</span><span class="s1">&#39;LogL&#39;</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="s1">&#39;km/s&#39;</span><span class="p">)}</span>
</pre></div>
</div>
</dd>
</dl>
</p></li>
<li><p><strong>em_grid</strong> (<em>dictionary pointing to lists</em><em>, </em><em>opt</em>) – <p>Dictionary where each entry corresponds to an emission line and points
to a list of values to inject for emission line fluxes. For computation
efficiency, interpolation will be performed between the points of this
grid during the MCMC sampling. Dictionary entries should match those in
<code class="docutils literal notranslate"><span class="pre">labels</span></code> and <code class="docutils literal notranslate"><span class="pre">em_lines</span></code>.</p>
<dl>
<dt>Examples:</dt><dd><div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">BrGmin</span><span class="p">,</span> <span class="n">BrGmax</span> <span class="o">=</span> <span class="o">-</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em_grid</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;BrG&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">BrGmin</span><span class="p">,</span> <span class="n">BrGmax</span><span class="p">,</span> <span class="mi">20</span><span class="p">)}</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">BrGmin</span><span class="p">,</span> <span class="n">BrGmax</span> <span class="o">=</span> <span class="o">-</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">PaBmin</span><span class="p">,</span> <span class="n">PaBmax</span> <span class="o">=</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">7</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em_grid</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;PaB&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">PaBmin</span><span class="p">,</span> <span class="n">PaBmax</span><span class="p">,</span> <span class="mi">20</span><span class="p">),</span>
<span class="gp">&gt;&gt;&gt; </span>           <span class="s1">&#39;BrG&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">BrGmin</span><span class="p">,</span> <span class="n">BrGmax</span><span class="p">,</span> <span class="mi">20</span><span class="p">)}</span>
</pre></div>
</div>
</dd>
</dl>
</p></li>
<li><p><strong>dlbda_obs</strong> (<em>numpy 1d ndarray</em><em> or </em><em>list</em><em>, </em><em>optional</em>) – Respective spectral channel width or FWHM of the photometric filters
used for each point of the observed spectrum. This vector is used to
infer which part(s) of a combined spectro+photometric spectrum should
involve convolution+subsampling (model resolution higher than
measurements), interpolation (the opposite), or convolution by the
transmission curve of a photometric filter. If not provided, it will be
inferred from the difference between consecutive lbda_obs points (i.e.
inaccurate for a combined spectrum). It must be provided IF one wants to
weigh each measurement based on the spectral resolution of each
instrument (as in <a class="reference internal" href="#olo16" id="id13"><span>[OLO16]</span></a>), through the <code class="docutils literal notranslate"><span class="pre">use_weights</span></code> argument.</p></li>
<li><p><strong>instru_corr</strong> (<em>numpy 2d ndarray</em><em>, </em><em>optional</em>) – Spectral correlation between post-processed images in which the
spectrum is measured. It is specific to the instrument, PSF subtraction
algorithm and radial separation of the companion from the central star.
Can be computed using <code class="docutils literal notranslate"><span class="pre">special.spec_corr.spectral_correlation</span></code>. In
case of a spectrum obtained with different instruments, it is
recommended to construct the final spectral_correlation matrix with
<code class="docutils literal notranslate"><span class="pre">special.spec_corr.combine_corrs</span></code>. If <code class="docutils literal notranslate"><span class="pre">instru_corr</span></code> is not provided,
the uncertainties in each spectral channel will be considered
independent. See <a class="reference internal" href="#gre16" id="id14"><span>[GRE16]</span></a> for more details.</p></li>
<li><p><strong>instru_res</strong> (<em>float</em><em> or </em><em>list of floats/strings</em><em>, </em><em>optional</em>) – The mean instrumental resolving power(s) OR filter names. This is
used to convolve the model spectrum. If several instruments are used,
provide a list of resolving power values / filter names, one for
each instrument used.</p></li>
<li><p><strong>instru_idx</strong> (<em>numpy 1d array</em><em>, </em><em>optional</em>) – 1d array containing an index representing each instrument used
to obtain the spectrum, label them from 0 to the number of instruments
(<span class="math notranslate nohighlight">\(n_{ins}\)</span>). Zero for points that don’t correspond to any of the
<code class="docutils literal notranslate"><span class="pre">instru_res</span></code> values provided, and i in <span class="math notranslate nohighlight">\([1,n_{ins}]\)</span> for points
associated to instru_res[i-1]. This parameter must be provided if the
spectrum consists of points obtained with different instruments.</p></li>
<li><p><strong>use_weights</strong> (<em>bool</em><em>, </em><em>optional</em>) – For the likelihood calculation, whether to weigh each point of the
spectrum based on the spectral resolution or bandwidth of photometric
filters used. Weights will be proportional to <code class="docutils literal notranslate"><span class="pre">dlbda_obs/lbda_obs</span></code> if
<code class="docutils literal notranslate"><span class="pre">dlbda_obs</span></code> is provided, or set to 1 for all points otherwise.</p></li>
<li><p><strong>filter_reader</strong> (<em>python routine</em><em>, </em><em>optional</em>) – <p>External routine that reads a filter file and returns a 2D numpy array,
where the first column corresponds to wavelengths, and the second
contains transmission values. Important: if not provided, but strings
are detected in instru_res, the default file reader will be used.
It assumes the following format for the files:</p>
<ul>
<li><p>first row contains headers (titles of each column)</p></li>
<li><p>starting from 2nd row: 1st column: wavelength, 2nd col.: transmission</p></li>
<li><p>Unit of wavelength can be provided in parentheses of first header         key name: e.g. “WL(AA)” for angstrom, “wavelength(mu)” for micrometer         or “lambda(nm)” for nanometer. Note: only what is in parentheses         matters for the units.</p></li>
</ul>
</p></li>
<li><p><strong>AV_bef_bb</strong> (<em>bool</em><em>, </em><em>optional</em>) – If both extinction and an extra bb component are free parameters,
whether to apply extinction before adding the BB component (e.g.
extinction mostly from circumplanetary dust) or after the BB component
(e.g. mostly insterstellar extinction).</p></li>
<li><p><strong>units_obs</strong> (<em>str</em><em>, </em><em>opt {'si'</em><em>,</em><em>'cgs'</em><em>,</em><em>'jy'}</em>) – Units of observed spectrum. ‘si’ for W/m^2/mu; ‘cgs’ for ergs/s/cm^2/mu
or ‘jy’ for janskys.</p></li>
<li><p><strong>units_mod</strong> (<em>str</em><em>, </em><em>opt {'si'</em><em>,</em><em>'cgs'</em><em>,</em><em>'jy'}</em>) – Units of the model. ‘si’ for W/m^2/mu; ‘cgs’ for ergs/s/cm^2/mu or ‘jy’
for janskys. If different to units_obs, the spectrum units will be
converted.</p></li>
<li><p><strong>interp_order</strong> (<em>int</em><em>, </em><em>opt</em><em>, </em><em>{-1</em><em>,</em><em>0</em><em>,</em><em>1}</em>) – <dl class="simple">
<dt>Interpolation mode for model interpolation.</dt><dd><ul>
<li><p>-1: log interpolation (i.e. linear interpolatlion on log(Flux))</p></li>
<li><p>0: nearest neighbour model</p></li>
<li><p>1: Order 1 spline interpolation</p></li>
</ul>
</dd>
</dl>
</p></li>
<li><p><strong>priors</strong> (<em>dictionary</em><em>, </em><em>opt</em>) – <p>If not None, sets prior estimates for each parameter of the model. Each
entry should be set to either None (no prior) or a tuple of 2 elements
containing prior estimate and uncertainty on the estimate.
Missing entries (i.e. provided in <code class="docutils literal notranslate"><span class="pre">bounds</span></code> dictionary but not here)
will be associated no prior.
‘M’ can be used for a prior on the mass of the planet. In that case the
corresponding prior log probability is computed from the values for
parameters ‘logg’ and ‘R’.</p>
<dl>
<dt>Examples:</dt><dd><div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">priors</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;logg&#39;</span><span class="p">:(</span><span class="mf">3.5</span><span class="p">,</span><span class="mf">0.2</span><span class="p">),</span> <span class="s1">&#39;Rv&#39;</span><span class="p">:(</span><span class="mf">3.1</span><span class="p">,</span><span class="mf">0.2</span><span class="p">)}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">priors</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;Teff&#39;</span><span class="p">:(</span><span class="mi">1600</span><span class="p">,</span><span class="mi">100</span><span class="p">),</span> <span class="s1">&#39;logg&#39;</span><span class="p">:(</span><span class="mf">3.5</span><span class="p">,</span><span class="mf">0.5</span><span class="p">),</span> <span class="s1">&#39;R&#39;</span><span class="p">:(</span><span class="mf">1.6</span><span class="p">,</span><span class="mf">0.1</span><span class="p">),</span>
<span class="gp">&gt;&gt;&gt; </span>          <span class="s1">&#39;Av&#39;</span><span class="p">:(</span><span class="mf">1.8</span><span class="p">,</span><span class="mf">0.2</span><span class="p">),</span> <span class="s1">&#39;M&#39;</span><span class="p">:(</span><span class="mi">10</span><span class="p">,</span><span class="mi">3</span><span class="p">)}</span>
</pre></div>
</div>
</dd>
</dl>
<p>Important: dictionary entry names should match exactly those of
<code class="docutils literal notranslate"><span class="pre">bounds</span></code>.</p>
</p></li>
<li><p><strong>physical</strong> (<em>bool</em><em>, </em><em>opt</em>) – In case of extra black body component(s) to a photosphere, whether to
force lower temperature than the photosphere effective temperature.</p></li>
<li><p><strong>interp_nonexist</strong> (<em>bool</em><em>, </em><em>opt</em>) – Whether to interpolate non-existing models in the grid. Only used if
resamp_before is set to True.</p></li>
<li><p><strong>ini_ball</strong> (<em>float</em><em> or </em><em>string</em><em>, </em><em>default=1e-1</em>) – Size of the initial ball in parameter space from which walkers start
their chain. If “uniform” is provided, a uniform ini_ball spanning
the bounds interval will be used to initialise walkers.</p></li>
<li><p><strong>a</strong> (<em>float</em><em>, </em><em>default=2.0</em>) – The proposal scale parameter. See notes.</p></li>
<li><p><strong>nwalkers</strong> (<em>int</em><em>, </em><em>default: 1000</em>) – Number of walkers</p></li>
<li><p><strong>niteration_min</strong> (<em>int</em><em>, </em><em>optional</em>) – Steps per walker lower bound. The simulation will run at least this
number of steps per walker.</p></li>
<li><p><strong>niteration_limit</strong> (<em>int</em><em>, </em><em>optional</em>) – Steps per walker upper bound. If the simulation runs up to
‘niteration_limit’ steps without having reached the convergence
criterion, the run is stopped.</p></li>
<li><p><strong>niteration_supp</strong> (<em>int</em><em>, </em><em>optional</em>) – Number of iterations to run after having “reached the convergence”.</p></li>
<li><p><strong>burnin</strong> (<em>float</em><em>, </em><em>default=0.3</em>) – The fraction of a walker which is discarded.</p></li>
<li><p><strong>rhat_threshold</strong> (<em>float</em><em>, </em><em>default=0.01</em>) – The Gelman-Rubin threshold used for the test for nonconvergence.</p></li>
<li><p><strong>rhat_count_threshold</strong> (<em>int</em><em>, </em><em>optional</em>) – The Gelman-Rubin test must be satisfied ‘rhat_count_threshold’ times in
a row before claiming that the chain has converged.</p></li>
<li><p><strong>check_maxgap</strong> (<em>int</em><em>, </em><em>optional</em>) – Maximum number of steps per walker between two convergence tests.</p></li>
<li><p><strong>conv_test</strong> (<em>str</em><em>, </em><em>optional {'gb'</em><em>,</em><em>'autocorr'}</em>) – <dl class="simple">
<dt>Method to check for convergence:</dt><dd><ul>
<li><p>’gb’ for gelman-rubin test                 (<a class="reference external" href="http://digitalassets.lib.berkeley.edu/sdtr/ucb/text/305.pdf">http://digitalassets.lib.berkeley.edu/sdtr/ucb/text/305.pdf</a>)</p></li>
<li><p>’autocorr’ for autocorrelation analysis                 (<a class="reference external" href="https://emcee.readthedocs.io/en/stable/tutorials/autocorr/">https://emcee.readthedocs.io/en/stable/tutorials/autocorr/</a>)</p></li>
</ul>
</dd>
</dl>
</p></li>
<li><p><strong>nproc</strong> (<em>int</em><em>, </em><em>optional</em>) – The number of processes to use for parallelization.</p></li>
<li><p><strong>grid_name</strong> (<em>str</em><em>, </em><em>optional</em>) – Name of the fits file containing the model grid (numpy array) AFTER
convolution+resampling as the observed spectrum given as input.
If provided, will read it if it exists (and resamp_before is set
to True), or make it and write it if it doesn’t.</p></li>
<li><p><strong>output_dir</strong> (<em>str</em><em>, </em><em>optional</em>) – The name of the output directory which contains the output files in the
case  <code class="docutils literal notranslate"><span class="pre">save</span></code> is True.</p></li>
<li><p><strong>output_file</strong> (<em>str</em><em>, </em><em>optional</em>) – The name of the output file which contains the MCMC results in the case
<code class="docutils literal notranslate"><span class="pre">save</span></code> is True.</p></li>
<li><p><strong>display</strong> (<em>bool</em><em>, </em><em>optional</em>) – If True, the walk plot is displayed at each evaluation of the Gelman-
Rubin test.</p></li>
<li><p><strong>verbosity</strong> (<em>0</em><em>, </em><em>1</em><em> or </em><em>2</em><em>, </em><em>optional</em>) – Verbosity level. 0 for no output and 2 for full information.</p></li>
<li><p><strong>save</strong> (<em>bool</em><em>, </em><em>optional</em>) – If True, the MCMC results are pickled.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>out</strong> (<em>numpy.array</em>) – The MCMC samples after truncation of zeros.</p></li>
<li><p><strong>lnprobability</strong> (<em>emcee sample object</em>) – The corresponding probabilities for each sample</p></li>
</ul>
</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<ul class="simple">
<li><p>The parameter <cite>a</cite> must be &gt; 1. For more theoretical information concerning
this parameter, see <a class="reference internal" href="#goo10" id="id15"><span>[GOO10]</span></a>.</p></li>
<li><p>The parameter ‘rhat_threshold’ can be a numpy.array with individual
threshold value for each model parameter.</p></li>
<li><p>If several filter filenames are provided in <code class="docutils literal notranslate"><span class="pre">instru_res</span></code>, the filter files
must all have the same format and wavelength units (for reading by the same
<code class="docutils literal notranslate"><span class="pre">filter_reader</span></code> snippet or default function).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">grid_param_list</span></code> and <code class="docutils literal notranslate"><span class="pre">model_grid</span></code> shouldn’t contain grids on radius
and Av. For a combined grid model + black body fit, just provide the list
of parameters probed by the grid to <code class="docutils literal notranslate"><span class="pre">grid_param_list</span></code>, and provide values
for ‘Tbbn’ and ‘Rbbn’ to <code class="docutils literal notranslate"><span class="pre">initial_state</span></code>, <code class="docutils literal notranslate"><span class="pre">labels</span></code> and <code class="docutils literal notranslate"><span class="pre">bounds</span></code>.</p></li>
</ul>
</div>
<p class="rubric">Examples</p>
<p>This is a minimal example for the file_reader routine to be provided     as argument to model_interpolation. The routine should only take as     inputs grid parameters, and returns as output: both the wavelengths and     model values as a 2D numpy array.    This example assumes the model is in a fits file, that is already a 2D    numpy array, where the first column is the wavelength, and 2nd column     is the corresponding model values.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">_example_file_reader</span><span class="p">(</span><span class="n">params</span><span class="p">):</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="n">model</span> <span class="o">=</span> <span class="n">open_fits</span><span class="p">(</span><span class="n">filename</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">params</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="k">return</span> <span class="n">model</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="special.mcmc_sampling.show_corner_plot">
<span class="sig-prename descclassname"><span class="pre">special.mcmc_sampling.</span></span><span class="sig-name descname"><span class="pre">show_corner_plot</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">chain</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">burnin</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">save</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">output_dir</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">''</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mcmc_res</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">units</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ndig</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">labels_plot</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">plot_name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'corner_plot.pdf'</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/special/mcmc_sampling.html#show_corner_plot"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#special.mcmc_sampling.show_corner_plot" title="Permalink to this definition"></a></dt>
<dd><p>Display/save a figure showing the corner plot (pdfs + correlation plots).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>chain</strong> (<em>numpy.array</em>) – The Markov chain. The shape of chain must be nwalkers x length x dim.
If a part of the chain is filled with zero values, the method will
discard these steps.</p></li>
<li><p><strong>burnin</strong> (<em>float</em><em>, </em><em>default: 0</em>) – The fraction of a walker we want to discard.</p></li>
<li><p><strong>save</strong> (<em>boolean</em><em>, </em><em>default: False</em>) – If True, a pdf file is created.</p></li>
<li><p><strong>output_dir</strong> (<em>str</em><em>, </em><em>optional</em>) – The name of the output directory which contains the output files in the
case  <code class="docutils literal notranslate"><span class="pre">save</span></code> is True.</p></li>
<li><p><strong>mcmc_res</strong> (<em>numpy array OR tuple of 2 dictionaries/np.array</em><em>, </em><em>opt</em>) – <p>Values to be printed on top of each 1d posterior distribution</p>
<ul>
<li><dl class="simple">
<dt>if numpy array:             - shape <span class="math notranslate nohighlight">\((n_{par},3)\)</span>, with <span class="math notranslate nohighlight">\((n_{par}\)</span> the number of             parameters, with the first, second and third rows containing the             most likely value of each parameter and the lower and upper             uncertainties at the desired quantiles, respectively.</dt><dd><ul>
<li><p>shape <span class="math notranslate nohighlight">\((n_{par},2)\)</span>: same as above but with a single value             for the uncertainty.</p></li>
</ul>
</dd>
</dl>
</li>
<li><p>if tuple of 2 dictionaries: output of         <code class="docutils literal notranslate"><span class="pre">special.mcm_sampling.spec_confidence</span></code> without gaussian fit.</p></li>
<li><p>if tuple of 2 np.array: output of         <code class="docutils literal notranslate"><span class="pre">special.mcm_sampling.spec_confidence</span></code> with gaussian fit.</p></li>
</ul>
</p></li>
<li><p><strong>units</strong> (<em>tuple</em><em>, </em><em>opt</em>) – Tuple of strings containing units for each parameter. If provided,
mcmc_res will be printed on top of each 1d posterior distribution along
with these units.</p></li>
<li><p><strong>ndig</strong> (<em>tuple</em><em>, </em><em>opt</em>) – Number of digits precision for each printed parameter</p></li>
<li><p><strong>labels_plot</strong> (<em>tuple</em><em>, </em><em>opt</em>) – Labels corresponding to parameter names, used for the plot. If None,
will use <code class="docutils literal notranslate"><span class="pre">label</span></code> passed in kwargs.</p></li>
<li><p><strong>kwargs</strong> – Additional attributes passed to the <code class="docutils literal notranslate"><span class="pre">corner.corner</span></code> method.
(e.g. <code class="docutils literal notranslate"><span class="pre">labels</span></code>, <code class="docutils literal notranslate"><span class="pre">labels_tit</span></code>, <code class="docutils literal notranslate"><span class="pre">labels_tit_unit</span></code>, <code class="docutils literal notranslate"><span class="pre">title_kwargs</span></code>)</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><em>Display the figure or create a pdf file named walk_plot.pdf in the working</em></p></li>
<li><p><em>directory.</em></p></li>
</ul>
</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>ImportError</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="special.mcmc_sampling.show_walk_plot">
<span class="sig-prename descclassname"><span class="pre">special.mcmc_sampling.</span></span><span class="sig-name descname"><span class="pre">show_walk_plot</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">chain</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">labels</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">save</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">output_dir</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">''</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ntrunc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/special/mcmc_sampling.html#show_walk_plot"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#special.mcmc_sampling.show_walk_plot" title="Permalink to this definition"></a></dt>
<dd><p>Display/save a figure showing the path of each walker during the MCMC run.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>chain</strong> (<em>numpy.array</em>) – The Markov chain. The shape of chain must be nwalkers x length x dim.
If a part of the chain is filled with zero values, the method will
discard these steps.</p></li>
<li><p><strong>labels</strong> (<em>Tuple of strings</em>) – <dl class="simple">
<dt>Tuple of labels in the same order as initial_state:</dt><dd><ul>
<li><p>first all parameters related to loaded models (e.g. ‘Teff’, ‘logg’)</p></li>
<li><p>then the planet photometric radius ‘R’, in Jupiter radius</p></li>
<li><p>(optionally) the flux of emission lines (labels should match those             in the em_lines dictionary), in units of the model spectrum (times mu)</p></li>
<li><p>(optionally) the optical extinction ‘Av’, in mag</p></li>
<li><p>(optionally) the ratio of total to selective optical extinction ‘Rv’</p></li>
<li><p>(optionally) ‘Tbb1’, ‘Rbb1’, ‘Tbb2’, ‘Rbb2’, etc. for each extra bb             contribution.</p></li>
</ul>
</dd>
</dl>
</p></li>
<li><p><strong>save</strong> (<em>boolean</em><em>, </em><em>default: False</em>) – If True, a pdf file is created.</p></li>
<li><p><strong>output_dir</strong> (<em>str</em><em>, </em><em>optional</em>) – The name of the output directory which contains the output files in the
case  <code class="docutils literal notranslate"><span class="pre">save</span></code> is True.</p></li>
<li><p><strong>ntrunc</strong> (<em>int</em><em>, </em><em>opt</em>) – max number of walkers plotted. If too many walkers the plot will become
too voluminous and too crowded. Plot will be truncated to only ntrunc
first walkers</p></li>
<li><p><strong>kwargs</strong> – Additional attributes are passed to the matplotlib plot method.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><em>Display the figure or create a pdf file named walk_plot.pdf in the working</em></p></li>
<li><p><em>directory.</em></p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-special.model_resampling">
<span id="special-model-resampling-module"></span><h2>special.model_resampling module<a class="headerlink" href="#module-special.model_resampling" title="Permalink to this headline"></a></h2>
<p>Functions useful for spectral fitting of companions, and model interpolation.</p>
<dl class="py function">
<dt class="sig sig-object py" id="special.model_resampling.interpolate_model">
<span class="sig-prename descclassname"><span class="pre">special.model_resampling.</span></span><span class="sig-name descname"><span class="pre">interpolate_model</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">params</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">grid_param_list</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">params_em</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">{}</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">em_grid</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">{}</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">em_lines</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">{}</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">labels</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">model_grid</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">model_reader</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">interp_order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_dlbda</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0002</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/special/model_resampling.html#interpolate_model"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#special.model_resampling.interpolate_model" title="Permalink to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>params</strong> (<em>tuple</em>) – Set of models parameters for which the model grid has to be
interpolated.</p></li>
<li><p><strong>grid_param_list</strong> (<em>list of 1d numpy arrays/lists</em>) – Should contain list/numpy 1d arrays with available grid of model
parameters (should only contain the sampled parameters, not the models
themselves). The models will be loaded with <code class="docutils literal notranslate"><span class="pre">model_reader</span></code>.</p></li>
<li><p><strong>params_em</strong> (<em>dictionary</em><em>, </em><em>opt</em>) – Set of emission line parameters (typically fluxes) for which the model
grid has to be interpolated.</p></li>
<li><p><strong>em_grid</strong> (<em>dictionary pointing to lists</em><em>, </em><em>opt</em>) – <p>Dictionary where each entry corresponds to an emission line and points
to a list of values to inject for emission line fluxes. For computation
efficiency, interpolation will be performed between the points of this
grid during the MCMC sampling. Dictionary entries should match those in
<code class="docutils literal notranslate"><span class="pre">labels</span></code> and <code class="docutils literal notranslate"><span class="pre">em_lines</span></code>.</p>
<dl>
<dt>Examples:</dt><dd><div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">BrGmin</span><span class="p">,</span> <span class="n">BrGmax</span> <span class="o">=</span> <span class="o">-</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em_grid</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;BrG&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">BrGmin</span><span class="p">,</span> <span class="n">BrGmax</span><span class="p">,</span> <span class="mi">20</span><span class="p">)}</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">BrGmin</span><span class="p">,</span> <span class="n">BrGmax</span> <span class="o">=</span> <span class="o">-</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">PaBmin</span><span class="p">,</span> <span class="n">PaBmax</span> <span class="o">=</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">7</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em_grid</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;PaB&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">PaBmin</span><span class="p">,</span> <span class="n">PaBmax</span><span class="p">,</span> <span class="mi">20</span><span class="p">),</span>
<span class="gp">&gt;&gt;&gt; </span>           <span class="s1">&#39;BrG&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">BrGmin</span><span class="p">,</span> <span class="n">BrGmax</span><span class="p">,</span> <span class="mi">20</span><span class="p">)}</span>
</pre></div>
</div>
</dd>
</dl>
</p></li>
<li><p><strong>em_lines</strong> (<em>dictionary</em><em>, </em><em>opt</em>) – <p>Dictionary of emission lines to be added on top of the model spectrum.
Each dict entry should be the name of the line, assigned to a tuple of
4 values:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>the wavelength (in <span class="math notranslate nohighlight">\(\mu\)</span> m);</p></li>
<li><p>a string indicating whether line intensity is expressed in flux             (‘F’), luminosity (‘L’) or log(L/LSun) (“LogL”);</p></li>
<li><p>the FWHM of the gaussian (or None if to be set automatically);</p></li>
<li><p>whether the FWHM is expressed in ‘nm’, ‘mu’ or ‘km/s’.</p></li>
</ol>
</div></blockquote>
<p>The third and fourth can also be set to None. In that case, the FWHM of
the gaussian will automatically be set to the equivalent width of the
line, calculated from the flux to be injected and the continuum
level (measured in the grid model to which the line is injected).</p>
<dl>
<dt>Examples:</dt><dd><div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">em_lines</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;BrG&#39;</span><span class="p">:(</span><span class="mf">2.1667</span><span class="p">,</span><span class="s1">&#39;F&#39;</span><span class="p">,</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">)};</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em_lines</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;BrG&#39;</span><span class="p">:(</span><span class="mf">2.1667</span><span class="p">,</span><span class="s1">&#39;LogL&#39;</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="s1">&#39;km/s&#39;</span><span class="p">)}</span>
</pre></div>
</div>
</dd>
</dl>
</p></li>
<li><p><strong>labels</strong> (<em>Tuple of strings</em>) – <dl class="simple">
<dt>Tuple of labels in the same order as initial_state:</dt><dd><ul>
<li><p>first all parameters related to loaded models (e.g. ‘Teff’, ‘logg’)</p></li>
<li><p>then the planet photometric radius ‘R’, in Jupiter radius</p></li>
<li><p>(optionally) the flux of emission lines (labels should match those             in the em_lines dictionary), in units of the model spectrum (times mu)</p></li>
<li><p>(optionally) the optical extinction ‘Av’, in mag</p></li>
<li><p>(optionally) the ratio of total to selective optical extinction ‘Rv’</p></li>
<li><p>(optionally) ‘Tbb1’, ‘Rbb1’, ‘Tbb2’, ‘Rbb2’, etc. for each extra bb             contribution.</p></li>
</ul>
</dd>
</dl>
<p>Note: only necessary if an emission line dictionary <code class="docutils literal notranslate"><span class="pre">em_lines</span></code> is provided.</p>
</p></li>
<li><p><strong>model_grid</strong> (<em>numpy N-d array</em><em>, </em><em>optional</em>) – If provided, should contain the grid of model spectra for each
free parameter of the given grid. I.e. for a grid of <span class="math notranslate nohighlight">\(n_T\)</span> values
of <span class="math notranslate nohighlight">\(T_{eff}\)</span> and <span class="math notranslate nohighlight">\(n_g\)</span> values of log(<span class="math notranslate nohighlight">\(g\)</span>), the numpy
array should have a shape of <span class="math notranslate nohighlight">\((n_T, n_g, n_{ch}, 2)\)</span>, where the
last 2 dimensions correspond to wavelength and fluxes respectively. If
provided, <code class="docutils literal notranslate"><span class="pre">model_grid</span></code> takes precedence over <code class="docutils literal notranslate"><span class="pre">model_name</span></code>/
<code class="docutils literal notranslate"><span class="pre">model_reader</span></code>.</p></li>
<li><p><strong>model_reader</strong> (<em>python routine</em><em>, </em><em>opt</em>) – External routine that reads a model file and returns a 2D numpy array,
where the first column corresponds to wavelengths, and the second
contains model values. See example routine in
<code class="docutils literal notranslate"><span class="pre">special.model_resampling.interpolate_model</span></code> description.</p></li>
<li><p><strong>interp_order</strong> (<em>int</em><em>, </em><em>opt</em><em>, </em><em>{-1</em><em>,</em><em>0</em><em>,</em><em>1}</em>) – <dl class="simple">
<dt>Interpolation mode for model interpolation.</dt><dd><ul>
<li><p>-1: log interpolation (i.e. linear interpolatlion on log(Flux))</p></li>
<li><p>0: nearest neighbour model</p></li>
<li><p>1: Order 1 spline interpolation</p></li>
</ul>
</dd>
</dl>
</p></li>
<li><p><strong>max_dlbda</strong> (<em>float</em><em>, </em><em>opt</em>) – Maximum delta lbda in mu allowed if binning of lbda_model is necessary.
This is necessary for grids of models (e.g. BT-SETTL) where the wavelength
sampling is not the same depending on parameters (e.g. between 4000K
and 4100K models for BT-SETTL): resampling preserving original
resolution is too prohibitive computationally.</p></li>
<li><p><strong>verbose</strong> (<em>bool</em><em>, </em><em>optional</em>) – Whether to print more information during resampling.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>model</strong> – Interpolated model for input parameters. First column corresponds
to wavelengths, and the second contains model values.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>2d numpy array</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="special.model_resampling.make_model_from_params">
<span class="sig-prename descclassname"><span class="pre">special.model_resampling.</span></span><span class="sig-name descname"><span class="pre">make_model_from_params</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">params</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">labels</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">grid_param_list</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dist</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lbda_obs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">model_grid</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">model_reader</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">em_lines</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">{}</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">em_grid</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">{}</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dlbda_obs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">instru_res</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">instru_idx</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">filter_reader</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">AV_bef_bb</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">units_obs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'si'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">units_mod</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'si'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">interp_order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/special/model_resampling.html#make_model_from_params"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#special.model_resampling.make_model_from_params" title="Permalink to this definition"></a></dt>
<dd><p>Routine to make the model from input parameters.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>params</strong> (<em>tuple</em>) – Set of models parameters for which the model grid has to be
interpolated.</p></li>
<li><p><strong>labels</strong> (<em>Tuple of strings</em>) – <dl class="simple">
<dt>Tuple of labels in the same order as initial_state:</dt><dd><ul>
<li><p>first all parameters related to loaded models (e.g. ‘Teff’, ‘logg’)</p></li>
<li><p>then the planet photometric radius ‘R’, in Jupiter radius</p></li>
<li><p>(optionally) the flux of emission lines (labels should match those             in the em_lines dictionary), in units of the model spectrum (times mu)</p></li>
<li><p>(optionally) the optical extinction ‘Av’, in mag</p></li>
<li><p>(optionally) the ratio of total to selective optical extinction ‘Rv’</p></li>
<li><p>(optionally) ‘Tbb1’, ‘Rbb1’, ‘Tbb2’, ‘Rbb2’, etc. for each extra bb             contribution.</p></li>
</ul>
</dd>
</dl>
</p></li>
<li><p><strong>grid_param_list</strong> (<em>list of 1d numpy arrays/lists</em>) – Should contain list/numpy 1d arrays with available grid of model
parameters (should only contain the sampled parameters, not the models
themselves). The models will be loaded with <code class="docutils literal notranslate"><span class="pre">model_reader</span></code>.</p></li>
<li><p><strong>dist</strong> (<em>float</em>) – Distance in parsec, used for flux scaling of the models.</p></li>
<li><p><strong>lbda_obs</strong> (<em>numpy 1d ndarray</em><em> or </em><em>list</em>) – Wavelengths of observed spectrum. If several instruments were used, the
wavelengths should be ordered per instrument, not necessarily as
monotonically increasing wavelength. Hereafter, <span class="math notranslate nohighlight">\(n_{ch}\)</span> is the
length of <code class="docutils literal notranslate"><span class="pre">lbda_obs</span></code>.</p></li>
<li><p><strong>model_grid</strong> (<em>numpy N-d array</em><em>, </em><em>optional</em>) – If provided, should contain the grid of model spectra for each
free parameter of the given grid. I.e. for a grid of <span class="math notranslate nohighlight">\(n_T\)</span> values
of <span class="math notranslate nohighlight">\(T_{eff}\)</span> and <span class="math notranslate nohighlight">\(n_g\)</span> values of log(<span class="math notranslate nohighlight">\(g\)</span>), the numpy
array should have a shape of <span class="math notranslate nohighlight">\((n_T, n_g, n_{ch}, 2)\)</span>, where the
last 2 dimensions correspond to wavelength and fluxes respectively. If
provided, <code class="docutils literal notranslate"><span class="pre">model_grid</span></code> takes precedence over <code class="docutils literal notranslate"><span class="pre">model_name</span></code>/
<code class="docutils literal notranslate"><span class="pre">model_reader</span></code>.</p></li>
<li><p><strong>model_reader</strong> (<em>python routine</em><em>, </em><em>opt</em>) – External routine that reads a model file and returns a 2D numpy array,
where the first column corresponds to wavelengths, and the second
contains model values. See example routine in
<code class="docutils literal notranslate"><span class="pre">special.model_resampling.interpolate_model</span></code> description.</p></li>
<li><p><strong>em_lines</strong> (<em>dictionary</em><em>, </em><em>opt</em>) – <p>Dictionary of emission lines to be added on top of the model spectrum.
Each dict entry should be the name of the line, assigned to a tuple of
4 values:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>the wavelength (in <span class="math notranslate nohighlight">\(\mu\)</span> m);</p></li>
<li><p>a string indicating whether line intensity is expressed in flux             (‘F’), luminosity (‘L’) or log(L/LSun) (“LogL”);</p></li>
<li><p>the FWHM of the gaussian (or None if to be set automatically);</p></li>
<li><p>whether the FWHM is expressed in ‘nm’, ‘mu’ or ‘km/s’.</p></li>
</ol>
</div></blockquote>
<p>The third and fourth can also be set to None. In that case, the FWHM of
the gaussian will automatically be set to the equivalent width of the
line, calculated from the flux to be injected and the continuum
level (measured in the grid model to which the line is injected).</p>
<dl>
<dt>Examples:</dt><dd><div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">em_lines</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;BrG&#39;</span><span class="p">:(</span><span class="mf">2.1667</span><span class="p">,</span><span class="s1">&#39;F&#39;</span><span class="p">,</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">)};</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em_lines</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;BrG&#39;</span><span class="p">:(</span><span class="mf">2.1667</span><span class="p">,</span><span class="s1">&#39;LogL&#39;</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="s1">&#39;km/s&#39;</span><span class="p">)}</span>
</pre></div>
</div>
</dd>
</dl>
</p></li>
<li><p><strong>em_grid</strong> (<em>dictionary pointing to lists</em><em>, </em><em>opt</em>) – <p>Dictionary where each entry corresponds to an emission line and points
to a list of values to inject for emission line fluxes. For computation
efficiency, interpolation will be performed between the points of this
grid during the MCMC sampling. Dictionary entries should match those in
<code class="docutils literal notranslate"><span class="pre">labels</span></code> and <code class="docutils literal notranslate"><span class="pre">em_lines</span></code>.</p>
<dl>
<dt>Examples:</dt><dd><div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">BrGmin</span><span class="p">,</span> <span class="n">BrGmax</span> <span class="o">=</span> <span class="o">-</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em_grid</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;BrG&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">BrGmin</span><span class="p">,</span> <span class="n">BrGmax</span><span class="p">,</span> <span class="mi">20</span><span class="p">)}</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">BrGmin</span><span class="p">,</span> <span class="n">BrGmax</span> <span class="o">=</span> <span class="o">-</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">PaBmin</span><span class="p">,</span> <span class="n">PaBmax</span> <span class="o">=</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">7</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em_grid</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;PaB&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">PaBmin</span><span class="p">,</span> <span class="n">PaBmax</span><span class="p">,</span> <span class="mi">20</span><span class="p">),</span>
<span class="gp">&gt;&gt;&gt; </span>           <span class="s1">&#39;BrG&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">BrGmin</span><span class="p">,</span> <span class="n">BrGmax</span><span class="p">,</span> <span class="mi">20</span><span class="p">)}</span>
</pre></div>
</div>
</dd>
</dl>
</p></li>
<li><p><strong>dlbda_obs</strong> (<em>numpy 1d ndarray</em><em> or </em><em>list</em><em>, </em><em>optional</em>) – Respective spectral channel width or FWHM of the photometric filters
used for each point of the observed spectrum. This vector is used to
infer which part(s) of a combined spectro+photometric spectrum should
involve convolution+subsampling (model resolution higher than
measurements), interpolation (the opposite), or convolution by the
transmission curve of a photometric filter. If not provided, it will be
inferred from the difference between consecutive lbda_obs points (i.e.
inaccurate for a combined spectrum). It must be provided IF one wants to
weigh each measurement based on the spectral resolution of each
instrument (as in <a class="reference internal" href="#olo16" id="id16"><span>[OLO16]</span></a>), through the <code class="docutils literal notranslate"><span class="pre">use_weights</span></code> argument.</p></li>
<li><p><strong>instru_res</strong> (<em>float</em><em> or </em><em>list of floats/strings</em><em>, </em><em>optional</em>) – The mean instrumental resolving power(s) OR filter names. This is
used to convolve the model spectrum. If several instruments are used,
provide a list of resolving power values / filter names, one for
each instrument used.</p></li>
<li><p><strong>instru_idx</strong> (<em>numpy 1d array</em><em>, </em><em>optional</em>) – 1d array containing an index representing each instrument used
to obtain the spectrum, label them from 0 to the number of instruments
(<span class="math notranslate nohighlight">\(n_{ins}\)</span>). Zero for points that don’t correspond to any of the
<code class="docutils literal notranslate"><span class="pre">instru_res</span></code> values provided, and i in <span class="math notranslate nohighlight">\([1,n_{ins}]\)</span> for points
associated to instru_res[i-1]. This parameter must be provided if the
spectrum consists of points obtained with different instruments.</p></li>
<li><p><strong>filter_reader</strong> (<em>python routine</em><em>, </em><em>optional</em>) – <p>External routine that reads a filter file and returns a 2D numpy array,
where the first column corresponds to wavelengths, and the second
contains transmission values. Important: if not provided, but strings
are detected in instru_res, the default file reader will be used.
It assumes the following format for the files:</p>
<ul>
<li><p>first row contains headers (titles of each column)</p></li>
<li><p>starting from 2nd row: 1st column: wavelength, 2nd col.: transmission</p></li>
<li><p>Unit of wavelength can be provided in parentheses of first header         key name: e.g. “WL(AA)” for angstrom, “wavelength(mu)” for micrometer         or “lambda(nm)” for nanometer. Note: only what is in parentheses         matters for the units.</p></li>
</ul>
</p></li>
<li><p><strong>AV_bef_bb</strong> (<em>bool</em><em>, </em><em>optional</em>) – If both extinction and an extra bb component are free parameters,
whether to apply extinction before adding the BB component (e.g.
extinction mostly from circumplanetary dust) or after the BB component
(e.g. mostly insterstellar extinction).</p></li>
<li><p><strong>units_obs</strong> (<em>str</em><em>, </em><em>opt {'si'</em><em>,</em><em>'cgs'</em><em>,</em><em>'jy'}</em>) – Units of observed spectrum. ‘si’ for W/m^2/mu; ‘cgs’ for ergs/s/cm^2/mu
or ‘jy’ for janskys.</p></li>
<li><p><strong>units_mod</strong> (<em>str</em><em>, </em><em>opt {'si'</em><em>,</em><em>'cgs'</em><em>,</em><em>'jy'}</em>) – Units of the model. ‘si’ for W/m^2/mu; ‘cgs’ for ergs/s/cm^2/mu or ‘jy’
for janskys. If different to units_obs, the spectrum units will be
converted.</p></li>
<li><p><strong>interp_order</strong> (<em>int</em><em>, </em><em>opt</em><em>, </em><em>{-1</em><em>,</em><em>0</em><em>,</em><em>1}</em>) – <dl class="simple">
<dt>Interpolation mode for model interpolation.</dt><dd><ul>
<li><p>-1: log interpolation (i.e. linear interpolatlion on log(Flux))</p></li>
<li><p>0: nearest neighbour model</p></li>
<li><p>1: Order 1 spline interpolation</p></li>
</ul>
</dd>
</dl>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>out</strong> – The model wavelength and spectrum</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>numpy array</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><code class="docutils literal notranslate"><span class="pre">grid_param_list</span></code> and <code class="docutils literal notranslate"><span class="pre">model_grid</span></code> shouldn’t contain grids on radius
and Av. For a combined grid model + black body fit, just provide the list
of parameters probed by the grid to <code class="docutils literal notranslate"><span class="pre">grid_param_list</span></code>, and provide values
for ‘Tbbn’ and ‘Rbbn’ to <code class="docutils literal notranslate"><span class="pre">initial_state</span></code>, <code class="docutils literal notranslate"><span class="pre">labels</span></code> and <code class="docutils literal notranslate"><span class="pre">bounds</span></code>.</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="special.model_resampling.make_resampled_models">
<span class="sig-prename descclassname"><span class="pre">special.model_resampling.</span></span><span class="sig-name descname"><span class="pre">make_resampled_models</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">lbda_obs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">grid_param_list</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">model_grid</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">model_reader</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">em_lines</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">{}</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">em_grid</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dlbda_obs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">instru_res</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">instru_idx</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">filter_reader</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">interp_nonexist</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/special/model_resampling.html#make_resampled_models"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#special.model_resampling.make_resampled_models" title="Permalink to this definition"></a></dt>
<dd><p>Returns a cube of models after convolution and resampling as in the
observations.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>lbda_obs</strong> (<em>numpy 1d ndarray</em><em> or </em><em>list</em>) – Wavelengths of observed spectrum. If several instruments were used, the
wavelengths should be ordered per instrument, not necessarily as
monotonically increasing wavelength. Hereafter, <span class="math notranslate nohighlight">\(n_{ch}\)</span> is the
length of <code class="docutils literal notranslate"><span class="pre">lbda_obs</span></code>.</p></li>
<li><p><strong>grid_param_list</strong> (<em>list of 1d numpy arrays/lists</em>) – Should contain list/numpy 1d arrays with available grid of model
parameters (should only contain the sampled parameters, not the models
themselves). The models will be loaded with <code class="docutils literal notranslate"><span class="pre">model_reader</span></code>.</p></li>
<li><p><strong>model_grid</strong> (<em>numpy N-d array</em><em>, </em><em>optional</em>) – If provided, should contain the grid of model spectra for each
free parameter of the given grid. I.e. for a grid of <span class="math notranslate nohighlight">\(n_T\)</span> values
of <span class="math notranslate nohighlight">\(T_{eff}\)</span> and <span class="math notranslate nohighlight">\(n_g\)</span> values of log(<span class="math notranslate nohighlight">\(g\)</span>), the numpy
array should have a shape of <span class="math notranslate nohighlight">\((n_T, n_g, n_{ch}, 2)\)</span>, where the
last 2 dimensions correspond to wavelength and fluxes respectively. If
provided, <code class="docutils literal notranslate"><span class="pre">model_grid</span></code> takes precedence over <code class="docutils literal notranslate"><span class="pre">model_name</span></code>/
<code class="docutils literal notranslate"><span class="pre">model_reader</span></code>.</p></li>
<li><p><strong>model_reader</strong> (<em>python routine</em>) – External routine that reads a model file, converts it to required
units and returns a 2D numpy array, where the first column corresponds
to wavelengths, and the second contains model values. Example below.</p></li>
<li><p><strong>em_lines</strong> (<em>dictionary</em><em>, </em><em>opt</em>) – <p>Dictionary of emission lines to be added on top of the model spectrum.
Each dict entry should be the name of the line, assigned to a tuple of
4 values:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>the wavelength (in <span class="math notranslate nohighlight">\(\mu\)</span> m);</p></li>
<li><p>a string indicating whether line intensity is expressed in flux             (‘F’), luminosity (‘L’) or log(L/LSun) (“LogL”);</p></li>
<li><p>the FWHM of the gaussian (or None if to be set automatically);</p></li>
<li><p>whether the FWHM is expressed in ‘nm’, ‘mu’ or ‘km/s’.</p></li>
</ol>
</div></blockquote>
<p>The third and fourth can also be set to None. In that case, the FWHM of
the gaussian will automatically be set to the equivalent width of the
line, calculated from the flux to be injected and the continuum
level (measured in the grid model to which the line is injected).</p>
<dl>
<dt>Examples:</dt><dd><div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">em_lines</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;BrG&#39;</span><span class="p">:(</span><span class="mf">2.1667</span><span class="p">,</span><span class="s1">&#39;F&#39;</span><span class="p">,</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">)};</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em_lines</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;BrG&#39;</span><span class="p">:(</span><span class="mf">2.1667</span><span class="p">,</span><span class="s1">&#39;LogL&#39;</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="s1">&#39;km/s&#39;</span><span class="p">)}</span>
</pre></div>
</div>
</dd>
</dl>
</p></li>
<li><p><strong>em_grid</strong> (<em>dictionary pointing to lists</em><em>, </em><em>opt</em>) – <p>Dictionary where each entry corresponds to an emission line and points
to a list of values to inject for emission line fluxes. For computation
efficiency, interpolation will be performed between the points of this
grid during the MCMC sampling. Dictionary entries should match those in
<code class="docutils literal notranslate"><span class="pre">labels</span></code> and <code class="docutils literal notranslate"><span class="pre">em_lines</span></code>.</p>
<dl>
<dt>Examples:</dt><dd><div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">BrGmin</span><span class="p">,</span> <span class="n">BrGmax</span> <span class="o">=</span> <span class="o">-</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em_grid</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;BrG&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">BrGmin</span><span class="p">,</span> <span class="n">BrGmax</span><span class="p">,</span> <span class="mi">20</span><span class="p">)}</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">BrGmin</span><span class="p">,</span> <span class="n">BrGmax</span> <span class="o">=</span> <span class="o">-</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">PaBmin</span><span class="p">,</span> <span class="n">PaBmax</span> <span class="o">=</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">7</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em_grid</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;PaB&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">PaBmin</span><span class="p">,</span> <span class="n">PaBmax</span><span class="p">,</span> <span class="mi">20</span><span class="p">),</span>
<span class="gp">&gt;&gt;&gt; </span>           <span class="s1">&#39;BrG&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">BrGmin</span><span class="p">,</span> <span class="n">BrGmax</span><span class="p">,</span> <span class="mi">20</span><span class="p">)}</span>
</pre></div>
</div>
</dd>
</dl>
</p></li>
<li><p><strong>lbda_mod</strong> (<em>numpy 1d ndarray</em><em> or </em><em>list</em>) – Wavelength of tested model. Should have a wider wavelength extent than
the observed spectrum.</p></li>
<li><p><strong>spec_mod</strong> (<em>numpy 1d ndarray</em>) – Model spectrum. It does not require the same wavelength sampling as
the observed spectrum. If higher spectral resolution, it will be
convolved with the instrumental spectral PSF (if <code class="docutils literal notranslate"><span class="pre">instru_res</span></code> is
provided) and then binned to the same sampling. If lower spectral
resolution, a linear interpolation is performed to infer the value at
the observed spectrum wavelength sampling.</p></li>
<li><p><strong>dlbda_obs</strong> (<em>numpy 1d ndarray</em><em> or </em><em>list</em><em>, </em><em>optional</em>) – Respective spectral channel width or FWHM of the photometric filters
used for each point of the observed spectrum. This vector is used to
infer which part(s) of a combined spectro+photometric spectrum should
involve convolution+subsampling (model resolution higher than
measurements), interpolation (the opposite), or convolution by the
transmission curve of a photometric filter. If not provided, it will be
inferred from the difference between consecutive lbda_obs points (i.e.
inaccurate for a combined spectrum). It must be provided IF one wants to
weigh each measurement based on the spectral resolution of each
instrument (as in <a class="reference internal" href="#olo16" id="id17"><span>[OLO16]</span></a>), through the <code class="docutils literal notranslate"><span class="pre">use_weights</span></code> argument.</p></li>
<li><p><strong>instru_res</strong> (<em>float</em><em> or </em><em>list of floats/strings</em><em>, </em><em>optional</em>) – The mean instrumental resolving power(s) OR filter names. This is
used to convolve the model spectrum. If several instruments are used,
provide a list of resolving power values / filter names, one for
each instrument used.</p></li>
<li><p><strong>instru_idx</strong> (<em>numpy 1d array</em><em>, </em><em>optional</em>) – 1d array containing an index representing each instrument used
to obtain the spectrum, label them from 0 to the number of instruments
(<span class="math notranslate nohighlight">\(n_{ins}\)</span>). Zero for points that don’t correspond to any of the
<code class="docutils literal notranslate"><span class="pre">instru_res</span></code> values provided, and i in <span class="math notranslate nohighlight">\([1,n_{ins}]\)</span> for points
associated to instru_res[i-1]. This parameter must be provided if the
spectrum consists of points obtained with different instruments.</p></li>
<li><p><strong>filter_reader</strong> (<em>python routine</em><em>, </em><em>optional</em>) – <p>External routine that reads a filter file and returns a 2D numpy array,
where the first column corresponds to wavelengths, and the second
contains transmission values. Important: if not provided, but strings
are detected in instru_res, the default file reader will be used.
It assumes the following format for the files:</p>
<ul>
<li><p>first row contains headers (titles of each column)</p></li>
<li><p>starting from 2nd row: 1st column: wavelength, 2nd col.: transmission</p></li>
<li><p>Unit of wavelength can be provided in parentheses of first header         key name: e.g. “WL(AA)” for angstrom, “wavelength(mu)” for micrometer         or “lambda(nm)” for nanometer. Note: only what is in parentheses         matters for the units.</p></li>
</ul>
</p></li>
<li><p><strong>interp_nonexist</strong> (<em>bool</em><em>, </em><em>opt</em>) – Whether to interpolate if models do not exist, based on closest model(s)</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>resamp_mod</strong> – Grid of model spectra resampled at wavelengths matching the observed
spectrum.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>1d numpy array</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><code class="docutils literal notranslate"><span class="pre">grid_param_list</span></code> and <code class="docutils literal notranslate"><span class="pre">model_grid</span></code> shouldn’t contain grids on radius
and Av. For a combined grid model + black body fit, just provide the list
of parameters probed by the grid to <code class="docutils literal notranslate"><span class="pre">grid_param_list</span></code>, and provide values
for ‘Tbbn’ and ‘Rbbn’ to <code class="docutils literal notranslate"><span class="pre">initial_state</span></code>, <code class="docutils literal notranslate"><span class="pre">labels</span></code> and <code class="docutils literal notranslate"><span class="pre">bounds</span></code>.</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="special.model_resampling.resample_model">
<span class="sig-prename descclassname"><span class="pre">special.model_resampling.</span></span><span class="sig-name descname"><span class="pre">resample_model</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">lbda_obs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lbda_mod</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">spec_mod</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dlbda_obs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">instru_res</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">instru_idx</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">filter_reader</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">no_constraint</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/special/model_resampling.html#resample_model"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#special.model_resampling.resample_model" title="Permalink to this definition"></a></dt>
<dd><p>Convolve, interpolate and resample a model spectrum to match observed
spectrum.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>lbda_obs</strong> (<em>numpy 1d ndarray</em><em> or </em><em>list</em>) – Wavelengths of observed spectrum. If several instruments were used, the
wavelengths should be ordered per instrument, not necessarily as
monotonically increasing wavelength. Hereafter, <span class="math notranslate nohighlight">\(n_{ch}\)</span> is the
length of <code class="docutils literal notranslate"><span class="pre">lbda_obs</span></code>.</p></li>
<li><p><strong>lbda_mod</strong> (<em>numpy 1d ndarray</em><em> or </em><em>list</em>) – Wavelength of tested model. Should have a wider wavelength extent than
the observed spectrum.</p></li>
<li><p><strong>spec_mod</strong> (<em>numpy 1d ndarray</em>) – Model spectrum. It does not require the same wavelength sampling as
the observed spectrum. If higher spectral resolution, it will be
convolved with the instrumental spectral PSF (if <code class="docutils literal notranslate"><span class="pre">instru_res</span></code> is
provided) and then binned to the same sampling. If lower spectral
resolution, a linear interpolation is performed to infer the value at
the observed spectrum wavelength sampling.</p></li>
<li><p><strong>dlbda_obs</strong> (<em>numpy 1d ndarray</em><em> or </em><em>list</em><em>, </em><em>optional</em>) – Respective spectral channel width or FWHM of the photometric filters
used for each point of the observed spectrum. This vector is used to
infer which part(s) of a combined spectro+photometric spectrum should
involve convolution+subsampling (model resolution higher than
measurements), interpolation (the opposite), or convolution by the
transmission curve of a photometric filter. If not provided, it will be
inferred from the difference between consecutive lbda_obs points (i.e.
inaccurate for a combined spectrum). It must be provided IF one wants to
weigh each measurement based on the spectral resolution of each
instrument (as in <a class="reference internal" href="#olo16" id="id18"><span>[OLO16]</span></a>), through the <code class="docutils literal notranslate"><span class="pre">use_weights</span></code> argument.</p></li>
<li><p><strong>instru_res</strong> (<em>float</em><em> or </em><em>list of floats/strings</em><em>, </em><em>optional</em>) – The mean instrumental resolving power(s) OR filter names. This is
used to convolve the model spectrum. If several instruments are used,
provide a list of resolving power values / filter names, one for
each instrument used.</p></li>
<li><p><strong>instru_idx</strong> (<em>numpy 1d array</em><em>, </em><em>optional</em>) – 1d array containing an index representing each instrument used
to obtain the spectrum, label them from 0 to the number of instruments
(<span class="math notranslate nohighlight">\(n_{ins}\)</span>). Zero for points that don’t correspond to any of the
<code class="docutils literal notranslate"><span class="pre">instru_res</span></code> values provided, and i in <span class="math notranslate nohighlight">\([1,n_{ins}]\)</span> for points
associated to instru_res[i-1]. This parameter must be provided if the
spectrum consists of points obtained with different instruments.</p></li>
<li><p><strong>filter_reader</strong> (<em>python routine</em><em>, </em><em>optional</em>) – <p>External routine that reads a filter file and returns a 2D numpy array,
where the first column corresponds to wavelengths, and the second
contains transmission values. Important: if not provided, but strings
are detected in instru_res, the default file reader will be used.
It assumes the following format for the files:</p>
<ul>
<li><p>first row contains headers (titles of each column)</p></li>
<li><p>starting from 2nd row: 1st column: wavelength, 2nd col.: transmission</p></li>
<li><p>Unit of wavelength can be provided in parentheses of first header         key name: e.g. “WL(AA)” for angstrom, “wavelength(mu)” for micrometer         or “lambda(nm)” for nanometer. Note: only what is in parentheses         matters for the units.</p></li>
</ul>
</p></li>
<li><p><strong>no_constraint</strong> (<em>bool</em><em>, </em><em>optional</em>) – If set to True, will not use ‘floor’ and ‘ceil’ constraints when
cropping the model wavelength ranges, i.e. faces the risk of
extrapolation. May be useful, if the bounds of the wavelength ranges
are known to match exactly.</p></li>
<li><p><strong>verbose</strong> (<em>bool</em><em>, </em><em>optional</em>) – Whether to print more information during resampling.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>lbda_obs, spec_mod_res</strong> – Observed lambdas, and resampled model spectrum (at those lambdas)</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>2x 1d numpy array</p>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-special.nested_sampling">
<span id="special-nested-sampling-module"></span><h2>special.nested_sampling module<a class="headerlink" href="#module-special.nested_sampling" title="Permalink to this headline"></a></h2>
<p>Module with functions for posterior sampling of the model spectra parameters
using nested sampling (either <code class="docutils literal notranslate"><span class="pre">nestle</span></code> or <code class="docutils literal notranslate"><span class="pre">ultranest</span></code> samplers).</p>
<dl class="citation">
<dt class="label" id="nes13"><span class="brackets"><a class="fn-backref" href="#id19">nes13</a></span></dt>
<dd><div class="line-block">
<div class="line">Barbary 2013</div>
<div class="line"><strong>nestle</strong></div>
<div class="line"><em>GitHub</em></div>
<div class="line"><a class="reference external" href="https://github.com/kbarbary/nestle">https://github.com/kbarbary/nestle</a></div>
</div>
</dd>
<dt class="label" id="ski04"><span class="brackets">SKI04</span><span class="fn-backref">(<a href="#id21">1</a>,<a href="#id26">2</a>)</span></dt>
<dd><div class="line-block">
<div class="line">Skilling 2004</div>
<div class="line"><strong>Bayesian Inference and Maximum Entropy Methods in Science and Engineering:
24th International Workshop on Bayesian Inference and Maximum Entropy
Methods in Science and Engineering</strong></div>
<div class="line"><em>American Institute of Physics Conference Series, Volume 735, pp. 395-405</em></div>
<div class="line"><a class="reference external" href="https://ui.adsabs.harvard.edu/abs/2004AIPC..735..395S">https://ui.adsabs.harvard.edu/abs/2004AIPC..735..395S</a></div>
</div>
</dd>
<dt class="label" id="muk06"><span class="brackets">MUK06</span><span class="fn-backref">(<a href="#id22">1</a>,<a href="#id27">2</a>)</span></dt>
<dd><div class="line-block">
<div class="line">Mukherjee et al. 2006</div>
<div class="line"><strong>A Nested Sampling Algorithm for Cosmological Model Selection</strong></div>
<div class="line"><em>ApJL, Volume 638, Issue 2, pp. 51-54</em></div>
<div class="line"><a class="reference external" href="https://arxiv.org/abs/astro-ph/0508461">https://arxiv.org/abs/astro-ph/0508461</a></div>
</div>
</dd>
<dt class="label" id="fer09"><span class="brackets">FER09</span><span class="fn-backref">(<a href="#id23">1</a>,<a href="#id28">2</a>)</span></dt>
<dd><div class="line-block">
<div class="line">Feroz et al. 2009</div>
<div class="line"><strong>MULTINEST: an efficient and robust Bayesian inference tool for cosmology
and particle physics</strong></div>
<div class="line"><em>MNRAS, Volume 398, Issue 4, pp. 1601-1614</em></div>
<div class="line"><a class="reference external" href="https://arxiv.org/abs/0809.3437">https://arxiv.org/abs/0809.3437</a></div>
</div>
</dd>
<dt class="label" id="buc21"><span class="brackets"><a class="fn-backref" href="#id20">BUC21</a></span></dt>
<dd><div class="line-block">
<div class="line">Buchner 2021</div>
<div class="line"><strong>UltraNest - a robust, general purpose Bayesian inference engine</strong></div>
<div class="line"><em>JOSS, Volume 6, Issue 60, p. 3001</em></div>
<div class="line"><a class="reference external" href="https://arxiv.org/abs/2101.09604">https://arxiv.org/abs/2101.09604</a></div>
</div>
</dd>
</dl>
<dl class="py function">
<dt class="sig sig-object py" id="special.nested_sampling.nested_spec_sampling">
<span class="sig-prename descclassname"><span class="pre">special.nested_sampling.</span></span><span class="sig-name descname"><span class="pre">nested_spec_sampling</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">init</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lbda_obs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">spec_obs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">err_obs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dist</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">grid_param_list</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">labels</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bounds</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">resamp_before</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">model_grid</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">model_reader</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">em_lines</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">{}</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">em_grid</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">{}</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dlbda_obs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">instru_corr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">instru_res</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">instru_idx</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_weights</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">filter_reader</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">AV_bef_bb</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">units_obs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'si'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">units_mod</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'si'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">interp_order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">priors</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">physical</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">interp_nonexist</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">output_dir</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'special/'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">grid_name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'resamp_grid.fits'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sampler</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'ultranest'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'single'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">npoints</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dlogz</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/special/nested_sampling.html#nested_spec_sampling"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#special.nested_sampling.nested_spec_sampling" title="Permalink to this definition"></a></dt>
<dd><p>Runs a nested sampling algorithm in order to retrieve the best-fit
parameters for given spectral model and observed spectrum.. The
result of this procedure is either a <code class="docutils literal notranslate"><span class="pre">nestle</span></code> <a class="reference internal" href="#nes13" id="id19"><span>[nes13]</span></a> or <code class="docutils literal notranslate"><span class="pre">ultranest</span></code>
<a class="reference internal" href="#buc21" id="id20"><span>[BUC21]</span></a> object (depending on the chosen sampler) containing the samples
from the posterior distributions of each of the parameters.
For the <code class="docutils literal notranslate"><span class="pre">nestle</span></code> sampler, several methods are available corresponding to
MCMC <a class="reference internal" href="#ski04" id="id21"><span>[SKI04]</span></a>, single ellipsoid <a class="reference internal" href="#muk06" id="id22"><span>[MUK06]</span></a> or multiple ellipsoid <a class="reference internal" href="#fer09" id="id23"><span>[FER09]</span></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>init</strong> (<em>numpy ndarray</em><em> or </em><em>tuple</em>) – Initial guess on the best fit parameters of the spectral fit. Length of
the tuple should match the total number of free parameters.
- first all parameters related to loaded models (e.g. ‘Teff’, ‘logg’)
- then the planet photometric radius ‘R’, in Jupiter radius
- (optionally) the intensity of emission lines (labels must match         those in the em_lines dict), in units of the model spectrum (x mu)
- (optionally) the optical extinction ‘Av’, in mag
- (optionally) the ratio of total to selective optical extinction ‘Rv’
- (optionally) ‘Tbb1’, ‘Rbb1’, ‘Tbb2’, ‘Rbb2’, etc. for each extra bb         contribution</p></li>
<li><p><strong>lbda_obs</strong> (<em>numpy 1d ndarray</em><em> or </em><em>list</em>) – Wavelengths of observed spectrum. If several instruments were used, the
wavelengths should be ordered per instrument, not necessarily as
monotonically increasing wavelength. Hereafter, <span class="math notranslate nohighlight">\(n_{ch}\)</span> is the
length of <code class="docutils literal notranslate"><span class="pre">lbda_obs</span></code>.</p></li>
<li><p><strong>spec_obs</strong> (<em>numpy 1d ndarray</em><em> or </em><em>list</em>) – Observed spectrum for each value of <code class="docutils literal notranslate"><span class="pre">lbda_obs</span></code>. Should have a length
of <span class="math notranslate nohighlight">\(n_{ch}\)</span>.</p></li>
<li><p><strong>err_obs</strong> (<em>numpy 1d/2d ndarray</em><em> or </em><em>list</em>) – Uncertainties on the observed spectrum. The array (list) can have either
a length of <span class="math notranslate nohighlight">\(n_{ch}\)</span>, or a shape of <span class="math notranslate nohighlight">\((2,n_{ch})\)</span> for lower
(first column) and upper (second column) uncertainties provided.</p></li>
<li><p><strong>dist</strong> (<em>float</em>) – Distance in parsec, used for flux scaling of the models.</p></li>
<li><p><strong>grid_param_list</strong> (<em>list of 1d numpy arrays/lists</em>) – Should contain list/numpy 1d arrays with available grid of model
parameters (should only contain the sampled parameters, not the models
themselves). The models will be loaded with <code class="docutils literal notranslate"><span class="pre">model_reader</span></code>.</p></li>
<li><p><strong>labels</strong> (<em>Tuple of strings</em>) – <dl class="simple">
<dt>Tuple of labels in the same order as initial_state:</dt><dd><ul>
<li><p>first all parameters related to loaded models (e.g. ‘Teff’, ‘logg’)</p></li>
<li><p>then the planet photometric radius ‘R’, in Jupiter radius</p></li>
<li><p>(optionally) the flux of emission lines (labels should match those             in the em_lines dictionary), in units of the model spectrum (times mu)</p></li>
<li><p>(optionally) the optical extinction ‘Av’, in mag</p></li>
<li><p>(optionally) the ratio of total to selective optical extinction ‘Rv’</p></li>
<li><p>(optionally) ‘Tbb1’, ‘Rbb1’, ‘Tbb2’, ‘Rbb2’, etc. for each extra bb             contribution.</p></li>
</ul>
</dd>
</dl>
</p></li>
<li><p><strong>bounds</strong> (<em>dictionary</em>) – <p>Each entry should be associated with a tuple corresponding to lower and
upper bounds respectively. Bounds should be provided for ALL model
parameters, including ‘R’ (planet photometric radius). ‘Av’ (optical
extinction) is optional. If provided here, Av will also be fitted.
All keywords that are neither ‘R’, ‘Av’ nor ‘M’ will
be considered model grid parameters.</p>
<dl>
<dt>Examples:</dt><dd><div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">bounds</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;Teff&#39;</span><span class="p">:(</span><span class="mi">1000</span><span class="p">,</span><span class="mi">2000</span><span class="p">),</span> <span class="s1">&#39;logg&#39;</span><span class="p">:(</span><span class="mf">3.0</span><span class="p">,</span><span class="mf">4.5</span><span class="p">),</span> <span class="s1">&#39;R&#39;</span><span class="p">:(</span><span class="mf">0.1</span><span class="p">,</span><span class="mi">5</span><span class="p">)}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bounds</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;Teff&#39;</span><span class="p">:(</span><span class="mi">1000</span><span class="p">,</span><span class="mi">2000</span><span class="p">),</span> <span class="s1">&#39;logg&#39;</span><span class="p">:(</span><span class="mf">3.0</span><span class="p">,</span><span class="mf">4.5</span><span class="p">),</span> <span class="s1">&#39;R&#39;</span><span class="p">:(</span><span class="mf">0.1</span><span class="p">,</span><span class="mi">5</span><span class="p">),</span>
<span class="gp">&gt;&gt;&gt; </span>          <span class="s1">&#39;Av&#39;</span><span class="p">:(</span><span class="mf">0.</span><span class="p">,</span><span class="mf">2.5</span><span class="p">),</span> <span class="s1">&#39;Rv&#39;</span><span class="p">:(</span><span class="mi">1</span><span class="p">,</span><span class="mi">5</span><span class="p">)}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bounds</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;Teff&#39;</span><span class="p">:(</span><span class="mi">1000</span><span class="p">,</span><span class="mi">2000</span><span class="p">),</span> <span class="s1">&#39;logg&#39;</span><span class="p">:(</span><span class="mf">3.0</span><span class="p">,</span><span class="mf">4.5</span><span class="p">),</span> <span class="s1">&#39;R&#39;</span><span class="p">:(</span><span class="mf">0.1</span><span class="p">,</span><span class="mi">5</span><span class="p">),</span>
<span class="gp">&gt;&gt;&gt; </span>          <span class="s1">&#39;Av&#39;</span><span class="p">:(</span><span class="mf">0.</span><span class="p">,</span><span class="mf">2.5</span><span class="p">),</span> <span class="s1">&#39;BrG&#39;</span><span class="p">:(</span><span class="mf">1e-17</span><span class="p">,</span><span class="mf">1e-15</span><span class="p">)}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bounds</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;Teff&#39;</span><span class="p">:(</span><span class="mi">2000</span><span class="p">,</span><span class="mi">3000</span><span class="p">),</span> <span class="s1">&#39;logg&#39;</span><span class="p">:(</span><span class="mf">3.0</span><span class="p">,</span><span class="mf">4.5</span><span class="p">),</span> <span class="s1">&#39;R&#39;</span><span class="p">:(</span><span class="mf">1.</span><span class="p">,</span><span class="mf">5.</span><span class="p">),</span>
<span class="gp">&gt;&gt;&gt; </span>          <span class="s1">&#39;Tbb1&#39;</span><span class="p">:(</span><span class="mi">500</span><span class="p">,</span><span class="mi">1500</span><span class="p">),</span> <span class="s1">&#39;Rbb1&#39;</span><span class="p">:(</span><span class="mf">0.1</span><span class="p">,</span><span class="mf">1.</span><span class="p">)}</span>
</pre></div>
</div>
</dd>
</dl>
</p></li>
<li><p><strong>resamp_before</strong> (<em>bool</em><em>, </em><em>optional</em>) – Whether to prepare the whole grid of resampled models before entering
the MCMC, i.e. to avoid doing it at every MCMC step. Recommended.
Only reason not to: model grid is too large and individual models
require being opened and resampled at each step.</p></li>
<li><p><strong>model_grid</strong> (<em>numpy N-d array</em><em>, </em><em>optional</em>) – If provided, should contain the grid of model spectra for each
free parameter of the given grid. I.e. for a grid of <span class="math notranslate nohighlight">\(n_T\)</span> values
of <span class="math notranslate nohighlight">\(T_{eff}\)</span> and <span class="math notranslate nohighlight">\(n_g\)</span> values of log(<span class="math notranslate nohighlight">\(g\)</span>), the numpy
array should have a shape of <span class="math notranslate nohighlight">\((n_T, n_g, n_{ch}, 2)\)</span>, where the
last 2 dimensions correspond to wavelength and fluxes respectively. If
provided, <code class="docutils literal notranslate"><span class="pre">model_grid</span></code> takes precedence over <code class="docutils literal notranslate"><span class="pre">model_name</span></code>/
<code class="docutils literal notranslate"><span class="pre">model_reader</span></code>.</p></li>
<li><p><strong>model_reader</strong> (<em>python routine</em><em>, </em><em>opt</em>) – External routine that reads a model file and returns a 2D numpy array,
where the first column corresponds to wavelengths, and the second
contains model values. See example routine in
<code class="docutils literal notranslate"><span class="pre">special.model_resampling.interpolate_model</span></code> description.</p></li>
<li><p><strong>em_lines</strong> (<em>dictionary</em><em>, </em><em>opt</em>) – <p>Dictionary of emission lines to be added on top of the model spectrum.
Each dict entry should be the name of the line, assigned to a tuple of
4 values:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>the wavelength (in <span class="math notranslate nohighlight">\(\mu\)</span> m);</p></li>
<li><p>a string indicating whether line intensity is expressed in flux             (‘F’), luminosity (‘L’) or log(L/LSun) (“LogL”);</p></li>
<li><p>the FWHM of the gaussian (or None if to be set automatically);</p></li>
<li><p>whether the FWHM is expressed in ‘nm’, ‘mu’ or ‘km/s’.</p></li>
</ol>
</div></blockquote>
<p>The third and fourth can also be set to None. In that case, the FWHM of
the gaussian will automatically be set to the equivalent width of the
line, calculated from the flux to be injected and the continuum
level (measured in the grid model to which the line is injected).</p>
<dl>
<dt>Examples:</dt><dd><div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">em_lines</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;BrG&#39;</span><span class="p">:(</span><span class="mf">2.1667</span><span class="p">,</span><span class="s1">&#39;F&#39;</span><span class="p">,</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">)};</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em_lines</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;BrG&#39;</span><span class="p">:(</span><span class="mf">2.1667</span><span class="p">,</span><span class="s1">&#39;LogL&#39;</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="s1">&#39;km/s&#39;</span><span class="p">)}</span>
</pre></div>
</div>
</dd>
</dl>
</p></li>
<li><p><strong>em_grid</strong> (<em>dictionary pointing to lists</em><em>, </em><em>opt</em>) – <p>Dictionary where each entry corresponds to an emission line and points
to a list of values to inject for emission line fluxes. For computation
efficiency, interpolation will be performed between the points of this
grid during the MCMC sampling. Dictionary entries should match those in
<code class="docutils literal notranslate"><span class="pre">labels</span></code> and <code class="docutils literal notranslate"><span class="pre">em_lines</span></code>.</p>
<dl>
<dt>Examples:</dt><dd><div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">BrGmin</span><span class="p">,</span> <span class="n">BrGmax</span> <span class="o">=</span> <span class="o">-</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em_grid</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;BrG&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">BrGmin</span><span class="p">,</span> <span class="n">BrGmax</span><span class="p">,</span> <span class="mi">20</span><span class="p">)}</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">BrGmin</span><span class="p">,</span> <span class="n">BrGmax</span> <span class="o">=</span> <span class="o">-</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">PaBmin</span><span class="p">,</span> <span class="n">PaBmax</span> <span class="o">=</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">7</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em_grid</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;PaB&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">PaBmin</span><span class="p">,</span> <span class="n">PaBmax</span><span class="p">,</span> <span class="mi">20</span><span class="p">),</span>
<span class="gp">&gt;&gt;&gt; </span>           <span class="s1">&#39;BrG&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">BrGmin</span><span class="p">,</span> <span class="n">BrGmax</span><span class="p">,</span> <span class="mi">20</span><span class="p">)}</span>
</pre></div>
</div>
</dd>
</dl>
</p></li>
<li><p><strong>dlbda_obs</strong> (<em>numpy 1d ndarray</em><em> or </em><em>list</em><em>, </em><em>optional</em>) – Respective spectral channel width or FWHM of the photometric filters
used for each point of the observed spectrum. This vector is used to
infer which part(s) of a combined spectro+photometric spectrum should
involve convolution+subsampling (model resolution higher than
measurements), interpolation (the opposite), or convolution by the
transmission curve of a photometric filter. If not provided, it will be
inferred from the difference between consecutive lbda_obs points (i.e.
inaccurate for a combined spectrum). It must be provided IF one wants to
weigh each measurement based on the spectral resolution of each
instrument (as in <a class="reference internal" href="#olo16" id="id24"><span>[OLO16]</span></a>), through the <code class="docutils literal notranslate"><span class="pre">use_weights</span></code> argument.</p></li>
<li><p><strong>instru_corr</strong> (<em>numpy 2d ndarray</em><em>, </em><em>optional</em>) – Spectral correlation between post-processed images in which the
spectrum is measured. It is specific to the instrument, PSF subtraction
algorithm and radial separation of the companion from the central star.
Can be computed using <code class="docutils literal notranslate"><span class="pre">special.spec_corr.spectral_correlation</span></code>. In
case of a spectrum obtained with different instruments, it is
recommended to construct the final spectral_correlation matrix with
<code class="docutils literal notranslate"><span class="pre">special.spec_corr.combine_corrs</span></code>. If <code class="docutils literal notranslate"><span class="pre">instru_corr</span></code> is not provided,
the uncertainties in each spectral channel will be considered
independent. See <a class="reference internal" href="#gre16" id="id25"><span>[GRE16]</span></a> for more details.</p></li>
<li><p><strong>instru_res</strong> (<em>float</em><em> or </em><em>list of floats/strings</em><em>, </em><em>optional</em>) – The mean instrumental resolving power(s) OR filter names. This is
used to convolve the model spectrum. If several instruments are used,
provide a list of resolving power values / filter names, one for
each instrument used.</p></li>
<li><p><strong>instru_idx</strong> (<em>numpy 1d array</em><em>, </em><em>optional</em>) – 1d array containing an index representing each instrument used
to obtain the spectrum, label them from 0 to the number of instruments
(<span class="math notranslate nohighlight">\(n_{ins}\)</span>). Zero for points that don’t correspond to any of the
<code class="docutils literal notranslate"><span class="pre">instru_res</span></code> values provided, and i in <span class="math notranslate nohighlight">\([1,n_{ins}]\)</span> for points
associated to instru_res[i-1]. This parameter must be provided if the
spectrum consists of points obtained with different instruments.</p></li>
<li><p><strong>use_weights</strong> (<em>bool</em><em>, </em><em>optional</em>) – For the likelihood calculation, whether to weigh each point of the
spectrum based on the spectral resolution or bandwidth of photometric
filters used. Weights will be proportional to <code class="docutils literal notranslate"><span class="pre">dlbda_obs/lbda_obs</span></code> if
<code class="docutils literal notranslate"><span class="pre">dlbda_obs</span></code> is provided, or set to 1 for all points otherwise.</p></li>
<li><p><strong>filter_reader</strong> (<em>python routine</em><em>, </em><em>optional</em>) – <p>External routine that reads a filter file and returns a 2D numpy array,
where the first column corresponds to wavelengths, and the second
contains transmission values. Important: if not provided, but strings
are detected in instru_res, the default file reader will be used.
It assumes the following format for the files:</p>
<ul>
<li><p>first row contains headers (titles of each column)</p></li>
<li><p>starting from 2nd row: 1st column: wavelength, 2nd col.: transmission</p></li>
<li><p>Unit of wavelength can be provided in parentheses of first header         key name: e.g. “WL(AA)” for angstrom, “wavelength(mu)” for micrometer         or “lambda(nm)” for nanometer. Note: only what is in parentheses         matters for the units.</p></li>
</ul>
</p></li>
<li><p><strong>AV_bef_bb</strong> (<em>bool</em><em>, </em><em>optional</em>) – If both extinction and an extra bb component are free parameters,
whether to apply extinction before adding the BB component (e.g.
extinction mostly from circumplanetary dust) or after the BB component
(e.g. mostly insterstellar extinction).</p></li>
<li><p><strong>units_obs</strong> (<em>str</em><em>, </em><em>opt {'si'</em><em>,</em><em>'cgs'</em><em>,</em><em>'jy'}</em>) – Units of observed spectrum. ‘si’ for W/m^2/mu; ‘cgs’ for ergs/s/cm^2/mu
or ‘jy’ for janskys.</p></li>
<li><p><strong>units_mod</strong> (<em>str</em><em>, </em><em>opt {'si'</em><em>,</em><em>'cgs'</em><em>,</em><em>'jy'}</em>) – Units of the model. ‘si’ for W/m^2/mu; ‘cgs’ for ergs/s/cm^2/mu or ‘jy’
for janskys. If different to units_obs, the spectrum units will be
converted.</p></li>
<li><p><strong>interp_order</strong> (<em>int</em><em>, </em><em>opt</em><em>, </em><em>{-1</em><em>,</em><em>0</em><em>,</em><em>1}</em>) – <dl class="simple">
<dt>Interpolation mode for model interpolation.</dt><dd><ul>
<li><p>-1: log interpolation (i.e. linear interpolatlion on log(Flux))</p></li>
<li><p>0: nearest neighbour model</p></li>
<li><p>1: Order 1 spline interpolation</p></li>
</ul>
</dd>
</dl>
</p></li>
<li><p><strong>priors</strong> (<em>dictionary</em><em>, </em><em>opt</em>) – <p>If not None, sets prior estimates for each parameter of the model. Each
entry should be set to either None (no prior) or a tuple of 2 elements
containing prior estimate and uncertainty on the estimate.
Missing entries (i.e. provided in <code class="docutils literal notranslate"><span class="pre">bounds</span></code> dictionary but not here)
will be associated no prior.
‘M’ can be used for a prior on the mass of the planet. In that case the
corresponding prior log probability is computed from the values for
parameters ‘logg’ and ‘R’.</p>
<dl>
<dt>Examples:</dt><dd><div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">priors</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;logg&#39;</span><span class="p">:(</span><span class="mf">3.5</span><span class="p">,</span><span class="mf">0.2</span><span class="p">),</span> <span class="s1">&#39;Rv&#39;</span><span class="p">:(</span><span class="mf">3.1</span><span class="p">,</span><span class="mf">0.2</span><span class="p">)}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">priors</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;Teff&#39;</span><span class="p">:(</span><span class="mi">1600</span><span class="p">,</span><span class="mi">100</span><span class="p">),</span> <span class="s1">&#39;logg&#39;</span><span class="p">:(</span><span class="mf">3.5</span><span class="p">,</span><span class="mf">0.5</span><span class="p">),</span> <span class="s1">&#39;R&#39;</span><span class="p">:(</span><span class="mf">1.6</span><span class="p">,</span><span class="mf">0.1</span><span class="p">),</span>
<span class="gp">&gt;&gt;&gt; </span>          <span class="s1">&#39;Av&#39;</span><span class="p">:(</span><span class="mf">1.8</span><span class="p">,</span><span class="mf">0.2</span><span class="p">),</span> <span class="s1">&#39;M&#39;</span><span class="p">:(</span><span class="mi">10</span><span class="p">,</span><span class="mi">3</span><span class="p">)}</span>
</pre></div>
</div>
</dd>
</dl>
<p>Important: dictionary entry names should match exactly those of
<code class="docutils literal notranslate"><span class="pre">bounds</span></code>.</p>
</p></li>
<li><p><strong>physical</strong> (<em>bool</em><em>, </em><em>opt</em>) – In case of extra black body component(s) to a photosphere, whether to
force lower temperature than the photosphere effective temperature.</p></li>
<li><p><strong>interp_nonexist</strong> (<em>bool</em><em>, </em><em>opt</em>) – Whether to interpolate non-existing models in the grid. Only used if
resamp_before is set to True.</p></li>
<li><p><strong>w</strong> (<em>float</em><em> or </em><em>tuple</em>) – The relative size of the bounds (around the initial state <code class="docutils literal notranslate"><span class="pre">init</span></code>) for
each parameter. If a float the same relative size is considered for
each parameter. E.g. if 0.1, bounds will be set to:
(0.9*params[0], 1.1*params[0]),
…
(0.9*params[N-1], 1.1*params[N-1]),
to True), or make it and write it if it does not.</p></li>
<li><p><strong>output_dir</strong> (<em>str</em><em>, </em><em>optional</em>) – The name of the output directory which contains the output files in the
case  <code class="docutils literal notranslate"><span class="pre">save</span></code> is True.</p></li>
<li><p><strong>grid_name</strong> (<em>str</em><em>, </em><em>optional</em>) – Name of the fits file containing the model grid (numpy array) AFTER
convolution+resampling as the observed spectrum given as input.
If provided, will read it if it exists (and resamp_before is set</p></li>
<li><p><strong>method</strong> (<em>{&quot;single&quot;</em><em>, </em><em>&quot;multi&quot;</em><em>, </em><em>&quot;classic&quot;}</em><em>, </em><em>str optional</em>) – Flavor of nested sampling.</p></li>
<li><p><strong>npoints</strong> (<em>int optional</em>) – Number of active points. Must be &gt;&gt; ndim+1, otherwise will produce bad
results. For UltraNest, this is the minimum number of active points.</p></li>
<li><p><strong>dlogz</strong> (<em>float</em><em>, </em><em>optional</em>) – Target evidence uncertainty. Iterations will stop when the estimated
contribution of the remaining prior volume to the total evidence falls
below this threshold. Explicitly, the stopping criterion is
log(z + z_est) - log(z) &lt; dlogz
where z is the current evidence from all saved samples, and z_est is the
estimated contribution from the remaining volume. This option and
decline_factor are mutually exclusive. If neither is specified, the
default is dlogz=0.2.</p></li>
<li><p><strong>decline_factor</strong> (<em>float</em><em>, </em><em>optional</em>) – If supplied, iteration will stop when the weight (likelihood times prior
volume) of newly saved samples has been declining for
decline_factor * nsamples consecutive samples. A value of 1.0 seems to
work pretty well.</p></li>
<li><p><strong>rstate</strong> (<em>random instance</em><em>, </em><em>optional</em>) – RandomState instance. If not given, the global random state of the
numpy.random module will be used.</p></li>
<li><p><strong>kwargs</strong> (<em>optional</em>) – Additional optional arguments to either the <cite>nestle.sample</cite> or
<cite>ultranest.ReactiveNestedSampler.run</cite> functions.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>res</strong> – <code class="docutils literal notranslate"><span class="pre">Nestle</span></code> object with the nested sampling results, including the
posterior samples.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>nestle object</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Nested Sampling is a computational approach for integrating posterior
probability in order to compare models in Bayesian statistics. It is similar
to Markov Chain Monte Carlo (MCMC) in that it generates samples that can be
used to estimate the posterior probability distribution. Unlike MCMC, the
nature of the sampling also allows one to calculate the integral of the
distribution. It also happens to be a pretty good method for robustly
finding global maxima.</p>
<dl class="simple">
<dt>Nestle documentation:</dt><dd><p><a class="reference external" href="http://kbarbary.github.io/nestle/">http://kbarbary.github.io/nestle/</a></p>
</dd>
<dt>Convergence:</dt><dd><p><a class="reference external" href="http://kbarbary.github.io/nestle/stopping.html">http://kbarbary.github.io/nestle/stopping.html</a>
Nested sampling has no well-defined stopping point. As iterations continue,
the active points sample a smaller and smaller region of prior space.
This can continue indefinitely. Unlike typical MCMC methods, we don’t gain
any additional precision on the results by letting the algorithm run longer;
the precision is determined at the outset by the number of active points.
So, we want to stop iterations as soon as we think the active points are
doing a pretty good job sampling the remaining prior volume - once we’ve
converged to the highest-likelihood regions such that the likelihood is
relatively flat within the remaining prior volume.</p>
</dd>
<dt>Method:</dt><dd><p>The trick in nested sampling is to, at each step in the algorithm,
efficiently choose a new point in parameter space drawn with uniform
probability from the parameter space with likelihood greater than the
current likelihood constraint. The different methods all use the
current set of active points as an indicator of where the target
parameter space lies, but differ in how they select new points from it:</p>
<ul class="simple">
<li><p>“classic” is close to the method described in <a class="reference internal" href="#ski04" id="id26"><span>[SKI04]</span></a>.</p></li>
<li><p>“single” <a class="reference internal" href="#muk06" id="id27"><span>[MUK06]</span></a> determines a single ellipsoid that bounds all active         points, enlarges the ellipsoid by a user-settable factor, and         selects a new point at random from within the ellipsoid.</p></li>
<li><p>“multiple” <a class="reference internal" href="#fer09" id="id28"><span>[FER09]</span></a> (Multinest). In cases where the posterior is         multi-modal, the single-ellipsoid method can be extremely inefficient.         In such situations, there are clusters of active points on separate         high-likelihood regions separated by regions of lower likelihood. Bounding         all points in a single ellipsoid means that the ellipsoid includes the         lower-likelihood regions we wish to avoid sampling from.        The solution is to detect these clusters and bound them in separate        ellipsoids. For this, we use a recursive process where we perform        K-means clustering with K=2. If the resulting two ellipsoids have a        significantly lower total volume than the parent ellipsoid (less than half),        we accept the split and repeat the clustering and volume test on each of        the two subset of points. This process continues recursively.        Alternatively, if the total ellipse volume is significantly greater        than expected (based on the expected density of points) this indicates        that there may be more than two clusters and that K=2 was not an        appropriate cluster division.        We therefore still try to subdivide the clusters recursively. However,        we still only accept the final split into N clusters if the total volume        decrease is significant.</p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<ul class="simple">
<li><p>If several filter filenames are provided in <code class="docutils literal notranslate"><span class="pre">instru_res</span></code>, the filter files
must all have the same format and wavelength units (for reading by the same
<code class="docutils literal notranslate"><span class="pre">filter_reader</span></code> snippet or default function).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">grid_param_list</span></code> and <code class="docutils literal notranslate"><span class="pre">model_grid</span></code> shouldn’t contain grids on radius
and Av. For a combined grid model + black body fit, just provide the list
of parameters probed by the grid to <code class="docutils literal notranslate"><span class="pre">grid_param_list</span></code>, and provide values
for ‘Tbbn’ and ‘Rbbn’ to <code class="docutils literal notranslate"><span class="pre">initial_state</span></code>, <code class="docutils literal notranslate"><span class="pre">labels</span></code> and <code class="docutils literal notranslate"><span class="pre">bounds</span></code>.</p></li>
</ul>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="special.nested_sampling.show_nestle_results">
<span class="sig-prename descclassname"><span class="pre">special.nested_sampling.</span></span><span class="sig-name descname"><span class="pre">show_nestle_results</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ns_object</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">labels</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">burnin</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.4</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bins</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cfd</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">68.27</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">units</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ndig</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">labels_plot</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">save</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">output_dir</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'/'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">plot</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/special/nested_sampling.html#show_nestle_results"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#special.nested_sampling.show_nestle_results" title="Permalink to this definition"></a></dt>
<dd><p>Show the results obtained with the Nestle sampler: summary, parameters with
errors, walk and corner plots. Returns best-fit values and uncertatinties.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ns_object</strong> (<em>numpy.array</em>) – The nestle object returned from <cite>nested_spec_sampling</cite>.</p></li>
<li><p><strong>labels</strong> (<em>Tuple of strings</em>) – <dl class="simple">
<dt>Tuple of labels in the same order as initial_state:</dt><dd><ul>
<li><p>first all parameters related to loaded models (e.g. ‘Teff’, ‘logg’)</p></li>
<li><p>then the planet photometric radius ‘R’, in Jupiter radius</p></li>
<li><p>(optionally) the flux of emission lines (labels should match those             in the em_lines dictionary), in units of the model spectrum (times mu)</p></li>
<li><p>(optionally) the optical extinction ‘Av’, in mag</p></li>
<li><p>(optionally) the ratio of total to selective optical extinction ‘Rv’</p></li>
<li><p>(optionally) ‘Tbb1’, ‘Rbb1’, ‘Tbb2’, ‘Rbb2’, etc. for each extra bb             contribution.</p></li>
</ul>
</dd>
</dl>
</p></li>
<li><p><strong>method</strong> (<em>{&quot;single&quot;</em><em>, </em><em>&quot;multi&quot;</em><em>, </em><em>&quot;classic&quot;}</em><em>, </em><em>str optional</em>) – Flavor of nested sampling.</p></li>
<li><p><strong>burnin</strong> (<em>float</em><em>, </em><em>default: 0</em>) – The fraction of a walker we want to discard.</p></li>
<li><p><strong>bins</strong> (<em>int</em><em>, </em><em>optional</em>) – The number of bins used to sample the posterior distributions.</p></li>
<li><p><strong>cfd</strong> (<em>float</em><em>, </em><em>optional</em>) – The confidence level given in percentage.</p></li>
<li><p><strong>units</strong> (<em>tuple</em><em>, </em><em>opt</em>) – Tuple of strings containing units for each parameter. If provided,
mcmc_res will be printed on top of each 1d posterior distribution along
with these units.</p></li>
<li><p><strong>ndig</strong> (<em>tuple</em><em>, </em><em>opt</em>) – Number of digits precision for each printed parameter.</p></li>
<li><p><strong>labels_plot</strong> (<em>tuple</em><em>, </em><em>opt</em>) – Labels corresponding to parameter names, used for the plot. If None,
will use “labels” passed in kwargs.</p></li>
<li><p><strong>save</strong> (<em>boolean</em><em>, </em><em>default: False</em>) – If True, a pdf file is created.</p></li>
<li><p><strong>output_dir</strong> (<em>str</em><em>, </em><em>optional</em>) – The name of the output directory which contains the output files in the
case  <code class="docutils literal notranslate"><span class="pre">save</span></code> is True.</p></li>
<li><p><strong>plot</strong> (<em>bool</em><em>, </em><em>optional</em>) – Whether to show the plots (instead of saving them).</p></li>
<li><p><strong>kwargs</strong> – Additional optional arguments passed to <cite>confidence</cite> (matplotlib
optional arguments for histograms).</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>final_res</strong> – Best-fit parameters and uncertainties (corresponding to 68% confidence
interval). Dimensions: nparams x 2.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>numpy ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="special.nested_sampling.show_ultranest_results">
<span class="sig-prename descclassname"><span class="pre">special.nested_sampling.</span></span><span class="sig-name descname"><span class="pre">show_ultranest_results</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">un_object</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">labels</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">grid_param_list</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dist</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bins</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cfd</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">68.27</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ndig</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">save</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">output_dir</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'/'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">plot</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">col</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'b'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">units</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">labels_plot</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lbda_obs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">spec_obs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">spec_obs_err</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_pts</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">title</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">figsize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">(8,</span> <span class="pre">6)</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/special/nested_sampling.html#show_ultranest_results"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#special.nested_sampling.show_ultranest_results" title="Permalink to this definition"></a></dt>
<dd><p>Shows the results obtained with the Ultranest sampler: summary, parameters
with errors, walk and corner plots. Returns best-fit values and
uncertatinties.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>un_object</strong> (<em>object</em>) – The UltraNest Sampler object returned by nested_spec_sampling.</p></li>
<li><p><strong>labels</strong> (<em>Tuple of strings</em>) – <dl class="simple">
<dt>Tuple of labels in the same order as initial_state:</dt><dd><ul>
<li><p>first all parameters related to loaded models (e.g. ‘Teff’, ‘logg’)</p></li>
<li><p>then the planet photometric radius ‘R’, in Jupiter radius</p></li>
<li><p>(optionally) the flux of emission lines (labels should match those             in the em_lines dictionary), in units of the model spectrum (times mu)</p></li>
<li><p>(optionally) the optical extinction ‘Av’, in mag</p></li>
<li><p>(optionally) the ratio of total to selective optical extinction ‘Rv’</p></li>
<li><p>(optionally) ‘Tbb1’, ‘Rbb1’, ‘Tbb2’, ‘Rbb2’, etc. for each extra bb             contribution.</p></li>
</ul>
</dd>
</dl>
</p></li>
<li><p><strong>grid_param_list</strong> (<em>list of 1d numpy arrays/lists</em>) – Should contain list/numpy 1d arrays with available grid of model
parameters (should only contain the sampled parameters, not the models
themselves). The models will be loaded with <code class="docutils literal notranslate"><span class="pre">model_reader</span></code>.</p></li>
<li><p><strong>dist</strong> (<em>float</em>) – Distance in parsec, used for flux scaling of the models.</p></li>
<li><p><strong>bins</strong> (<em>int</em><em>, </em><em>optional</em>) – The number of bins used to sample the posterior distributions.</p></li>
<li><p><strong>cfd</strong> (<em>float</em><em>, </em><em>optional</em>) – The confidence level given in percentage.</p></li>
<li><p><strong>ndig</strong> (<em>tuple</em><em>, </em><em>opt</em>) – Number of digits precision for each printed parameter.</p></li>
<li><p><strong>save</strong> (<em>boolean</em><em>, </em><em>default: False</em>) – If True, a pdf file is created.</p></li>
<li><p><strong>output_dir</strong> (<em>str</em><em>, </em><em>optional</em>) – The name of the output directory which contains the output files in the
case  <code class="docutils literal notranslate"><span class="pre">save</span></code> is True.</p></li>
<li><p><strong>plot</strong> (<em>bool</em><em>, </em><em>optional</em>) – Whether to show the best-fit model against data.</p></li>
<li><p><strong>col</strong> (<em>str</em><em>, </em><em>optional</em>) – Color used for data points.</p></li>
<li><p><strong>lbda_obs</strong> (<em>1d ndarrays</em><em>, </em><em>optional</em>) – Must be provided if plot is set to True</p></li>
<li><p><strong>spec_obs</strong> (<em>1d ndarrays</em><em>, </em><em>optional</em>) – Must be provided if plot is set to True</p></li>
<li><p><strong>spec_obs_err</strong> (<em>1d ndarrays</em><em>, </em><em>optional</em>) – Must be provided if plot is set to True</p></li>
<li><p><strong>n_pts</strong> (<em>None</em><em> or </em><em>int</em><em>, </em><em>optional</em>) – If None, models will be sampled at the same resolution as measured
spectrum for plot. If an integer, corresponds to the number of sampled
points (uniform sampling) between the first and last point of the
measured spectrum.</p></li>
<li><p><strong>title</strong> (<em>str</em><em>, </em><em>optional</em>) – If plot is set to True, title of the plot.</p></li>
<li><p><strong>kwargs</strong> – Additional optional arguments passed to <cite>nested_spec_sampling</cite> - only
used if plot is set to True and model parameters are evaluated.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>final_res</strong> – Best-fit parameters and uncertainties (corresponding to 68% confidence
interval). Dimensions: nparams x 2.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>numpy ndarray</p>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-special.spec_corr">
<span id="special-spec-corr-module"></span><h2>special.spec_corr module<a class="headerlink" href="#module-special.spec_corr" title="Permalink to this headline"></a></h2>
<p>Module to estimate the spectral correlation between channels of an IFS datacube.</p>
<dl class="py function">
<dt class="sig sig-object py" id="special.spec_corr.combine_spec_corrs">
<span class="sig-prename descclassname"><span class="pre">special.spec_corr.</span></span><span class="sig-name descname"><span class="pre">combine_spec_corrs</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">arr_list</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/special/spec_corr.html#combine_spec_corrs"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#special.spec_corr.combine_spec_corrs" title="Permalink to this definition"></a></dt>
<dd><p>Combines the spectral correlation matrices of different instruments
into a single square matrix (required for input of spectral fits).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>arr_list</strong> (<em>list</em><em> or </em><em>tuple of numpy ndarrays</em>) – List/tuple containing the distinct square spectral correlation matrices
OR ones (for independent photometric measurements).</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>combi_corr</strong> – 2d square ndarray representing the combined spectral correlation.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>numpy 2d ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="special.spec_corr.spectral_correlation">
<span class="sig-prename descclassname"><span class="pre">special.spec_corr.</span></span><span class="sig-name descname"><span class="pre">spectral_correlation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">array</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">awidth</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">r_in</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">r_out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pl_xy</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask_r</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">4</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fwhm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">4</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sp_fwhm_guess</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">3</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">full_output</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/special/spec_corr.html#spectral_correlation"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#special.spec_corr.spectral_correlation" title="Permalink to this definition"></a></dt>
<dd><p>Computes the spectral correlation between (post-processed) IFS frames,
as a function of radius, implemented as Eq. 7 of <a class="reference internal" href="#gre16" id="id29"><span>[GRE16]</span></a>. This is a crucial
step for an unbiased fit of a measured IFS spectrum to either synthetic or
template spectra.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>array</strong> (<em>numpy ndarray</em>) – Input cube or 3d array, of dimensions n_ch x n_y x n_x; where n_y and
n_x should be odd values (star should be centered on central pixel).</p></li>
<li><p><strong>awidth</strong> (<em>int</em><em>, </em><em>optional</em>) – Width in pixels of the concentric annuli used to compute the spectral
correlation as a function of radial separation. Greco &amp; Brandt 2017
noted no significant differences for annuli between 1 and 3 pixels
width on GPI data.</p></li>
<li><p><strong>r_in</strong> (<em>int</em><em>, </em><em>optional</em>) – Innermost radius where the spectral correlation starts to be computed.</p></li>
<li><p><strong>r_out</strong> (<em>int</em><em>, </em><em>optional</em>) – Outermost radius where the spectral correlation is computed. If left as
None, it will automatically be computed up to the edge of the frame.</p></li>
<li><p><strong>pl_xy</strong> (<em>tuple of tuples of 2 floats</em><em>, </em><em>optional</em>) – x,y coordinates of all companions present in the images. If provided,
a circle centered on the location of each companion will be masked out
for the spectral correlation computation.</p></li>
<li><p><strong>mask_r</strong> (<em>float</em><em>, </em><em>optional</em>) – if pl_xy is provided, this should also be provided. Size of the
aperture around each companion (in terms of fwhm) that is discarded to
not bias the spectral correlation computation.</p></li>
<li><p><strong>fwhm</strong> (<em>float</em><em>, </em><em>optional</em>) – if pl_xy is provided, this should also be provided. By default we
consider a 2FWHM aperture mask around each companion to not bias the
spectral correlation computation.</p></li>
<li><p><strong>sp_fwhm_guess</strong> (<em>float</em><em>, </em><em>optional</em>) – Initial guess on the spectral FWHM of all channels.</p></li>
<li><p><strong>full_output</strong> (<em>bool</em><em>, </em><em>opt</em>) – Whether to also output the fitted spectral FWHM for each channel, and
the vector of radial separation at which each spectral correlation
matrix is calculated.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>sp_corr</strong> (<em>numpy ndarray</em>) – 3d array of spectral correlation, as a function of radius with
dimensions: n_rad x n_ch x n_ch, where n_rad = int((r_out-r_in)/2)</p></li>
<li><p><strong>sp_fwhm</strong> (<em>numpy ndarray</em>) – (if full_output is True) 2d array containing the spectral fwhm at each
radius, for each spectral channel. Dims: n_rad x n_ch</p></li>
<li><p><strong>sp_rad</strong> (<em>numpy ndarray</em>) – (if full_output is True) 1d array containing the radial separation of
each measured spectral correlation matrix. Dims: n_rad</p></li>
</ul>
</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Radii that are skipped will be filled with zeros in the output cube.</p>
</div>
</dd></dl>

</section>
<section id="module-special.spec_indices">
<span id="special-spec-indices-module"></span><h2>special.spec_indices module<a class="headerlink" href="#module-special.spec_indices" title="Permalink to this headline"></a></h2>
<p>Module with utilities to estimate the spectral type and gravity of an object
based on spectral indices.</p>
<dl class="citation">
<dt class="label" id="gor03"><span class="brackets">GOR03</span><span class="fn-backref">(<a href="#id31">1</a>,<a href="#id32">2</a>,<a href="#id36">3</a>,<a href="#id39">4</a>)</span></dt>
<dd><div class="line-block">
<div class="line">Gorlova et al. 2003</div>
<div class="line"><strong>Gravity Indicators in the Near-Infrared Spectra of Brown Dwarfs</strong></div>
<div class="line"><em>The Astrophysical Journal, Volume 593, Issue 1, pp. 1074-1092</em></div>
<div class="line"><a class="reference external" href="https://arxiv.org/abs/astro-ph/0305147">https://arxiv.org/abs/astro-ph/0305147</a></div>
</div>
</dd>
<dt class="label" id="sle04"><span class="brackets">SLE04</span><span class="fn-backref">(<a href="#id34">1</a>,<a href="#id38">2</a>)</span></dt>
<dd><div class="line-block">
<div class="line">Slesnick et al. 2004</div>
<div class="line"><strong>The Spectroscopically Determined Substellar Mass Function of the Orion
Nebula Cluster</strong></div>
<div class="line"><em>The Astrophysical Journal, Volume 610, Issue 1, pp. 1045-1063</em></div>
<div class="line"><a class="reference external" href="https://arxiv.org/abs/astro-ph/0404292">https://arxiv.org/abs/astro-ph/0404292</a></div>
</div>
</dd>
<dt class="label" id="all07"><span class="brackets">ALL07</span><span class="fn-backref">(<a href="#id30">1</a>,<a href="#id33">2</a>,<a href="#id35">3</a>,<a href="#id37">4</a>,<a href="#id40">5</a>)</span></dt>
<dd><div class="line-block">
<div class="line">Allers et al. 2007</div>
<div class="line"><strong>Characterizing Young Brown Dwarfs Using Low-Resolution Near-Infrared
Spectra</strong></div>
<div class="line"><em>The Astrophysical Journal, Volume 657, Issue 1, pp. 511-520</em></div>
<div class="line"><a class="reference external" href="https://arxiv.org/abs/astro-ph/0611408">https://arxiv.org/abs/astro-ph/0611408</a></div>
</div>
</dd>
</dl>
<dl class="py function">
<dt class="sig sig-object py" id="special.spec_indices.digit_to_spt">
<span class="sig-prename descclassname"><span class="pre">special.spec_indices.</span></span><span class="sig-name descname"><span class="pre">digit_to_spt</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">idx</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">convention</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'splat'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/special/spec_indices.html#digit_to_spt"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#special.spec_indices.digit_to_spt" title="Permalink to this definition"></a></dt>
<dd><p>Converts an integer index into spectral type.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>idx</strong> (<em>float</em><em> or </em><em>int</em>) – Index value of the spectral type</p></li>
<li><p><strong>convention</strong> (<em>str</em><em>, </em><em>optional {'splat'</em><em>, </em><em>'Allers+07'}</em>) – Which convention to use to convert digit into spectral type.
Convention from splat: K0 = 0, M0=10, L0=20, T0=30, Y9 = 49
Convention from Allers+07: M0 = 0, L0 = 10, …</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>spt</strong> – String representing the spectral index</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>str</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="special.spec_indices.sp_idx_to_gravity">
<span class="sig-prename descclassname"><span class="pre">special.spec_indices.</span></span><span class="sig-name descname"><span class="pre">sp_idx_to_gravity</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">idx</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'Na-1.1'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/special/spec_indices.html#sp_idx_to_gravity"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#special.spec_indices.sp_idx_to_gravity" title="Permalink to this definition"></a></dt>
<dd><p>Provides a qualitative estimate of the gravity/youth based on a
gravity-sensitive spectral index. Implemented so far:</p>
<ul class="simple">
<li><p>the Na-1.1 index <a class="reference internal" href="#all07" id="id30"><span>[ALL07]</span></a></p></li>
<li><p>the CO-2.3 index <a class="reference internal" href="#gor03" id="id31"><span>[GOR03]</span></a></p></li>
</ul>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>idx</strong> (<em>float</em>) – Value of spectral index</p></li>
<li><p><strong>name</strong> (<em>str</em><em>, </em><em>optional {'Na-1.1'</em><em>, </em><em>'CO-2.3'}</em>) – The name of the spectral index.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="special.spec_indices.sp_idx_to_spt">
<span class="sig-prename descclassname"><span class="pre">special.spec_indices.</span></span><span class="sig-name descname"><span class="pre">sp_idx_to_spt</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">idx</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'H2O-1.5'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">idx_err</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">young</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/special/spec_indices.html#sp_idx_to_spt"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#special.spec_indices.sp_idx_to_spt" title="Permalink to this definition"></a></dt>
<dd><dl class="simple">
<dt>Estimates a spectral type from a spectral index. Implemented so far:</dt><dd><ul class="simple">
<li><p>the H2O 1.3 mu index <a class="reference internal" href="#gor03" id="id32"><span>[GOR03]</span></a></p></li>
<li><p>the H2O 1.5 mu index <a class="reference internal" href="#all07" id="id33"><span>[ALL07]</span></a></p></li>
<li><p>the H2O-2 index <a class="reference internal" href="#sle04" id="id34"><span>[SLE04]</span></a></p></li>
</ul>
</dd>
</dl>
<p>Note on scale of SpT: 0 = M0, 10 = L0.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>idx</strong> (<em>float</em>) – Value of spectral index</p></li>
<li><p><strong>name</strong> (<em>str</em><em>, </em><em>optional {'H2O-1.3'</em><em>, </em><em>'H2O-1.5</em><em>, </em><em>'H2O-2'}</em>) – The name of the spectral index.</p></li>
<li><p><strong>idx_err</strong> (<em>float</em><em>, </em><em>optional</em>) – Uncertainty on the spectral index value</p></li>
<li><p><strong>young</strong> (<em>bool</em><em>, </em><em>opt</em>) – Whether the object is likely young (only used for ‘H2O-1.3’ index, which
is gravity dependent)</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>spt</strong> (<em>float</em>) – Value of the spectral type</p></li>
<li><p><strong>spt_err</strong> (<em>float</em>) – [if idx_err is provided] Uncertainty on the spectral type.</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="special.spec_indices.spectral_idx">
<span class="sig-prename descclassname"><span class="pre">special.spec_indices.</span></span><span class="sig-name descname"><span class="pre">spectral_idx</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">lbda</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">spec</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">band</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'H2O-1.5'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">spec_err</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/special/spec_indices.html#spectral_idx"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#special.spec_indices.spectral_idx" title="Permalink to this definition"></a></dt>
<dd><dl class="simple">
<dt>Computes a spectral index. Implemented so far:</dt><dd><ul class="simple">
<li><p>the Na 1.1 mu index <a class="reference internal" href="#all07" id="id35"><span>[ALL07]</span></a></p></li>
<li><p>the H2O 1.3 mu index <a class="reference internal" href="#gor03" id="id36"><span>[GOR03]</span></a></p></li>
<li><p>the H2O 1.5 mu index <a class="reference internal" href="#all07" id="id37"><span>[ALL07]</span></a></p></li>
<li><p>the H2O 2 index <a class="reference internal" href="#sle04" id="id38"><span>[SLE04]</span></a></p></li>
<li><p>the CO 2.3 index <a class="reference internal" href="#gor03" id="id39"><span>[GOR03]</span></a>.</p></li>
</ul>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>lbda</strong> (<em>numpy ndarray</em>) – 1d numpy array containing the wavelengths of the spectrum in microns.</p></li>
<li><p><strong>spec</strong> (<em>numpy ndarray</em>) – 1d numpy array containing the measured flux (arbitrary units accepted).</p></li>
<li><p><strong>band</strong> (<em>str</em><em>, </em><em>optional {'H2O-1.5'</em><em>, </em><em>'H2O-1.3'</em><em>, </em><em>'H2O-2'</em><em>, </em><em>'Na-1.1'</em><em>, </em><em>'CO-2.3'}</em>) – Name of the band where the spectral index is defined (spectral feature
+ wavelength in mu)</p></li>
<li><p><strong>spec_err</strong> (<em>numpy ndarray</em><em>, </em><em>optional</em>) – 1d numpy array containing the uncertainties on the measured flux
(arbitrary units accepted). If provided the uncertainty on the spectral
index will also be returned.</p></li>
<li><p><strong>verbose</strong> (<em>bool</em><em>, </em><em>optional</em>) – Whther to print more information.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>index</strong> (<em>float</em>) – Value of the spectral index</p></li>
<li><p><strong>index_err</strong> (<em>float</em>) – [if spec_err is provided] Uncertainty on the spectral index.</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="special.spec_indices.spt_to_digit">
<span class="sig-prename descclassname"><span class="pre">special.spec_indices.</span></span><span class="sig-name descname"><span class="pre">spt_to_digit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">spt</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">convention</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'splat'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/special/spec_indices.html#spt_to_digit"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#special.spec_indices.spt_to_digit" title="Permalink to this definition"></a></dt>
<dd><p>Converts a string representing spectral type into an integer index.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>spt</strong> (<em>str</em>) – String representing the spectral index</p></li>
<li><p><strong>convention</strong> (<em>str</em><em>, </em><em>optional {'splat'</em><em>, </em><em>'Allers+07'}</em>) – Which convention to use to convert digit into spectral type.
Convention from splat: K0 = 0, M0=10, L0=20, T0=30, Y9 = 49
Convention from <a class="reference internal" href="#all07" id="id40"><span>[ALL07]</span></a>: M0 = 0, L0 = 10, …</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>idx</strong> – Index value of the spectral type</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>float or int</p>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-special.template_fit">
<span id="special-template-fit-module"></span><h2>special.template_fit module<a class="headerlink" href="#module-special.template_fit" title="Permalink to this headline"></a></h2>
<p>Module for simplex or grid search of best fit spectrum in a template library.</p>
<dl class="py function">
<dt class="sig sig-object py" id="special.template_fit.best_fit_tmp">
<span class="sig-prename descclassname"><span class="pre">special.template_fit.</span></span><span class="sig-name descname"><span class="pre">best_fit_tmp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">lbda_obs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">spec_obs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">err_obs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tmp_reader</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">search_mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'simplex'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_best</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lambda_scal</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scale_range</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">(0.1,</span> <span class="pre">10,</span> <span class="pre">0.01)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ext_range</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">simplex_options</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dlbda_obs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">instru_corr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">instru_res</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">instru_idx</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">filter_reader</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lib_dir</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'tmp_lib/'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tmp_endswith</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'.fits'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">red_chi2</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">remove_nan</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nproc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbosity</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">force_continue</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">min_npts</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/special/template_fit.html#best_fit_tmp"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#special.template_fit.best_fit_tmp" title="Permalink to this definition"></a></dt>
<dd><p>Finds the best fit template spectrum to a given observed spectrum,
within a spectral library.  By default, a single free parameter is
considered: the scaling factor of the spectrum. A first automatic scaling
is performed by comparing the flux of the observed and template spectra at
lambda_scal. Then a more refined scaling is performed, either through
simplex or grid search (within scale_range).
If fit_extinction is set to True, the exctinction is also considered as a
free parameter.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>lbda_obs</strong> (<em>numpy 1d ndarray</em><em> or </em><em>list</em>) – Wavelengths of observed spectrum. If several instruments were used, the
wavelengths should be ordered per instrument, not necessarily as
monotonically increasing wavelength. Hereafter, <span class="math notranslate nohighlight">\(n_{ch}\)</span> is the
length of <code class="docutils literal notranslate"><span class="pre">lbda_obs</span></code>.</p></li>
<li><p><strong>spec_obs</strong> (<em>numpy 1d ndarray</em><em> or </em><em>list</em>) – Observed spectrum for each value of <code class="docutils literal notranslate"><span class="pre">lbda_obs</span></code>. Should have a length
of <span class="math notranslate nohighlight">\(n_{ch}\)</span>.</p></li>
<li><p><strong>err_obs</strong> (<em>numpy 1d/2d ndarray</em><em> or </em><em>list</em>) – Uncertainties on the observed spectrum. The array (list) can have either
a length of <span class="math notranslate nohighlight">\(n_{ch}\)</span>, or a shape of <span class="math notranslate nohighlight">\((2,n_{ch})\)</span> for lower
(first column) and upper (second column) uncertainties provided.</p></li>
<li><p><strong>tmp_reader</strong> (<em>python routine</em>) – External routine that reads a model file and returns a 3D numpy array,
where the first column corresponds to wavelengths, the second
contains flux values, and the third the uncertainties on the flux.</p></li>
<li><p><strong>search_mode</strong> (<em>str</em><em>, </em><em>optional</em><em>, </em><em>{'simplex'</em><em>,</em><em>'grid'}</em>) – How is the best fit template found? Simplex or grid search.</p></li>
<li><p><strong>n_best</strong> (<em>int</em><em>, </em><em>optional</em>) – Number of best templates to be returned (default: 1)</p></li>
<li><p><strong>lambda_scal</strong> (<em>float</em><em>, </em><em>optional</em>) – Wavelength where a first scaling will be performed between template
and observed spectra. If not provided, the middle wavelength of the
osberved spectra will be considered.</p></li>
<li><p><strong>scale_range</strong> (<em>tuple</em><em>, </em><em>opt</em>) – If grid search, this parameter should be provided as a tuple of 3
floats: lower limit, upper limit and step of the grid search for the
scaling factor to be applied AFTER the first rough scaling (i.e.
scale_range should always encompass 1).</p></li>
<li><p><strong>ext_range</strong> (<em>tuple</em><em> or </em><em>None</em><em>, </em><em>opt</em>) – <ul>
<li><p>If None: differential extinction is not considered as a free parameter.</p></li>
<li><p>If a tuple: it should contain 2 floats (for simplex         <code class="docutils literal notranslate"><span class="pre">search_mode</span></code>) or 3 floats (for grid search <code class="docutils literal notranslate"><span class="pre">search_mode</span></code>)         corresponding to the lower limit, upper limit (and step for the grid         search). For the simplex search, the lower and upper limits are used         to set a chi square of infinity outside of the range.</p></li>
</ul>
</p></li>
<li><p><strong>dlbda_obs</strong> (<em>numpy 1d ndarray</em><em> or </em><em>list</em><em>, </em><em>optional</em>) – Respective spectral channel width or FWHM of the photometric filters
used for each point of the observed spectrum. This vector is used to
infer which part(s) of a combined spectro+photometric spectrum should
involve convolution+subsampling (model resolution higher than
measurements), interpolation (the opposite), or convolution by the
transmission curve of a photometric filter. If not provided, it will be
inferred from the difference between consecutive lbda_obs points (i.e.
inaccurate for a combined spectrum). It must be provided IF one wants to
weigh each measurement based on the spectral resolution of each
instrument (as in <a class="reference internal" href="#olo16" id="id41"><span>[OLO16]</span></a>), through the <code class="docutils literal notranslate"><span class="pre">use_weights</span></code> argument.</p></li>
<li><p><strong>instru_corr</strong> (<em>numpy 2d ndarray</em><em>, </em><em>optional</em>) – Spectral correlation between post-processed images in which the
spectrum is measured. It is specific to the instrument, PSF subtraction
algorithm and radial separation of the companion from the central star.
Can be computed using <code class="docutils literal notranslate"><span class="pre">special.spec_corr.spectral_correlation</span></code>. In
case of a spectrum obtained with different instruments, it is
recommended to construct the final spectral_correlation matrix with
<code class="docutils literal notranslate"><span class="pre">special.spec_corr.combine_corrs</span></code>. If <code class="docutils literal notranslate"><span class="pre">instru_corr</span></code> is not provided,
the uncertainties in each spectral channel will be considered
independent. See <a class="reference internal" href="#gre16" id="id42"><span>[GRE16]</span></a> for more details.</p></li>
<li><p><strong>instru_res</strong> (<em>float</em><em> or </em><em>list of floats/strings</em><em>, </em><em>optional</em>) – The mean instrumental resolving power(s) OR filter names. This is
used to convolve the model spectrum. If several instruments are used,
provide a list of resolving power values / filter names, one for
each instrument used.</p></li>
<li><p><strong>instru_idx</strong> (<em>numpy 1d array</em><em>, </em><em>optional</em>) – 1d array containing an index representing each instrument used
to obtain the spectrum, label them from 0 to the number of instruments
(<span class="math notranslate nohighlight">\(n_{ins}\)</span>). Zero for points that don’t correspond to any of the
<code class="docutils literal notranslate"><span class="pre">instru_res</span></code> values provided, and i in <span class="math notranslate nohighlight">\([1,n_{ins}]\)</span> for points
associated to instru_res[i-1]. This parameter must be provided if the
spectrum consists of points obtained with different instruments.</p></li>
<li><p><strong>filter_reader</strong> (<em>python routine</em><em>, </em><em>optional</em>) – <p>External routine that reads a filter file and returns a 2D numpy array,
where the first column corresponds to wavelengths, and the second
contains transmission values. Important: if not provided, but strings
are detected in instru_res, the default file reader will be used.
It assumes the following format for the files:</p>
<ul>
<li><p>first row contains headers (titles of each column)</p></li>
<li><p>starting from 2nd row: 1st column: wavelength, 2nd col.: transmission</p></li>
<li><p>Unit of wavelength can be provided in parentheses of first header         key name: e.g. “WL(AA)” for angstrom, “wavelength(mu)” for micrometer         or “lambda(nm)” for nanometer. Note: only what is in parentheses         matters for the units.</p></li>
</ul>
</p></li>
<li><p><strong>simplex_options</strong> (<em>dict</em><em>, </em><em>optional</em>) – The scipy.optimize.minimize simplex (Nelder-Mead) options.</p></li>
<li><p><strong>red_chi2</strong> (<em>bool</em><em>, </em><em>optional</em>) – Whether to compute the reduced chi square. If False, considers chi^2.</p></li>
<li><p><strong>remove_nan</strong> (<em>bool</em><em>, </em><em>optional</em>) – Whether to remove NaN values from template spectrum BEFORE resampling
to the wavelength sampling of the observed spectrum. Whether it is set
to True or False, a check is made just before chi^2 is calculated
(after resampling), and only non-NaN values will be considered.</p></li>
<li><p><strong>nproc</strong> (<em>None</em><em> or </em><em>int</em><em>, </em><em>optional</em>) – The number of processes to use for parallelization. If set to None,
will automatically use half of the available CPUs on the machine.</p></li>
<li><p><strong>verbosity</strong> (<em>0</em><em>, </em><em>1</em><em> or </em><em>2</em><em>, </em><em>optional</em>) – Verbosity level. 0 for no output and 2 for full information.</p></li>
<li><p><strong>force_continue</strong> (<em>bool</em><em>, </em><em>optional</em>) – In case of issue with the fit, whether to continue regardless (this may
be useful in an uneven spectral library, where some templates have too
few points for the fit to be performed).</p></li>
<li><p><strong>min_npts</strong> (<em>int</em><em> or </em><em>None</em><em>, </em><em>optional</em>) – Minimum number of (resampled) points to consider a
template spectrum valid in the minimization search.</p></li>
<li><p><strong>**kwargs</strong> (<em>optional</em>) – Optional arguments to the scipy.optimize.minimize function</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>final_tmpname</strong> (<em>tuple of n_best str</em>) – Best-fit template filenames</p></li>
<li><p><strong>final_tmp</strong> (<em>tuple of n_best 3D numpy array</em>) – Best-fit template spectra (3D: lbda+spec+spec_err)</p></li>
<li><p><strong>final_chi</strong> (<em>1D numpy array of length n_best</em>) – Best-fit template chi^2</p></li>
<li><p><strong>final_params</strong> (<em>2D numpy array (2xn_best)</em>) – Best-fit parameters (optimal scaling and optical extinction). Note if
extinction is not fitted, optimal AV will be set to 0.</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="special.template_fit.get_chi">
<span class="sig-prename descclassname"><span class="pre">special.template_fit.</span></span><span class="sig-name descname"><span class="pre">get_chi</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">lbda_obs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">spec_obs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">err_obs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tmp_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tmp_reader</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">search_mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'simplex'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lambda_scal</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scale_range</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">(0.1,</span> <span class="pre">10,</span> <span class="pre">0.01)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ext_range</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dlbda_obs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">instru_corr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">instru_res</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">instru_idx</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_weights</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">filter_reader</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">simplex_options</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">red_chi2</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">remove_nan</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">force_continue</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">min_npts</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/special/template_fit.html#get_chi"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#special.template_fit.get_chi" title="Permalink to this definition"></a></dt>
<dd><p>Routine calculating chi^2, optimal scaling factor and optimal
extinction for a given template spectrum to match an observed spectrum.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>lbda_obs</strong> (<em>numpy 1d ndarray</em><em> or </em><em>list</em>) – Wavelengths of observed spectrum. If several instruments were used, the
wavelengths should be ordered per instrument, not necessarily as
monotonically increasing wavelength. Hereafter, <span class="math notranslate nohighlight">\(n_{ch}\)</span> is the
length of <code class="docutils literal notranslate"><span class="pre">lbda_obs</span></code>.</p></li>
<li><p><strong>spec_obs</strong> (<em>numpy 1d ndarray</em><em> or </em><em>list</em>) – Observed spectrum for each value of <code class="docutils literal notranslate"><span class="pre">lbda_obs</span></code>. Should have a length
of <span class="math notranslate nohighlight">\(n_{ch}\)</span>.</p></li>
<li><p><strong>err_obs</strong> (<em>numpy 1d/2d ndarray</em><em> or </em><em>list</em>) – Uncertainties on the observed spectrum. The array (list) can have either
a length of <span class="math notranslate nohighlight">\(n_{ch}\)</span>, or a shape of <span class="math notranslate nohighlight">\((2,n_{ch})\)</span> for lower
(first column) and upper (second column) uncertainties provided.</p></li>
<li><p><strong>tmp_name</strong> (<em>str</em>) – Template spectrum filename.</p></li>
<li><p><strong>tmp_reader</strong> (<em>python routine</em>) – External routine that reads a model file and returns a 3D numpy array,
where the first column corresponds to wavelengths, the second
contains flux values, and the third the uncertainties on the flux.</p></li>
<li><p><strong>search_mode</strong> (<em>str</em><em>, </em><em>opt {'simplex'</em><em>, </em><em>'grid'}</em>) – How is the best fit template found? Simplex or grid search.</p></li>
<li><p><strong>lambda_scal</strong> (<em>float</em><em>, </em><em>optional</em>) – Wavelength where a first scaling will be performed between template
and observed spectra. If not provided, the middle wavelength of the
osberved spectra will be considered.</p></li>
<li><p><strong>scale_range</strong> (<em>tuple</em><em>, </em><em>opt</em>) – If grid search, this parameter should be provided as a tuple of 3
floats: lower limit, upper limit and step of the grid search for the
scaling factor to be applied AFTER the first rough scaling (i.e.
scale_range should always encompass 1).</p></li>
<li><p><strong>ext_range</strong> (<em>tuple</em><em> or </em><em>None</em><em>, </em><em>opt</em>) – <ul>
<li><p>If None: differential extinction is not considered as a free parameter.</p></li>
<li><p>If a tuple: it should contain 2 floats (for simplex         <code class="docutils literal notranslate"><span class="pre">search_mode</span></code>) or 3 floats (for grid search <code class="docutils literal notranslate"><span class="pre">search_mode</span></code>)         corresponding to the lower limit, upper limit (and step for the grid         search). For the simplex search, the lower and upper limits are used         to set a chi square of infinity outside of the range.</p></li>
</ul>
</p></li>
<li><p><strong>dlbda_obs</strong> (<em>numpy 1d ndarray</em><em> or </em><em>list</em><em>, </em><em>optional</em>) – Respective spectral channel width or FWHM of the photometric filters
used for each point of the observed spectrum. This vector is used to
infer which part(s) of a combined spectro+photometric spectrum should
involve convolution+subsampling (model resolution higher than
measurements), interpolation (the opposite), or convolution by the
transmission curve of a photometric filter. If not provided, it will be
inferred from the difference between consecutive lbda_obs points (i.e.
inaccurate for a combined spectrum). It must be provided IF one wants to
weigh each measurement based on the spectral resolution of each
instrument (as in <a class="reference internal" href="#olo16" id="id43"><span>[OLO16]</span></a>), through the <code class="docutils literal notranslate"><span class="pre">use_weights</span></code> argument.</p></li>
<li><p><strong>instru_corr</strong> (<em>numpy 2d ndarray</em><em>, </em><em>optional</em>) – Spectral correlation between post-processed images in which the
spectrum is measured. It is specific to the instrument, PSF subtraction
algorithm and radial separation of the companion from the central star.
Can be computed using <code class="docutils literal notranslate"><span class="pre">special.spec_corr.spectral_correlation</span></code>. In
case of a spectrum obtained with different instruments, it is
recommended to construct the final spectral_correlation matrix with
<code class="docutils literal notranslate"><span class="pre">special.spec_corr.combine_corrs</span></code>. If <code class="docutils literal notranslate"><span class="pre">instru_corr</span></code> is not provided,
the uncertainties in each spectral channel will be considered
independent. See <a class="reference internal" href="#gre16" id="id44"><span>[GRE16]</span></a> for more details.</p></li>
<li><p><strong>instru_res</strong> (<em>float</em><em> or </em><em>list of floats/strings</em><em>, </em><em>optional</em>) – The mean instrumental resolving power(s) OR filter names. This is
used to convolve the model spectrum. If several instruments are used,
provide a list of resolving power values / filter names, one for
each instrument used.</p></li>
<li><p><strong>instru_idx</strong> (<em>numpy 1d array</em><em>, </em><em>optional</em>) – 1d array containing an index representing each instrument used
to obtain the spectrum, label them from 0 to the number of instruments
(<span class="math notranslate nohighlight">\(n_{ins}\)</span>). Zero for points that don’t correspond to any of the
<code class="docutils literal notranslate"><span class="pre">instru_res</span></code> values provided, and i in <span class="math notranslate nohighlight">\([1,n_{ins}]\)</span> for points
associated to instru_res[i-1]. This parameter must be provided if the
spectrum consists of points obtained with different instruments.</p></li>
<li><p><strong>use_weights</strong> (<em>bool</em><em>, </em><em>optional</em>) – For the likelihood calculation, whether to weigh each point of the
spectrum based on the spectral resolution or bandwidth of photometric
filters used. Weights will be proportional to <code class="docutils literal notranslate"><span class="pre">dlbda_obs/lbda_obs</span></code> if
<code class="docutils literal notranslate"><span class="pre">dlbda_obs</span></code> is provided, or set to 1 for all points otherwise.</p></li>
<li><p><strong>filter_reader</strong> (<em>python routine</em><em>, </em><em>optional</em>) – <p>External routine that reads a filter file and returns a 2D numpy array,
where the first column corresponds to wavelengths, and the second
contains transmission values. Important: if not provided, but strings
are detected in instru_res, the default file reader will be used.
It assumes the following format for the files:</p>
<ul>
<li><p>first row contains headers (titles of each column)</p></li>
<li><p>starting from 2nd row: 1st column: wavelength, 2nd col.: transmission</p></li>
<li><p>Unit of wavelength can be provided in parentheses of first header         key name: e.g. “WL(AA)” for angstrom, “wavelength(mu)” for micrometer         or “lambda(nm)” for nanometer. Note: only what is in parentheses         matters for the units.</p></li>
</ul>
</p></li>
<li><p><strong>red_chi2</strong> (<em>bool</em><em>, </em><em>optional</em>) – Whether to compute the reduced chi square. If False, considers chi^2.</p></li>
<li><p><strong>remove_nan</strong> (<em>bool</em><em>, </em><em>optional</em>) – Whether to remove NaN values from template spectrum BEFORE resampling
to the wavelength sampling of the observed spectrum. Whether it is set
to True or False, a check is made just before chi^2 is calculated
(after resampling), and only non-NaN values will be considered.</p></li>
<li><p><strong>simplex_options</strong> (<em>dict</em><em>, </em><em>optional</em>) – The <code class="docutils literal notranslate"><span class="pre">scipy.optimize.minimize</span></code> simplex (Nelder-Mead) options.</p></li>
<li><p><strong>force_continue</strong> (<em>bool</em><em>, </em><em>optional</em>) – In case of issue with the fit, whether to continue regardless (this may
be useful in an uneven spectral library, where some templates have too
few points for the fit to be performed).</p></li>
<li><p><strong>verbose</strong> (<em>str</em><em>, </em><em>optional</em>) – Whether to print more information when fit fails.</p></li>
<li><p><strong>min_npts</strong> (<em>int</em><em> or </em><em>None</em><em>, </em><em>optional</em>) – Iinimum number of (resampled) points to consider a template spectrum
valid in the minimization search. A Nan value will be returned for chi
if the condition is not met.</p></li>
<li><p><strong>**kwargs</strong> (<em>optional</em>) – Other optional arguments to the <code class="docutils literal notranslate"><span class="pre">scipy.optimize.minimize</span></code> function.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>best_chi</strong> (<em>float</em>) – goodness of fit scored by the template</p></li>
<li><p><em>best_scal</em> – best-fit scaling factor for the considered template</p></li>
<li><p><em>best_ext</em> – best-fit optical extinction for the considered template</p></li>
</ul>
</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If several filter filenames are provided in <code class="docutils literal notranslate"><span class="pre">instru_res</span></code>, the filter files
must all have the same format and wavelength units (for reading by the same
<code class="docutils literal notranslate"><span class="pre">filter_reader</span></code> snippet or default function).</p>
</div>
</dd></dl>

</section>
<section id="module-special.utils_mcmc">
<span id="special-utils-mcmc-module"></span><h2>special.utils_mcmc module<a class="headerlink" href="#module-special.utils_mcmc" title="Permalink to this headline"></a></h2>
<p>Module with utility functions to the MCMC (<code class="docutils literal notranslate"><span class="pre">emcee</span></code>) sampling for
parameter estimation.</p>
<dl class="py function">
<dt class="sig sig-object py" id="special.utils_mcmc.auto_window">
<span class="sig-prename descclassname"><span class="pre">special.utils_mcmc.</span></span><span class="sig-name descname"><span class="pre">auto_window</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">taus</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">c</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/special/utils_mcmc.html#auto_window"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#special.utils_mcmc.auto_window" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="special.utils_mcmc.autocorr">
<span class="sig-prename descclassname"><span class="pre">special.utils_mcmc.</span></span><span class="sig-name descname"><span class="pre">autocorr</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">c</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">5.0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/special/utils_mcmc.html#autocorr"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#special.utils_mcmc.autocorr" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="special.utils_mcmc.autocorr_func_1d">
<span class="sig-prename descclassname"><span class="pre">special.utils_mcmc.</span></span><span class="sig-name descname"><span class="pre">autocorr_func_1d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">norm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/special/utils_mcmc.html#autocorr_func_1d"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#special.utils_mcmc.autocorr_func_1d" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="special.utils_mcmc.autocorr_test">
<span class="sig-prename descclassname"><span class="pre">special.utils_mcmc.</span></span><span class="sig-name descname"><span class="pre">autocorr_test</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">chain</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/special/utils_mcmc.html#autocorr_test"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#special.utils_mcmc.autocorr_test" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="special.utils_mcmc.gelman_rubin">
<span class="sig-prename descclassname"><span class="pre">special.utils_mcmc.</span></span><span class="sig-name descname"><span class="pre">gelman_rubin</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/special/utils_mcmc.html#gelman_rubin"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#special.utils_mcmc.gelman_rubin" title="Permalink to this definition"></a></dt>
<dd><p>Determine the Gelman-Rubin hat{R} statistical test between Markov chains.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>x</strong> (<em>numpy.array</em>) – The numpy.array on which the Gelman-Rubin test is applied. This array
should contain at least 2 set of data, i.e. x.shape &gt;= (2,).</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>out</strong> – The Gelman-Rubin hat{R}.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span><span class="mf">1.0</span><span class="p">,(</span><span class="mi">1</span><span class="p">,</span><span class="mi">100</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="mf">0.1</span><span class="p">,</span><span class="mf">1.3</span><span class="p">,(</span><span class="mi">1</span><span class="p">,</span><span class="mi">100</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">x1</span><span class="p">,</span><span class="n">x2</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gelman_rubin</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">1.0366629898991262</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gelman_rubin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">x1</span><span class="p">,</span><span class="n">x1</span><span class="p">)))</span>
<span class="go">0.99</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="special.utils_mcmc.gelman_rubin_from_chain">
<span class="sig-prename descclassname"><span class="pre">special.utils_mcmc.</span></span><span class="sig-name descname"><span class="pre">gelman_rubin_from_chain</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">chain</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">burnin</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/special/utils_mcmc.html#gelman_rubin_from_chain"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#special.utils_mcmc.gelman_rubin_from_chain" title="Permalink to this definition"></a></dt>
<dd><p>Pack the MCMC chain and determine the Gelman-Rubin hat{R} statistical
test. In other words, two sub-sets are extracted from the chain (burnin
parts are taken into account) and the Gelman-Rubin statistical test is
performed.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>chain</strong> (<em>numpy.array</em>) – The MCMC chain with the shape walkers x steps x model_parameters</p></li>
<li><p><strong>burnin</strong> (<em>float in</em><em> [</em><em>0</em><em>,</em><em>1</em><em>]</em>) – The fraction of a walker which is discarded.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>out</strong> – The Gelman-Rubin hat{R}.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-special.utils_nested">
<span id="special-utils-nested-module"></span><h2>special.utils_nested module<a class="headerlink" href="#module-special.utils_nested" title="Permalink to this headline"></a></h2>
<p>Module with utility functions to the nested sampling for parameter estimation.</p>
<dl class="py function">
<dt class="sig sig-object py" id="special.utils_nested.un_burning">
<span class="sig-prename descclassname"><span class="pre">special.utils_nested.</span></span><span class="sig-name descname"><span class="pre">un_burning</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">res</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">logger</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/special/utils_nested.html#un_burning"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#special.utils_nested.un_burning" title="Permalink to this definition"></a></dt>
<dd><p>Automatic burning of UltraNest chain based on cumulated sum of weights
(as implemented in UltraNest’s cornerplot).</p>
<p>Note: this function is necessary to be able to make corner plots showing
units after best estimates, as ultranest’s cornerplots does not feature
that option and does burning+corner plot together.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>res</strong> (<em>UltraNest result object</em>) – The UltraNest result.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>burned_res</strong> – The burned UltraNest chain and associated weights</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>tuple of 2 numpy nd array</p>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-special.utils_spec">
<span id="special-utils-spec-module"></span><h2>special.utils_spec module<a class="headerlink" href="#module-special.utils_spec" title="Permalink to this headline"></a></h2>
<p>Utility functions for spectral fitting.</p>
<dl class="py function">
<dt class="sig sig-object py" id="special.utils_spec.akaike">
<span class="sig-prename descclassname"><span class="pre">special.utils_spec.</span></span><span class="sig-name descname"><span class="pre">akaike</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">LnL</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">k</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/special/utils_spec.html#akaike"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#special.utils_spec.akaike" title="Permalink to this definition"></a></dt>
<dd><p>Computes the Akaike Information Criterion: 2k-2ln(L),
where k is the number of estimated parameters in the model and LnL is the
max ln-likelihood for the model.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>LnL</strong> (<em>float</em>) – Max ln-likelihood for the considered model.</p></li>
<li><p><strong>k</strong> (<em>int</em>) – Number of estimated parameters in the model.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>aic</strong> – Akaike Information Criterion</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="special.utils_spec.blackbody">
<span class="sig-prename descclassname"><span class="pre">special.utils_spec.</span></span><span class="sig-name descname"><span class="pre">blackbody</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">lbda</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">T</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/special/utils_spec.html#blackbody"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#special.utils_spec.blackbody" title="Permalink to this definition"></a></dt>
<dd><p>Planck function. Returns specific intensity for an input wavelength vector
lbda (in micrometers) and a given input temperature.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>lbda</strong> (<em>numpy array</em>) – 1d numpy array corresponding to the wavelengths (in microns) for the
desired output specific intensities.</p></li>
<li><p><strong>T</strong> (<em>float</em>) – Temperature</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>B_lambda</strong> – Specific intensity corresponding to the Planck function.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="special.utils_spec.convert_F_units">
<span class="sig-prename descclassname"><span class="pre">special.utils_spec.</span></span><span class="sig-name descname"><span class="pre">convert_F_units</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">F</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lbda</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">in_unit</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'cgs'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out_unit</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'si'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/special/utils_spec.html#convert_F_units"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#special.utils_spec.convert_F_units" title="Permalink to this definition"></a></dt>
<dd><p>Function to convert Flux density between [ergs s-1 cm-2 um-1],
[W m-2 um-1] and [Jy].</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>F</strong> (<em>float</em><em> or </em><em>1d array</em>) – Flux</p></li>
<li><p><strong>lbda</strong> (<em>float</em><em> or </em><em>1d array</em>) – Wavelength of the flux (in um)</p></li>
<li><p><strong>in_unit</strong> (<em>str</em><em>, </em><em>opt</em><em>, </em><em>{&quot;si&quot;</em><em>, </em><em>&quot;cgs&quot;</em><em>, </em><em>&quot;jy&quot;</em><em>, </em><em>&quot;cgsA&quot;}</em>) – Input flux units.
‘si’: W/m^2/mu;
‘cgs’: ergs/s/cm^2/mu
‘jy’: janskys
‘cgsA’: erg/s/cm^2/AA</p></li>
<li><p><strong>out_unit</strong> (<em>str</em><em>, </em><em>opt {&quot;si&quot;</em><em>, </em><em>&quot;cgs&quot;</em><em>, </em><em>&quot;jy&quot;}</em>) – Output flux units.</p></li>
</ul>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>Flux in output units.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="special.utils_spec.convert_F_vs_mag">
<span class="sig-prename descclassname"><span class="pre">special.utils_spec.</span></span><span class="sig-name descname"><span class="pre">convert_F_vs_mag</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">value</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">F_0</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">band</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'H'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">system</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'Johnson'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">conversion</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'to_mag'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/special/utils_spec.html#convert_F_vs_mag"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#special.utils_spec.convert_F_vs_mag" title="Permalink to this definition"></a></dt>
<dd><p>Function to convert Flux density (in Jy) to magnitude in a given band, or
the opposite.</p>
<dl class="simple">
<dt>Sources for zero points:</dt><dd><ul class="simple">
<li><p>TOKUNAGA chapter on IR astronomy (from Cohen 1992)</p></li>
<li><p>UKIRT webpage:         (<a class="reference external" href="http://www.jach.hawaii.edu/UKIRT/astronomy/calib/phot_cal/conver.html">http://www.jach.hawaii.edu/UKIRT/astronomy/calib/phot_cal/conver.html</a>)</p></li>
<li><p>van der Bliek et al. 1996 (ESO standard stars)</p></li>
</ul>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>value</strong> (<em>float</em>) – Flux or magnitude to be converted.</p></li>
<li><p><strong>F_0</strong> (<em>float</em><em>, </em><em>opt</em>) – Zero-point flux. If provided will take precedence over band.</p></li>
<li><p><strong>band</strong> (<em>str</em><em>, </em><em>opt</em>) – Band of the given flux or magnitude. Choice between: {‘U’,’B’,’V’, ‘R’,
‘I’, ‘J’, ‘H’, ‘K’, “L”, “L’”, ‘M’, ‘N’, ‘O’}
(but not for all band systems).</p></li>
<li><p><strong>system</strong> (<em>str</em><em>, </em><em>opt</em>) – Band system. Choice between: {‘Johnson;,’2MASS’, ‘UKIRT’, ‘ESO’}</p></li>
<li><p><strong>conversion</strong> (<em>str</em><em>, </em><em>opt</em>) – In which sense to convert: flux to mag (‘to_mag’) or mag to flux
(‘to_flux’)</p></li>
</ul>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>Converted flux or magnitude.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="special.utils_spec.extinction">
<span class="sig-prename descclassname"><span class="pre">special.utils_spec.</span></span><span class="sig-name descname"><span class="pre">extinction</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">lbda</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">AV</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">RV</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">3.1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/special/utils_spec.html#extinction"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#special.utils_spec.extinction" title="Permalink to this definition"></a></dt>
<dd><p>Calculates the A(lambda) extinction for a given combination of A_V and R_V.
If R_V is not provided, assumes an ISM value of R_V=3.1
Uses the Cardelli et al. (1989) empirical formulas.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>lbda</strong> (<em>1d np.ndarray</em>) – Array with the wavelengths (um) for which the extinction is calculated.</p></li>
<li><p><strong>AV</strong> (<em>float</em>) – Extinction (mag) in the V band.</p></li>
<li><p><strong>RV</strong> (<em>float</em><em>, </em><em>opt</em>) – Reddening in the V band: R_V = A_V / E(B-V)</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>Albda</strong> – Extinction (mag) at wavelengths lbda.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>1d np.ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="special.utils_spec.find_nearest">
<span class="sig-prename descclassname"><span class="pre">special.utils_spec.</span></span><span class="sig-name descname"><span class="pre">find_nearest</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">array</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">value</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">output</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'index'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">constraint</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/special/utils_spec.html#find_nearest"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#special.utils_spec.find_nearest" title="Permalink to this definition"></a></dt>
<dd><p>Function to find the indices, and optionally the values, of an array’s n
closest elements to a certain value.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>array</strong> (<em>1d numpy array</em><em> or </em><em>list</em>) – Array in which to check the closest element to value.</p></li>
<li><p><strong>value</strong> (<em>float</em>) – Value for which the algorithm searches for the n closest elements in
the array.</p></li>
<li><p><strong>output</strong> (<em>str</em><em>, </em><em>opt {'index'</em><em>,</em><em>'value'</em><em>,</em><em>'both' }</em>) – Set what is returned</p></li>
<li><p><strong>constraint</strong> (<em>str</em><em>, </em><em>opt {None</em><em>, </em><em>'ceil'</em><em>, </em><em>'floor'}</em>) – If not None, will check for the closest element larger than value (ceil)
or closest element smaller than value (floor).</p></li>
<li><p><strong>n</strong> (<em>int</em><em>, </em><em>opt</em>) – Number of elements to be returned, sorted by proximity to the values.
Default: only the closest value is returned.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><em>Either</em> – (output=’index’): index/indices of the closest n value(s) in the array;
(output=’value’): the closest n value(s) in the array,
(output=’both’): closest value(s) and index/-ices, respectively.</p></li>
<li><p><em>By default, only returns the index/indices.</em></p></li>
<li><p><strong>Possible constraints</strong> (<em>‘ceil’, ‘floor’, None (“ceil” will return the closest</em>)</p></li>
<li><p><em>element with a value greater than ‘value’, “floor” the opposite)</em></p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="special.utils_spec.inject_em_line">
<span class="sig-prename descclassname"><span class="pre">special.utils_spec.</span></span><span class="sig-name descname"><span class="pre">inject_em_line</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">wl</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">flux</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lbda</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">spec</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">width</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">height</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">em</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/special/utils_spec.html#inject_em_line"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#special.utils_spec.inject_em_line" title="Permalink to this definition"></a></dt>
<dd><p>Injects an emission (or absorption) line in a spectrum.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>wl</strong> (<em>float</em>) – Wavelength of the line</p></li>
<li><p><strong>flux</strong> (<em>float</em>) – Flux of the line to be injected</p></li>
<li><p><strong>lbda</strong> (<em>1d np.ndarray</em>) – Array with the wavelengths (um) of the input spectrum.</p></li>
<li><p><strong>spec</strong> (<em>1d np.ndarray</em>) – Input spectrum fluxes</p></li>
<li><p><strong>width</strong> (<em>float</em><em>, </em><em>opt</em>) – Full width of the line in mu (see also height). The line will be
injected assuming a gaussian profile. If not provided, the width will
be set to the ‘equivalent width’ of the line.</p></li>
<li><p><strong>height</strong> (<em>float</em><em>, </em><em>opt</em>) – Ratio to peak where the line width is considered. E.g. if
height=10%, the width will be the full width at 10% maximum.</p></li>
<li><p><strong>em</strong> (<em>bool</em><em>, </em><em>opt</em>) – Whether emission (True) or absorption (False) line.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>spec</strong> – Spectrum with the injected line</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>1d np.ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="special.utils_spec.mj_from_rj_and_logg">
<span class="sig-prename descclassname"><span class="pre">special.utils_spec.</span></span><span class="sig-name descname"><span class="pre">mj_from_rj_and_logg</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rp</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">logg</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/special/utils_spec.html#mj_from_rj_and_logg"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#special.utils_spec.mj_from_rj_and_logg" title="Permalink to this definition"></a></dt>
<dd><p>Estimates a planet mass in Jupiter mass for a given radius in Jupiter
radius and the log of the surface gravity.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>rp</strong> (<em>float</em>) – Planet radius in Jupiter radii</p></li>
<li><p><strong>logg</strong> (<em>float</em>) – Log of the surface gravity</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>mj</strong> – Planet mass in Jupiter masses</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="special.utils_spec.nrefrac">
<span class="sig-prename descclassname"><span class="pre">special.utils_spec.</span></span><span class="sig-name descname"><span class="pre">nrefrac</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">wavelength</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">density</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/special/utils_spec.html#nrefrac"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#special.utils_spec.nrefrac" title="Permalink to this definition"></a></dt>
<dd><p>Calculates refractive index of air from Cauchy formula.
For comparisong to measurements from the ground, the wavelenghts of model
spectra must be slightly shifted using:
lbda_shift = lbda_model/(1+(nrefrac*1e-6))</p>
<p>Input: wavelength in Angstrom,
Returns N = (n-1) * 1.e6.
Credit: France Allard.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>wavelength</strong> (<em>numpy array</em>) – 1d numpy array corresponding to the wavelengths of the input spectrum
in Angstrom</p></li>
<li><p><strong>density</strong> (<em>float</em>) – density of air in amagat (relative to STP, e.g. ~10% decrease per 1000m
above sea level).</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>N</strong> – Refractive index</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-special">
<span id="module-contents"></span><h2>Module contents<a class="headerlink" href="#module-special" title="Permalink to this headline"></a></h2>
<p><code class="docutils literal notranslate"><span class="pre">special</span></code> has helping functions for the analysis of (low-res)
spectra, including:</p>
<ul class="simple">
<li><p>fitting of input spectra to models and templates;</p></li>
<li><p>mcmc sampling of model parameter space;</p></li>
<li><p>nested sampling of model parameter space;</p></li>
<li><p>best fit search within a template library;</p></li>
<li><p>utility functions for the spectral fit.</p></li>
</ul>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="about.html" class="btn btn-neutral float-left" title="Contributions" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2019-2022, Valentin Christiaens.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>